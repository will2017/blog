<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK href="diff.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="nav.js"></script>
</head>
<body>
<div id="left" class="src">
<pre>
<a id='leftstart' tid='rightstart'></a>
// Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#<a id='6047' tid='6048' class='m'>include</a> <a id='6049' tid='6050' class='m'>&lt;</a><a id='6051' tid='6052' class='m'>stdlib</a><a id='6053' tid='6054' class='m'>.</a><a id='6055' tid='6056' class='m'>h</a><a id='6057' tid='6058' class='m'>&gt;</a>
#<a id='6035' tid='6036' class='m'>include</a> <a id='6037' tid='6038' class='m'>&lt;</a><a id='6039' tid='6040' class='m'>math</a><a id='6041' tid='6042' class='m'>.</a><a id='6043' tid='6044' class='m'>h</a><a id='6045' tid='6046' class='m'>&gt;</a>
<span class='d'>#include &lt;limits.h&gt;</span>
#<a id='6027' tid='6028' class='m'>include</a> <a id='6029' tid='6030' class='m'>&lt;</a><a id='6031' tid='6032' class='m'>cstdarg</a><a id='6033' tid='6034' class='m'>&gt;</a>
#<a id='6023' tid='6024' class='m'>include</a> <a id='6025' tid='6026' class='m'>&quot;v8.h&quot;</a>

<span class='d'>#if defined(V8_TARGET_ARCH_MIPS)</span>

#<a id='6019' tid='6020' class='m'>include</a> <a id='6021' tid='6022' class='m'>&quot;disasm.h&quot;</a>
#<a id='6015' tid='6016' class='m'>include</a> <a id='6017' tid='6018' class='m'>&quot;assembler.h&quot;</a>
<span class='d'>#include &quot;globals.h&quot;</span>    // Need the BitCast.
<span class='d'>#include &quot;mips/constants-mips.h&quot;</span>
<span class='d'>#include &quot;mips/simulator-mips.h&quot;</span>


// Only build the simulator if not compiling for real MIPS hardware.
#<a id='6005' tid='6006' class='m'>if</a> <a id='6007' tid='6008' class='m'>defined</a><a id='6009' tid='6010' class='m'>(</a><a id='6011' tid='6012' class='m'>USE_SIMULATOR</a><a id='6013' tid='6014' class='m'>)</a>

<span class='d'>namespace</span> <span class='d'>v8</span> {
<span class='d'>namespace</span> <span class='d'>internal</span> {

// Utils functions.
<span class='d'>bool HaveSameSign(int32_t a, int32_t b) {
  return ((a ^ b) &gt;= 0);
}</span>


<span class='d'>uint32_t get_fcsr_condition_bit(uint32_t cc) {
  if (cc == 0) {
    return 23;
  } else {
    return 24 + cc;
  }
}</span>


// This macro provides a platform independent use of sscanf. The reason for
// SScanF not being implemented in a platform independent was through
// ::v8::internal::OS in the same way as SNPrintF is that the Windows C Run-Time
// Library does not provide vsscanf.
#<a id='5999' tid='6000' class='m'>define</a> <a id='6001' tid='6002' class='m'>SScanF</a> <a id='6003' tid='6004' class='m'>sscanf</a>  // NOLINT

// The MipsDebugger class is used by the simulator while debugging simulated
// code.
<span class='d'>class</span> <span class='d'>MipsDebugger</span> {
 <span class='d'>public:</span>
  <span class='d'>explicit MipsDebugger(Simulator* sim)</span>;
  <span class='d'>~MipsDebugger();</span>

  <a id='5971' tid='5972' class='m'>void</a> <a id='5973' tid='5974' class='m'>Stop</a>(<a id='5975' tid='5976' class='m'>Instruction</a><a id='5977' tid='5978' class='m'>*</a> <a id='5979' tid='5980' class='m'>instr</a>);
  <span class='d'>void Debug()</span>;
  // Print all registers with a nice formatting.
  <span class='d'>void PrintAllRegs()</span>;
  <span class='d'>void PrintAllRegsIncludingFPU()</span>;

 <span class='d'>private:</span>
  // We set the breakpoint code to 0xfffff to easily recognize it.
  <span class='d'>static const Instr kBreakpointInstr = SPECIAL | BREAK | 0xfffff &lt;&lt; 6;</span>
  <span class='d'>static const Instr kNopInstr =  0x0;</span>

  <span class='d'>Simulator* sim_;</span>

  <span class='d'>int32_t GetRegisterValue(int regnum)</span>;
  <span class='d'>int32_t GetFPURegisterValueInt(int regnum)</span>;
  <span class='d'>int64_t GetFPURegisterValueLong(int regnum)</span>;
  <span class='d'>float GetFPURegisterValueFloat(int regnum)</span>;
  <span class='d'>double GetFPURegisterValueDouble(int regnum)</span>;
  <a id='5981' tid='5982' class='m'>bool</a> <a id='5983' tid='5984' class='m'>GetValue</a>(<a id='5985' tid='5986' class='m'>const</a> <a id='5987' tid='5988' class='m'>char</a><a id='5989' tid='5990' class='m'>*</a> <a id='5991' tid='5992' class='m'>desc</a>, <a id='5993' tid='5994' class='m'>int32_t</a><a id='5995' tid='5996' class='m'>*</a> <a id='5997' tid='5998' class='m'>value</a>);

  // Set or delete a breakpoint. Returns true if successful.
  <a id='5957' tid='5958' class='m'>bool</a> <a id='5959' tid='5960' class='m'>SetBreakpoint</a>(<a id='5961' tid='5962' class='m'>Instruction</a><a id='5963' tid='5964' class='m'>*</a> <a id='5965' tid='5966' class='m'>breakpc</a>);
  <a id='5937' tid='5938' class='m'>bool</a> <a id='5939' tid='5940' class='m'>DeleteBreakpoint</a>(<a id='5941' tid='5942' class='m'>Instruction</a><a id='5943' tid='5944' class='m'>*</a> <a id='5945' tid='5946' class='m'>breakpc</a>);

  // Undo and redo all breakpoints. This is needed to bracket disassembly and
  // execution to skip past breakpoints when run from the debugger.
  <span class='d'>void UndoBreakpoints()</span>;
  <span class='d'>void RedoBreakpoints()</span>;
};

<span class='d'>MipsDebugger::MipsDebugger(Simulator* sim) {
  sim_ = sim;
}</span>


<span class='d'>MipsDebugger::~MipsDebugger() {
}</span>


#<a id='5967' tid='5968' class='m'>ifdef</a> <a id='5969' tid='5970' class='m'>GENERATED_CODE_COVERAGE</a>
<a id='5947' tid='5948' class='m'>static</a> <a id='5949' tid='5950' class='m'>FILE</a><a id='5951' tid='5952' class='m'>*</a> <a id='5953' tid='5954' class='m'>coverage_log</a> = <a id='5955' tid='5956' class='m'>NULL</a>;


<a id='5903' tid='5904' class='m'>static</a> <a id='5905' tid='5906' class='m'>void</a> <a id='5907' tid='5908' class='m'>InitializeCoverage</a>() {
  <a id='5909' tid='5910' class='m'>char</a><a id='5911' tid='5912' class='m'>*</a> <a id='5913' tid='5914' class='m'>file_name</a> = <a id='5915' tid='5916' class='m'>getenv</a>(<a id='5917' tid='5918' class='m'>&quot;V8_GENERATED_CODE_COVERAGE_LOG&quot;</a>);
  <a id='5919' tid='5920' class='m'>if</a> (<a id='5921' tid='5922' class='m'>file_name</a> <a id='5923' tid='5924' class='m'>!=</a> <a id='5925' tid='5926' class='m'>NULL</a>) {
    <a id='5927' tid='5928' class='m'>coverage_log</a> <a id='5929' tid='5930' class='m'>=</a> <a id='5931' tid='5932' class='m'>fopen</a>(<a id='5933' tid='5934' class='m'>file_name</a>, <a id='5935' tid='5936' class='m'>&quot;aw+&quot;</a>);
  }
}


<span class='d'>void</span> <span class='d'>MipsDebugger::Stop</span>(<a id='5897' tid='5898' class='m'>Instruction</a><a id='5899' tid='5900' class='m'>*</a> <a id='5901' tid='5902' class='m'>instr</a>) {
  // Get the stop code.
  <span class='d'>uint32_t code = instr-&gt;Bits(25, 6);</span>
  // Retrieve the encoded address, which comes just after this stop.
  <a id='5871' tid='5872' class='m'>char</a><a id='5873' tid='5874' class='m'>*</a><a id='5875' tid='5876' class='m'>*</a> <a id='5877' tid='5878' class='m'>msg_address</a> =
    <a id='5879' tid='5880' class='m'>reinterpret_cast</a>&lt;<a id='5881' tid='5882' class='m'>char</a><a id='5883' tid='5884' class='m'>*</a><a id='5885' tid='5886' class='m'>*</a>&gt;(<a id='5887' tid='5888' class='m'>sim_</a>-&gt;<a id='5889' tid='5890' class='m'>get_pc</a>() <span class='d'>+</span> <span class='d'>Instr::kInstrSize</span>);
  <a id='5861' tid='5862' class='m'>char</a><a id='5863' tid='5864' class='m'>*</a> <a id='5865' tid='5866' class='m'>msg</a> = <a id='5867' tid='5868' class='m'>*</a><a id='5869' tid='5870' class='m'>msg_address</a>;
  <a id='5797' tid='5798' class='m'>ASSERT</a>(<a id='5799' tid='5800' class='m'>msg</a> <a id='5801' tid='5802' class='m'>!=</a> <a id='5803' tid='5804' class='m'>NULL</a>);

  // Update this stop description.
  <a id='5727' tid='5728' class='m'>if</a> (<a id='5729' tid='5730' class='m'>!</a><a id='5731' tid='5732' class='m'>watched_stops</a>[<a id='5733' tid='5734' class='m'>code</a>].<a id='5735' tid='5736' class='m'>desc</a>) {
    <a id='5737' tid='5738' class='m'>watched_stops</a>[<a id='5739' tid='5740' class='m'>code</a>].<a id='5741' tid='5742' class='m'>desc</a> <a id='5743' tid='5744' class='m'>=</a> <a id='5745' tid='5746' class='m'>msg</a>;
  }

  <a id='5673' tid='5674' class='m'>if</a> (<a id='5675' tid='5676' class='m'>strlen</a>(<a id='5677' tid='5678' class='m'>msg</a>) <a id='5679' tid='5680' class='m'>&gt;</a> <a id='5681' tid='5682' class='m'>0</a>) {
    <a id='5683' tid='5684' class='m'>if</a> (<a id='5685' tid='5686' class='m'>coverage_log</a> <a id='5687' tid='5688' class='m'>!=</a> <a id='5689' tid='5690' class='m'>NULL</a>) {
      <span class='d'>fprintf(coverage_log, &quot;%s\n&quot;, str);</span>
      <a id='5691' tid='5692' class='m'>fflush</a>(<a id='5693' tid='5694' class='m'>coverage_log</a>);
    }
    // Overwrite the instruction and address with nops.
    <a id='5611' tid='5612' class='m'>instr</a>-&gt;<a id='5613' tid='5614' class='m'>SetInstructionBits</a>(<a id='5615' tid='5616' class='m'>kNopInstr</a>);
    <span class='d'>reinterpret_cast&lt;Instr*&gt;(msg_address)-&gt;SetInstructionBits(kNopInstr);</span>
  }
  <a id='5603' tid='5604' class='m'>sim_</a>-&gt;<a id='5605' tid='5606' class='m'>set_pc</a>(<a id='5607' tid='5608' class='m'>sim_</a>-&gt;<a id='5609' tid='5610' class='m'>get_pc</a>() <span class='d'>+</span> <span class='d'>2 * Instruction::kInstructionSize</span>);
}


<span class='d'>#else</span>  // GENERATED_CODE_COVERAGE

<span class='d'>#define UNSUPPORTED() printf(&quot;Unsupported instruction.\n&quot;);</span>

<span class='d'>static void InitializeCoverage() {}</span>


<span class='d'>void</span> <span class='d'>MipsDebugger::Stop</span>(<a id='5891' tid='5892' class='m'>Instruction</a><a id='5893' tid='5894' class='m'>*</a> <a id='5895' tid='5896' class='m'>instr</a>) {
  // Get the stop code.
  <span class='d'>uint32_t code = instr-&gt;Bits(25, 6);</span>
  // Retrieve the encoded address, which comes just after this stop.
  <a id='5829' tid='5830' class='m'>char</a><a id='5831' tid='5832' class='m'>*</a> <a id='5833' tid='5834' class='m'>msg</a> = <a id='5835' tid='5836' class='m'>*</a><a id='5837' tid='5838' class='m'>reinterpret_cast</a>&lt;<a id='5839' tid='5840' class='m'>char</a><a id='5841' tid='5842' class='m'>*</a><a id='5843' tid='5844' class='m'>*</a>&gt;(<a id='5845' tid='5846' class='m'>sim_</a>-&gt;<a id='5847' tid='5848' class='m'>get_pc</a>() <a id='5849' tid='5850' class='m'>+</a>
      <a id='5851' tid='5852' class='m'>Instruction</a><a id='5853' tid='5854' class='m'>::</a><a id='5855' tid='5856' class='m'>kInstrSize</a>);
  // Update this stop description.
  <a id='5805' tid='5806' class='m'>if</a> (<a id='5807' tid='5808' class='m'>!</a><a id='5809' tid='5810' class='m'>sim_</a>-&gt;<a id='5811' tid='5812' class='m'>watched_stops</a>[<a id='5813' tid='5814' class='m'>code</a>].<a id='5815' tid='5816' class='m'>desc</a>) {
    <a id='5817' tid='5818' class='m'>sim_</a>-&gt;<a id='5819' tid='5820' class='m'>watched_stops</a>[<a id='5821' tid='5822' class='m'>code</a>].<a id='5823' tid='5824' class='m'>desc</a> <a id='5825' tid='5826' class='m'>=</a> <a id='5827' tid='5828' class='m'>msg</a>;
  }
  <span class='d'>PrintF(&quot;Simulator hit %s (%u)\n&quot;, msg, code);</span>
  <a id='5747' tid='5748' class='m'>sim_</a>-&gt;<a id='5749' tid='5750' class='m'>set_pc</a>(<a id='5751' tid='5752' class='m'>sim_</a>-&gt;<a id='5753' tid='5754' class='m'>get_pc</a>() <a id='5755' tid='5756' class='m'>+</a> <a id='5757' tid='5758' class='m'>2</a> <a id='5759' tid='5760' class='m'>*</a> <a id='5761' tid='5762' class='m'>Instruction</a><a id='5763' tid='5764' class='m'>::</a><a id='5765' tid='5766' class='m'>kInstrSize</a>);
  <span class='d'>Debug();</span>
}
<span class='d'>#endif</span>  // GENERATED_CODE_COVERAGE


<span class='d'>int32_t</span> <span class='d'>MipsDebugger::GetRegisterValue</span>(<a id='5857' tid='5858' class='m'>int</a> <a id='5859' tid='5860' class='m'>regnum</a>) {
  <span class='d'>if</span> <span class='d'>(regnum == kNumSimuRegisters)</span> {
    <a id='5777' tid='5778' class='m'>return</a> <a id='5779' tid='5780' class='m'>sim_</a>-&gt;<a id='5781' tid='5782' class='m'>get_pc</a>();
  } <a id='5767' tid='5768' class='m'>else</a> {
    <a id='5769' tid='5770' class='m'>return</a> <a id='5771' tid='5772' class='m'>sim_</a>-&gt;<a id='5773' tid='5774' class='m'>get_register</a>(<a id='5775' tid='5776' class='m'>regnum</a>);
  }
}


<span class='d'>int32_t MipsDebugger::GetFPURegisterValueInt(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register(regnum);
  }
}</span>


<span class='d'>int64_t MipsDebugger::GetFPURegisterValueLong(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_long(regnum);
  }
}</span>


<span class='d'>float MipsDebugger::GetFPURegisterValueFloat(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_float(regnum);
  }
}</span>


<span class='d'>double MipsDebugger::GetFPURegisterValueDouble(int regnum) {
  if (regnum == kNumFPURegisters) {
    return sim_-&gt;get_pc();
  } else {
    return sim_-&gt;get_fpu_register_double(regnum);
  }
}</span>


<span class='d'>bool</span> <span class='d'>MipsDebugger::GetValue</span>(<a id='5783' tid='5784' class='m'>const</a> <a id='5785' tid='5786' class='m'>char</a><a id='5787' tid='5788' class='m'>*</a> <a id='5789' tid='5790' class='m'>desc</a>, <a id='5791' tid='5792' class='m'>int32_t</a><a id='5793' tid='5794' class='m'>*</a> <a id='5795' tid='5796' class='m'>value</a>) {
  <a id='5709' tid='5710' class='m'>int</a> <a id='5711' tid='5712' class='m'>regnum</a> = <a id='5713' tid='5714' class='m'>Registers</a><a id='5715' tid='5716' class='m'>::</a><a id='5717' tid='5718' class='m'>Number</a>(<a id='5719' tid='5720' class='m'>desc</a>);
  <span class='d'>int fpuregnum = FPURegisters::Number(desc);</span>

  <span class='d'>if</span> <span class='d'>(regnum != kInvalidRegister)</span> {
    <a id='5695' tid='5696' class='m'>*</a><a id='5697' tid='5698' class='m'>value</a> <a id='5699' tid='5700' class='m'>=</a> <a id='5701' tid='5702' class='m'>GetRegisterValue</a>(<a id='5703' tid='5704' class='m'>regnum</a>);
    <a id='5705' tid='5706' class='m'>return</a> <a id='5707' tid='5708' class='m'>true</a>;
  } <span class='d'>else</span> <span class='d'>if</span> <span class='d'>(fpuregnum != kInvalidFPURegister)</span> <span class='d'>{
    *value = GetFPURegisterValueInt(fpuregnum);
    return true;
  }</span> <a id='5617' tid='5618' class='m'>else</a> <span class='d'>if</span> (<a id='5619' tid='5620' class='m'>strncmp</a>(<a id='5621' tid='5622' class='m'>desc</a>, <a id='5623' tid='5624' class='m'>&quot;0x&quot;</a>, <a id='5625' tid='5626' class='m'>2</a>) <a id='5627' tid='5628' class='m'>==</a> <a id='5629' tid='5630' class='m'>0</a>) {
    <a id='5527' tid='5528' class='m'>return</a> <a id='5529' tid='5530' class='m'>SScanF</a>(<span class='d'>desc</span>, <span class='d'>&quot;%x&quot;</span>, <a id='5531' tid='5532' class='m'>reinterpret_cast</a>&lt;<a id='5533' tid='5534' class='m'>uint32_t</a><a id='5535' tid='5536' class='m'>*</a>&gt;(<a id='5537' tid='5538' class='m'>value</a>)) <a id='5539' tid='5540' class='m'>==</a> <a id='5541' tid='5542' class='m'>1</a>;
  } <span class='d'>else {
    return SScanF(desc, &quot;%i&quot;, value) == 1;
  }</span>
  <span class='d'>return false;</span>
}


<span class='d'>bool</span> <span class='d'>MipsDebugger::SetBreakpoint</span>(<a id='5721' tid='5722' class='m'>Instruction</a><a id='5723' tid='5724' class='m'>*</a> <a id='5725' tid='5726' class='m'>breakpc</a>) {
  // Check if a breakpoint can be set. If not return without any side-effects.
  <a id='5631' tid='5632' class='m'>if</a> (<a id='5633' tid='5634' class='m'>sim_</a>-&gt;<a id='5635' tid='5636' class='m'>break_pc_</a> <a id='5637' tid='5638' class='m'>!=</a> <a id='5639' tid='5640' class='m'>NULL</a>) {
    <a id='5641' tid='5642' class='m'>return</a> <a id='5643' tid='5644' class='m'>false</a>;
  }

  // Set the breakpoint.
  <a id='5645' tid='5646' class='m'>sim_</a>-&gt;<a id='5647' tid='5648' class='m'>break_pc_</a> <a id='5649' tid='5650' class='m'>=</a> <a id='5651' tid='5652' class='m'>breakpc</a>;
  <a id='5653' tid='5654' class='m'>sim_</a>-&gt;<a id='5655' tid='5656' class='m'>break_instr_</a> <a id='5657' tid='5658' class='m'>=</a> <a id='5659' tid='5660' class='m'>breakpc</a>-&gt;<a id='5661' tid='5662' class='m'>InstructionBits</a>();
  // Not setting the breakpoint instruction in the code itself. It will be set
  // when the debugger shell continues.
  <a id='5663' tid='5664' class='m'>return</a> <a id='5665' tid='5666' class='m'>true</a>;
}


<span class='d'>bool</span> <span class='d'>MipsDebugger::DeleteBreakpoint</span>(<a id='5667' tid='5668' class='m'>Instruction</a><a id='5669' tid='5670' class='m'>*</a> <a id='5671' tid='5672' class='m'>breakpc</a>) {
  <a id='5543' tid='5544' class='m'>if</a> (<a id='5545' tid='5546' class='m'>sim_</a>-&gt;<a id='5547' tid='5548' class='m'>break_pc_</a> <a id='5549' tid='5550' class='m'>!=</a> <a id='5551' tid='5552' class='m'>NULL</a>) {
    <a id='5553' tid='5554' class='m'>sim_</a>-&gt;<a id='5555' tid='5556' class='m'>break_pc_</a>-&gt;<a id='5557' tid='5558' class='m'>SetInstructionBits</a>(<a id='5559' tid='5560' class='m'>sim_</a>-&gt;<a id='5561' tid='5562' class='m'>break_instr_</a>);
  }

  <a id='5563' tid='5564' class='m'>sim_</a>-&gt;<a id='5565' tid='5566' class='m'>break_pc_</a> <a id='5567' tid='5568' class='m'>=</a> <a id='5569' tid='5570' class='m'>NULL</a>;
  <a id='5571' tid='5572' class='m'>sim_</a>-&gt;<a id='5573' tid='5574' class='m'>break_instr_</a> <a id='5575' tid='5576' class='m'>=</a> <a id='5577' tid='5578' class='m'>0</a>;
  <a id='5579' tid='5580' class='m'>return</a> <a id='5581' tid='5582' class='m'>true</a>;
}


<span class='d'>void</span> <span class='d'>MipsDebugger::UndoBreakpoints</span><span class='d'>()</span> {
  <a id='5583' tid='5584' class='m'>if</a> (<a id='5585' tid='5586' class='m'>sim_</a>-&gt;<a id='5587' tid='5588' class='m'>break_pc_</a> <a id='5589' tid='5590' class='m'>!=</a> <a id='5591' tid='5592' class='m'>NULL</a>) {
    <a id='5593' tid='5594' class='m'>sim_</a>-&gt;<a id='5595' tid='5596' class='m'>break_pc_</a>-&gt;<a id='5597' tid='5598' class='m'>SetInstructionBits</a>(<a id='5599' tid='5600' class='m'>sim_</a>-&gt;<a id='5601' tid='5602' class='m'>break_instr_</a>);
  }
}


<span class='d'>void</span> <span class='d'>MipsDebugger::RedoBreakpoints</span><span class='d'>()</span> {
  <a id='5509' tid='5510' class='m'>if</a> (<a id='5511' tid='5512' class='m'>sim_</a>-&gt;<a id='5513' tid='5514' class='m'>break_pc_</a> <a id='5515' tid='5516' class='m'>!=</a> <a id='5517' tid='5518' class='m'>NULL</a>) {
    <a id='5519' tid='5520' class='m'>sim_</a>-&gt;<a id='5521' tid='5522' class='m'>break_pc_</a>-&gt;<a id='5523' tid='5524' class='m'>SetInstructionBits</a>(<a id='5525' tid='5526' class='m'>kBreakpointInstr</a>);
  }
}


<span class='d'>void MipsDebugger::PrintAllRegs() {
#define REG_INFO(n) Registers::Name(n), GetRegisterValue(n), GetRegisterValue(n)

  PrintF(&quot;\n&quot;);
  // at, v0, a0.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(1), REG_INFO(2), REG_INFO(4));
  // v1, a1.
  PrintF(&quot;%26s\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         &quot;&quot;, REG_INFO(3), REG_INFO(5));
  // a2.
  PrintF(&quot;%26s\t%26s\t%3s: 0x%08x %10d\n&quot;, &quot;&quot;, &quot;&quot;, REG_INFO(6));
  // a3.
  PrintF(&quot;%26s\t%26s\t%3s: 0x%08x %10d\n&quot;, &quot;&quot;, &quot;&quot;, REG_INFO(7));
  PrintF(&quot;\n&quot;);
  // t0-t7, s0-s7
  for (int i = 0; i &lt; 8; i++) {
    PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
           REG_INFO(8+i), REG_INFO(16+i));
  }
  PrintF(&quot;\n&quot;);
  // t8, k0, LO.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(24), REG_INFO(26), REG_INFO(32));
  // t9, k1, HI.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(25), REG_INFO(27), REG_INFO(33));
  // sp, fp, gp.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(29), REG_INFO(30), REG_INFO(28));
  // pc.
  PrintF(&quot;%3s: 0x%08x %10d\t%3s: 0x%08x %10d\n&quot;,
         REG_INFO(31), REG_INFO(34));

#undef REG_INFO
#undef FPU_REG_INFO
}</span>


<span class='d'>void MipsDebugger::PrintAllRegsIncludingFPU() {
#define FPU_REG_INFO(n) FPURegisters::Name(n), FPURegisters::Name(n+1), \
        GetFPURegisterValueInt(n+1), \
        GetFPURegisterValueInt(n), \
                        GetFPURegisterValueDouble(n)

  PrintAllRegs();

  PrintF(&quot;\n\n&quot;);
  // f0, f1, f2, ... f31.
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(0) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(2) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(4) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(6) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(8) );
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(10));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(12));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(14));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(16));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(18));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(20));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(22));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(24));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(26));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(28));
  PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;, FPU_REG_INFO(30));

#undef REG_INFO
#undef FPU_REG_INFO
}</span>


<span class='d'>void</span> <span class='d'>MipsDebugger::Debug</span><span class='d'>()</span> {
  <a id='5501' tid='5502' class='m'>intptr_t</a> <a id='5503' tid='5504' class='m'>last_pc</a> = <a id='5505' tid='5506' class='m'>-</a><a id='5507' tid='5508' class='m'>1</a>;
  <a id='4517' tid='4518' class='m'>bool</a> <a id='4519' tid='4520' class='m'>done</a> = <a id='4521' tid='4522' class='m'>false</a>;

#<a id='4523' tid='4524' class='m'>define</a> <a id='4525' tid='4526' class='m'>COMMAND_SIZE</a> <a id='4527' tid='4528' class='m'>63</a>
#<a id='4529' tid='4530' class='m'>define</a> <a id='4531' tid='4532' class='m'>ARG_SIZE</a> <a id='4533' tid='4534' class='m'>255</a>

#<a id='4535' tid='4536' class='m'>define</a> <a id='4537' tid='4538' class='m'>STR</a><a id='4539' tid='4540' class='m'>(</a><a id='4541' tid='4542' class='m'>a</a><a id='4543' tid='4544' class='m'>)</a> <a id='4545' tid='4546' class='m'>#</a><a id='4547' tid='4548' class='m'>a</a>
#<a id='4549' tid='4550' class='m'>define</a> <a id='4551' tid='4552' class='m'>XSTR</a><a id='4553' tid='4554' class='m'>(</a><a id='4555' tid='4556' class='m'>a</a><a id='4557' tid='4558' class='m'>)</a> <a id='4559' tid='4560' class='m'>STR</a><a id='4561' tid='4562' class='m'>(</a><a id='4563' tid='4564' class='m'>a</a><a id='4565' tid='4566' class='m'>)</a>

  <a id='4567' tid='4568' class='m'>char</a> <a id='4569' tid='4570' class='m'>cmd</a>[<a id='4571' tid='4572' class='m'>COMMAND_SIZE</a> <a id='4573' tid='4574' class='m'>+</a> <a id='4575' tid='4576' class='m'>1</a>];
  <a id='4577' tid='4578' class='m'>char</a> <a id='4579' tid='4580' class='m'>arg1</a>[<a id='4581' tid='4582' class='m'>ARG_SIZE</a> <a id='4583' tid='4584' class='m'>+</a> <a id='4585' tid='4586' class='m'>1</a>];
  <a id='4587' tid='4588' class='m'>char</a> <a id='4589' tid='4590' class='m'>arg2</a>[<a id='4591' tid='4592' class='m'>ARG_SIZE</a> <a id='4593' tid='4594' class='m'>+</a> <a id='4595' tid='4596' class='m'>1</a>];
  <a id='4597' tid='4598' class='m'>char</a><a id='4599' tid='4600' class='m'>*</a> <a id='4601' tid='4602' class='m'>argv</a>[<a id='4603' tid='4604' class='m'>3</a>] = { <a id='4605' tid='4606' class='m'>cmd</a>, <a id='4607' tid='4608' class='m'>arg1</a>, <a id='4609' tid='4610' class='m'>arg2</a> };

  // Make sure to have a proper terminating character if reaching the limit.
  <a id='4611' tid='4612' class='m'>cmd</a>[<a id='4613' tid='4614' class='m'>COMMAND_SIZE</a>] <a id='4615' tid='4616' class='m'>=</a> <a id='4617' tid='4618' class='m'>0</a>;
  <a id='4619' tid='4620' class='m'>arg1</a>[<a id='4621' tid='4622' class='m'>ARG_SIZE</a>] <a id='4623' tid='4624' class='m'>=</a> <a id='4625' tid='4626' class='m'>0</a>;
  <a id='4627' tid='4628' class='m'>arg2</a>[<a id='4629' tid='4630' class='m'>ARG_SIZE</a>] <a id='4631' tid='4632' class='m'>=</a> <a id='4633' tid='4634' class='m'>0</a>;

  // Undo all set breakpoints while running in the debugger shell. This will
  // make them invisible to all commands.
  <a id='4635' tid='4636' class='m'>UndoBreakpoints</a>();

  <a id='4637' tid='4638' class='m'>while</a> (<a id='4639' tid='4640' class='m'>!</a><a id='4641' tid='4642' class='m'>done</a> <span class='d'>&&</span> (<span class='d'>sim_-&gt;get_pc() != Simulator::end_sim_pc</span>)) {
    <a id='4643' tid='4644' class='m'>if</a> (<a id='4645' tid='4646' class='m'>last_pc</a> <a id='4647' tid='4648' class='m'>!=</a> <a id='4649' tid='4650' class='m'>sim_</a>-&gt;<a id='4651' tid='4652' class='m'>get_pc</a>()) {
      <a id='4663' tid='4664' class='m'>disasm</a><a id='4665' tid='4666' class='m'>::</a><a id='4667' tid='4668' class='m'>NameConverter</a> <a id='4669' tid='4670' class='m'>converter</a>;
      <a id='4653' tid='4654' class='m'>disasm</a><a id='4655' tid='4656' class='m'>::</a><a id='4657' tid='4658' class='m'>Disassembler</a> <a id='4659' tid='4660' class='m'>dasm</a>(<a id='4661' tid='4662' class='m'>converter</a>);
      // Use a reasonably large buffer.
      <a id='4671' tid='4672' class='m'>v8</a><a id='4673' tid='4674' class='m'>::</a><a id='4675' tid='4676' class='m'>internal</a><a id='4677' tid='4678' class='m'>::</a><a id='4679' tid='4680' class='m'>EmbeddedVector</a>&lt;<a id='4681' tid='4682' class='m'>char</a>, <a id='4683' tid='4684' class='m'>256</a>&gt; <a id='4685' tid='4686' class='m'>buffer</a>;
      <a id='4687' tid='4688' class='m'>dasm</a>.<a id='4689' tid='4690' class='m'>InstructionDecode</a>(<a id='4691' tid='4692' class='m'>buffer</a>,
                             <a id='4693' tid='4694' class='m'>reinterpret_cast</a>&lt;<a id='4695' tid='4696' class='m'>byte</a><a id='4697' tid='4698' class='m'>*</a>&gt;(<a id='4699' tid='4700' class='m'>sim_</a>-&gt;<a id='4701' tid='4702' class='m'>get_pc</a>()));
      <a id='4703' tid='4704' class='m'>PrintF</a>(<a id='4705' tid='4706' class='m'>&quot;  0x%08x  %s\n&quot;</a>, <a id='4707' tid='4708' class='m'>sim_</a>-&gt;<a id='4709' tid='4710' class='m'>get_pc</a>(), <a id='4711' tid='4712' class='m'>buffer</a>.<a id='4713' tid='4714' class='m'>start</a>());
      <a id='4715' tid='4716' class='m'>last_pc</a> <a id='4717' tid='4718' class='m'>=</a> <a id='4719' tid='4720' class='m'>sim_</a>-&gt;<a id='4721' tid='4722' class='m'>get_pc</a>();
    }
    <a id='4723' tid='4724' class='m'>char</a><a id='4725' tid='4726' class='m'>*</a> <a id='4727' tid='4728' class='m'>line</a> = <a id='4729' tid='4730' class='m'>ReadLine</a>(<a id='4731' tid='4732' class='m'>&quot;sim&gt; &quot;</a>);
    <a id='4733' tid='4734' class='m'>if</a> (<a id='4735' tid='4736' class='m'>line</a> <a id='4737' tid='4738' class='m'>==</a> <a id='4739' tid='4740' class='m'>NULL</a>) {
      <a id='4741' tid='4742' class='m'>break</a>;
    } <a id='4743' tid='4744' class='m'>else</a> {
      // Use sscanf to parse the individual parts of the command line. At the
      // moment no command expects more than two parameters.
      <a id='4745' tid='4746' class='m'>int</a> <a id='4747' tid='4748' class='m'>argc</a> = <a id='4749' tid='4750' class='m'>SScanF</a>(<a id='4751' tid='4752' class='m'>line</a>,
                        <a id='4753' tid='4754' class='m'>&quot;%&quot;</a> <a id='4755' tid='4756' class='m'>XSTR</a>(<a id='4757' tid='4758' class='m'>COMMAND_SIZE</a>) <a id='4759' tid='4760' class='m'>&quot;s &quot;</a>
                        <a id='4761' tid='4762' class='m'>&quot;%&quot;</a> <a id='4763' tid='4764' class='m'>XSTR</a>(<a id='4765' tid='4766' class='m'>ARG_SIZE</a>) <a id='4767' tid='4768' class='m'>&quot;s &quot;</a>
                        <a id='4769' tid='4770' class='m'>&quot;%&quot;</a> <a id='4771' tid='4772' class='m'>XSTR</a>(<a id='4773' tid='4774' class='m'>ARG_SIZE</a>) <a id='4775' tid='4776' class='m'>&quot;s&quot;</a>,
                        <a id='4777' tid='4778' class='m'>cmd</a>, <a id='4779' tid='4780' class='m'>arg1</a>, <a id='4781' tid='4782' class='m'>arg2</a>);
      <a id='4783' tid='4784' class='m'>if</a> ((<a id='4785' tid='4786' class='m'>strcmp</a>(<a id='4787' tid='4788' class='m'>cmd</a>, <a id='4789' tid='4790' class='m'>&quot;si&quot;</a>) <a id='4791' tid='4792' class='m'>==</a> <a id='4793' tid='4794' class='m'>0</a>) <a id='4795' tid='4796' class='m'>||</a> (<a id='4797' tid='4798' class='m'>strcmp</a>(<a id='4799' tid='4800' class='m'>cmd</a>, <a id='4801' tid='4802' class='m'>&quot;stepi&quot;</a>) <a id='4803' tid='4804' class='m'>==</a> <a id='4805' tid='4806' class='m'>0</a>)) {
        <a id='4807' tid='4808' class='m'>Instruction</a><a id='4809' tid='4810' class='m'>*</a> <span class='d'>instr = reinterpret_cast&lt;Instruction*&gt;(sim_-&gt;get_pc())</span>;
        <span class='d'>if (!(instr-&gt;IsTrap()) ||
            instr-&gt;InstructionBits() == rtCallRedirInstr) {
          sim_-&gt;InstructionDecode(
              reinterpret_cast&lt;Instruction*&gt;(sim_-&gt;get_pc()));
        } else {
          // Allow si to jump over generated breakpoints.
          PrintF(&quot;/!\\ Jumping over generated breakpoint.\n&quot;);
          sim_-&gt;set_pc(sim_-&gt;get_pc() + Instruction::kInstrSize);
        }</span>
      } <a id='4811' tid='4812' class='m'>else</a> <a id='4813' tid='4814' class='m'>if</a> ((<a id='4815' tid='4816' class='m'>strcmp</a>(<a id='4817' tid='4818' class='m'>cmd</a>, <a id='4819' tid='4820' class='m'>&quot;c&quot;</a>) <a id='4821' tid='4822' class='m'>==</a> <a id='4823' tid='4824' class='m'>0</a>) <a id='4825' tid='4826' class='m'>||</a> (<a id='4827' tid='4828' class='m'>strcmp</a>(<a id='4829' tid='4830' class='m'>cmd</a>, <a id='4831' tid='4832' class='m'>&quot;cont&quot;</a>) <a id='4833' tid='4834' class='m'>==</a> <a id='4835' tid='4836' class='m'>0</a>)) {
        // Execute the one instruction we broke at with breakpoints disabled.
        <a id='4837' tid='4838' class='m'>sim_</a>-&gt;<a id='4839' tid='4840' class='m'>InstructionDecode</a>(<a id='4841' tid='4842' class='m'>reinterpret_cast</a>&lt;<a id='4843' tid='4844' class='m'>Instruction</a><a id='4845' tid='4846' class='m'>*</a>&gt;(<a id='4847' tid='4848' class='m'>sim_</a>-&gt;<a id='4849' tid='4850' class='m'>get_pc</a>()));
        // Leave the debugger shell.
        <a id='4851' tid='4852' class='m'>done</a> <a id='4853' tid='4854' class='m'>=</a> <a id='4855' tid='4856' class='m'>true</a>;
      } <a id='4857' tid='4858' class='m'>else</a> <a id='4859' tid='4860' class='m'>if</a> ((<a id='4861' tid='4862' class='m'>strcmp</a>(<a id='4863' tid='4864' class='m'>cmd</a>, <a id='4865' tid='4866' class='m'>&quot;p&quot;</a>) <a id='4867' tid='4868' class='m'>==</a> <a id='4869' tid='4870' class='m'>0</a>) <a id='4871' tid='4872' class='m'>||</a> (<a id='4873' tid='4874' class='m'>strcmp</a>(<a id='4875' tid='4876' class='m'>cmd</a>, <a id='4877' tid='4878' class='m'>&quot;print&quot;</a>) <a id='4879' tid='4880' class='m'>==</a> <a id='4881' tid='4882' class='m'>0</a>)) {
        <a id='3735' tid='3736' class='m'>if</a> (<a id='4883' tid='4884' class='m'>argc</a> <a id='4885' tid='4886' class='m'>==</a> <a id='4887' tid='4888' class='m'>2</a>) {
          <a id='4427' tid='4428' class='m'>int32_t</a> <a id='4429' tid='4430' class='m'>value</a>;
          <span class='d'>float fvalue;</span>
          <span class='d'>if</span> (<a id='4035' tid='4036' class='m'>strcmp</a>(<a id='4037' tid='4038' class='m'>arg1</a>, <a id='4039' tid='4040' class='m'>&quot;all&quot;</a>) <a id='4041' tid='4042' class='m'>==</a> <a id='4043' tid='4044' class='m'>0</a>) <span class='d'>{
            PrintAllRegs();
          }</span> <span class='d'>else</span> <span class='d'>if</span> <span class='d'>(strcmp(arg1, &quot;allf&quot;) == 0)</span> <span class='d'>{
            PrintAllRegsIncludingFPU();
          }</span> <span class='d'>else</span> {
            <span class='d'>int regnum = Registers::Number(arg1);</span>
            <span class='d'>int fpuregnum = FPURegisters::Number(arg1);</span>

            <span class='d'>if</span> <span class='d'>(regnum != kInvalidRegister)</span> {
              <span class='d'>value = GetRegisterValue(regnum);</span>
              <a id='3743' tid='3744' class='m'>PrintF</a>(<a id='3745' tid='3746' class='m'>&quot;%s: 0x%08x %d \n&quot;</a>, <a id='3747' tid='3748' class='m'>arg1</a>, <a id='3749' tid='3750' class='m'>value</a>, <a id='3751' tid='3752' class='m'>value</a>);
            } <span class='d'>else</span> <span class='d'>if</span> <span class='d'>(fpuregnum != kInvalidFPURegister)</span> <span class='d'>{
              if (fpuregnum % 2 == 1) {
                value = GetFPURegisterValueInt(fpuregnum);
                fvalue = GetFPURegisterValueFloat(fpuregnum);
                PrintF(&quot;%s: 0x%08x %11.4e\n&quot;, arg1, value, fvalue);
              } else {
                double dfvalue;
                int32_t lvalue1 = GetFPURegisterValueInt(fpuregnum);
                int32_t lvalue2 = GetFPURegisterValueInt(fpuregnum + 1);
                dfvalue = GetFPURegisterValueDouble(fpuregnum);
                PrintF(&quot;%3s,%3s: 0x%08x%08x %16.4e\n&quot;,
                       FPURegisters::Name(fpuregnum+1),
                       FPURegisters::Name(fpuregnum),
                       lvalue1,
                       lvalue2,
                       dfvalue);
              }
            }</span> <a id='3619' tid='3620' class='m'>else</a> {
              <a id='3621' tid='3622' class='m'>PrintF</a>(<a id='3623' tid='3624' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='3625' tid='3626' class='m'>arg1</a>);
            }
          }
        } <span class='d'>else</span> {
          <span class='d'>if</span> (<a id='3737' tid='3738' class='m'>argc</a> <a id='3739' tid='3740' class='m'>==</a> <a id='3741' tid='3742' class='m'>3</a>) {
            <span class='d'>if</span> <span class='d'>(strcmp(arg2, &quot;single&quot;) == 0)</span> {
              <a id='3627' tid='3628' class='m'>int32_t</a> <a id='3629' tid='3630' class='m'>value</a>;
              <span class='d'>float fvalue;</span>
              <span class='d'>int fpuregnum = FPURegisters::Number(arg1);</span>

              <span class='d'>if (fpuregnum != kInvalidFPURegister) {
                value = GetFPURegisterValueInt(fpuregnum);
                fvalue = GetFPURegisterValueFloat(fpuregnum);
                PrintF(&quot;%s: 0x%08x %11.4e\n&quot;, arg1, value, fvalue);
              } else {
                PrintF(&quot;%s unrecognized\n&quot;, arg1);
              }</span>
            } <span class='d'>else {
              PrintF(&quot;print &lt;fpu register&gt; single\n&quot;);
            }</span>
          } <span class='d'>else {
            PrintF(&quot;print &lt;register&gt; or print &lt;fpu register&gt; single\n&quot;);
          }</span>
        }
      } <a id='4889' tid='4890' class='m'>else</a> <a id='4891' tid='4892' class='m'>if</a> ((<a id='4893' tid='4894' class='m'>strcmp</a>(<a id='4895' tid='4896' class='m'>cmd</a>, <a id='4897' tid='4898' class='m'>&quot;po&quot;</a>) <a id='4899' tid='4900' class='m'>==</a> <a id='4901' tid='4902' class='m'>0</a>)
                 <a id='4903' tid='4904' class='m'>||</a> (<a id='4905' tid='4906' class='m'>strcmp</a>(<a id='4907' tid='4908' class='m'>cmd</a>, <a id='4909' tid='4910' class='m'>&quot;printobject&quot;</a>) <a id='4911' tid='4912' class='m'>==</a> <a id='4913' tid='4914' class='m'>0</a>)) {
        <a id='4915' tid='4916' class='m'>if</a> (<a id='4917' tid='4918' class='m'>argc</a> <a id='4919' tid='4920' class='m'>==</a> <a id='4921' tid='4922' class='m'>2</a>) {
          <a id='4923' tid='4924' class='m'>int32_t</a> <a id='4925' tid='4926' class='m'>value</a>;
          <a id='4927' tid='4928' class='m'>if</a> (<a id='4929' tid='4930' class='m'>GetValue</a>(<a id='4931' tid='4932' class='m'>arg1</a>, <a id='4933' tid='4934' class='m'>&</a><a id='4935' tid='4936' class='m'>value</a>)) {
            <a id='4937' tid='4938' class='m'>Object</a><a id='4939' tid='4940' class='m'>*</a> <a id='4941' tid='4942' class='m'>obj</a> = <a id='4943' tid='4944' class='m'>reinterpret_cast</a>&lt;<a id='4945' tid='4946' class='m'>Object</a><a id='4947' tid='4948' class='m'>*</a>&gt;(<a id='4949' tid='4950' class='m'>value</a>);
            <a id='4951' tid='4952' class='m'>PrintF</a>(<a id='4953' tid='4954' class='m'>&quot;%s: \n&quot;</a>, <a id='4955' tid='4956' class='m'>arg1</a>);
#<a id='4957' tid='4958' class='m'>ifdef</a> <a id='4959' tid='4960' class='m'>DEBUG</a>
            <a id='4961' tid='4962' class='m'>obj</a>-&gt;<a id='4963' tid='4964' class='m'>PrintLn</a>();
#<a id='4965' tid='4966' class='m'>else</a>
            <a id='4967' tid='4968' class='m'>obj</a>-&gt;<a id='4969' tid='4970' class='m'>ShortPrint</a>();
            <a id='4971' tid='4972' class='m'>PrintF</a>(<a id='4973' tid='4974' class='m'>&quot;\n&quot;</a>);
#<a id='4975' tid='4976' class='m'>endif</a>
          } <a id='4977' tid='4978' class='m'>else</a> {
            <a id='4979' tid='4980' class='m'>PrintF</a>(<a id='4981' tid='4982' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='4983' tid='4984' class='m'>arg1</a>);
          }
        } <a id='4985' tid='4986' class='m'>else</a> {
          <a id='4987' tid='4988' class='m'>PrintF</a>(<a id='4989' tid='4990' class='m'>&quot;printobject &lt;value&gt;\n&quot;</a>);
        }
      } <a id='4991' tid='4992' class='m'>else</a> <a id='4993' tid='4994' class='m'>if</a> (<a id='4995' tid='4996' class='m'>strcmp</a>(<a id='4997' tid='4998' class='m'>cmd</a>, <a id='4999' tid='5000' class='m'>&quot;stack&quot;</a>) <a id='5001' tid='5002' class='m'>==</a> <a id='5003' tid='5004' class='m'>0</a> <a id='5005' tid='5006' class='m'>||</a> <a id='5007' tid='5008' class='m'>strcmp</a>(<a id='5009' tid='5010' class='m'>cmd</a>, <a id='5011' tid='5012' class='m'>&quot;mem&quot;</a>) <a id='5013' tid='5014' class='m'>==</a> <a id='5015' tid='5016' class='m'>0</a>) {
        <a id='5017' tid='5018' class='m'>int32_t</a><a id='5019' tid='5020' class='m'>*</a> <a id='5021' tid='5022' class='m'>cur</a> = <a id='5023' tid='5024' class='m'>NULL</a>;
        <a id='5025' tid='5026' class='m'>int32_t</a><a id='5027' tid='5028' class='m'>*</a> <a id='5029' tid='5030' class='m'>end</a> = <a id='5031' tid='5032' class='m'>NULL</a>;
        <a id='5033' tid='5034' class='m'>int</a> <a id='5035' tid='5036' class='m'>next_arg</a> = <a id='5037' tid='5038' class='m'>1</a>;

        <a id='5039' tid='5040' class='m'>if</a> (<a id='5041' tid='5042' class='m'>strcmp</a>(<a id='5043' tid='5044' class='m'>cmd</a>, <a id='5045' tid='5046' class='m'>&quot;stack&quot;</a>) <a id='5047' tid='5048' class='m'>==</a> <a id='5049' tid='5050' class='m'>0</a>) {
          <a id='5051' tid='5052' class='m'>cur</a> <a id='5053' tid='5054' class='m'>=</a> <a id='5055' tid='5056' class='m'>reinterpret_cast</a>&lt;<a id='5057' tid='5058' class='m'>int32_t</a><a id='5059' tid='5060' class='m'>*</a>&gt;(<a id='5061' tid='5062' class='m'>sim_</a>-&gt;<a id='5063' tid='5064' class='m'>get_register</a>(<a id='5065' tid='5066' class='m'>Simulator</a><a id='5067' tid='5068' class='m'>::</a><a id='5069' tid='5070' class='m'>sp</a>));
        } <a id='5071' tid='5072' class='m'>else</a> {  // Command &quot;mem&quot;.
          <a id='5073' tid='5074' class='m'>int32_t</a> <a id='5075' tid='5076' class='m'>value</a>;
          <a id='5077' tid='5078' class='m'>if</a> (<a id='5079' tid='5080' class='m'>!</a><a id='5081' tid='5082' class='m'>GetValue</a>(<a id='5083' tid='5084' class='m'>arg1</a>, <a id='5085' tid='5086' class='m'>&</a><a id='5087' tid='5088' class='m'>value</a>)) {
            <a id='5089' tid='5090' class='m'>PrintF</a>(<a id='5091' tid='5092' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='5093' tid='5094' class='m'>arg1</a>);
            <a id='5095' tid='5096' class='m'>continue</a>;
          }
          <a id='5097' tid='5098' class='m'>cur</a> <a id='5099' tid='5100' class='m'>=</a> <a id='5101' tid='5102' class='m'>reinterpret_cast</a>&lt;<a id='5103' tid='5104' class='m'>int32_t</a><a id='5105' tid='5106' class='m'>*</a>&gt;(<a id='5107' tid='5108' class='m'>value</a>);
          <a id='5109' tid='5110' class='m'>next_arg</a><a id='5111' tid='5112' class='m'>++</a>;
        }

        <a id='5113' tid='5114' class='m'>int32_t</a> <a id='5115' tid='5116' class='m'>words</a>;
        <a id='5117' tid='5118' class='m'>if</a> (<a id='5119' tid='5120' class='m'>argc</a> <a id='5121' tid='5122' class='m'>==</a> <a id='5123' tid='5124' class='m'>next_arg</a>) {
          <a id='5125' tid='5126' class='m'>words</a> <a id='5127' tid='5128' class='m'>=</a> <a id='5129' tid='5130' class='m'>10</a>;
        } <a id='5131' tid='5132' class='m'>else</a> <a id='5133' tid='5134' class='m'>if</a> (<a id='5135' tid='5136' class='m'>argc</a> <a id='5137' tid='5138' class='m'>==</a> <a id='5139' tid='5140' class='m'>next_arg</a> <a id='5141' tid='5142' class='m'>+</a> <a id='5143' tid='5144' class='m'>1</a>) {
          <a id='5145' tid='5146' class='m'>if</a> (<a id='5147' tid='5148' class='m'>!</a><a id='5149' tid='5150' class='m'>GetValue</a>(<a id='5151' tid='5152' class='m'>argv</a>[<a id='5153' tid='5154' class='m'>next_arg</a>], <a id='5155' tid='5156' class='m'>&</a><a id='5157' tid='5158' class='m'>words</a>)) {
            <a id='5159' tid='5160' class='m'>words</a> <a id='5161' tid='5162' class='m'>=</a> <a id='5163' tid='5164' class='m'>10</a>;
          }
        }
        <a id='5165' tid='5166' class='m'>end</a> <a id='5167' tid='5168' class='m'>=</a> <a id='5169' tid='5170' class='m'>cur</a> <a id='5171' tid='5172' class='m'>+</a> <a id='5173' tid='5174' class='m'>words</a>;

        <a id='5175' tid='5176' class='m'>while</a> (<a id='5177' tid='5178' class='m'>cur</a> <a id='5179' tid='5180' class='m'>&lt;</a> <a id='5181' tid='5182' class='m'>end</a>) {
          <a id='5183' tid='5184' class='m'>PrintF</a>(<a id='5185' tid='5186' class='m'>&quot;  0x%08x:  0x%08x %10d&quot;</a>,
                 <a id='5187' tid='5188' class='m'>reinterpret_cast</a>&lt;<a id='5189' tid='5190' class='m'>intptr_t</a>&gt;(<a id='5191' tid='5192' class='m'>cur</a>), <a id='5193' tid='5194' class='m'>*</a><a id='5195' tid='5196' class='m'>cur</a>, <a id='5197' tid='5198' class='m'>*</a><a id='5199' tid='5200' class='m'>cur</a>);
          <a id='5201' tid='5202' class='m'>HeapObject</a><a id='5203' tid='5204' class='m'>*</a> <a id='5205' tid='5206' class='m'>obj</a> = <a id='5207' tid='5208' class='m'>reinterpret_cast</a>&lt;<a id='5209' tid='5210' class='m'>HeapObject</a><a id='5211' tid='5212' class='m'>*</a>&gt;(<a id='5213' tid='5214' class='m'>*</a><a id='5215' tid='5216' class='m'>cur</a>);
          <a id='5217' tid='5218' class='m'>int</a> <a id='5219' tid='5220' class='m'>value</a> = <a id='5221' tid='5222' class='m'>*</a><a id='5223' tid='5224' class='m'>cur</a>;
          <a id='5225' tid='5226' class='m'>Heap</a><a id='5227' tid='5228' class='m'>*</a> <a id='5229' tid='5230' class='m'>current_heap</a> = <a id='5231' tid='5232' class='m'>v8</a><a id='5233' tid='5234' class='m'>::</a><a id='5235' tid='5236' class='m'>internal</a><a id='5237' tid='5238' class='m'>::</a><a id='5239' tid='5240' class='m'>Isolate</a><a id='5241' tid='5242' class='m'>::</a><a id='5243' tid='5244' class='m'>Current</a>()-&gt;<a id='5245' tid='5246' class='m'>heap</a>();
          <a id='5247' tid='5248' class='m'>if</a> (<a id='5249' tid='5250' class='m'>current_heap</a>-&gt;<a id='5251' tid='5252' class='m'>Contains</a>(<a id='5253' tid='5254' class='m'>obj</a>) <a id='5255' tid='5256' class='m'>||</a> ((<a id='5257' tid='5258' class='m'>value</a> <a id='5259' tid='5260' class='m'>&</a> <a id='5261' tid='5262' class='m'>1</a>) <a id='5263' tid='5264' class='m'>==</a> <a id='5265' tid='5266' class='m'>0</a>)) {
            <a id='5267' tid='5268' class='m'>PrintF</a>(<a id='5269' tid='5270' class='m'>&quot; (&quot;</a>);
            <a id='5271' tid='5272' class='m'>if</a> ((<a id='5273' tid='5274' class='m'>value</a> <a id='5275' tid='5276' class='m'>&</a> <a id='5277' tid='5278' class='m'>1</a>) <a id='5279' tid='5280' class='m'>==</a> <a id='5281' tid='5282' class='m'>0</a>) {
              <a id='5283' tid='5284' class='m'>PrintF</a>(<a id='5285' tid='5286' class='m'>&quot;smi %d&quot;</a>, <a id='5287' tid='5288' class='m'>value</a> <a id='5289' tid='5290' class='m'>/</a> <a id='5291' tid='5292' class='m'>2</a>);
            } <a id='5293' tid='5294' class='m'>else</a> {
              <a id='5295' tid='5296' class='m'>obj</a>-&gt;<a id='5297' tid='5298' class='m'>ShortPrint</a>();
            }
            <a id='5299' tid='5300' class='m'>PrintF</a>(<a id='5301' tid='5302' class='m'>&quot;)&quot;</a>);
          }
          <a id='5303' tid='5304' class='m'>PrintF</a>(<a id='5305' tid='5306' class='m'>&quot;\n&quot;</a>);
          <a id='5307' tid='5308' class='m'>cur</a><a id='5309' tid='5310' class='m'>++</a>;
        }

      } <a id='5311' tid='5312' class='m'>else</a> <a id='5313' tid='5314' class='m'>if</a> ((<a id='5315' tid='5316' class='m'>strcmp</a>(<a id='5317' tid='5318' class='m'>cmd</a>, <a id='5319' tid='5320' class='m'>&quot;disasm&quot;</a>) <span class='d'>==</span> <span class='d'>0</span>) <span class='d'>||</span>
                 (<span class='d'>strcmp(cmd, &quot;dpc&quot;) == 0</span>) <a id='5321' tid='5322' class='m'>||</a>
                 (<a id='5323' tid='5324' class='m'>strcmp</a>(<a id='5325' tid='5326' class='m'>cmd</a>, <a id='5327' tid='5328' class='m'>&quot;di&quot;</a>) <span class='d'>==</span> <span class='d'>0</span>)) {
        <a id='5329' tid='5330' class='m'>disasm</a><a id='5331' tid='5332' class='m'>::</a><a id='5333' tid='5334' class='m'>NameConverter</a> <a id='5335' tid='5336' class='m'>converter</a>;
        <a id='4431' tid='4432' class='m'>disasm</a><a id='4433' tid='4434' class='m'>::</a><a id='4435' tid='4436' class='m'>Disassembler</a> <a id='4437' tid='4438' class='m'>dasm</a>(<a id='4439' tid='4440' class='m'>converter</a>);
        // Use a reasonably large buffer.
        <a id='4045' tid='4046' class='m'>v8</a><a id='4047' tid='4048' class='m'>::</a><a id='4049' tid='4050' class='m'>internal</a><a id='4051' tid='4052' class='m'>::</a><a id='4053' tid='4054' class='m'>EmbeddedVector</a>&lt;<a id='4055' tid='4056' class='m'>char</a>, <a id='4057' tid='4058' class='m'>256</a>&gt; <a id='4059' tid='4060' class='m'>buffer</a>;

        <a id='3753' tid='3754' class='m'>byte</a><a id='3755' tid='3756' class='m'>*</a> <a id='3757' tid='3758' class='m'>cur</a> = <a id='3759' tid='3760' class='m'>NULL</a>;
        <a id='3063' tid='3064' class='m'>byte</a><a id='3065' tid='3066' class='m'>*</a> <a id='3067' tid='3068' class='m'>end</a> = <a id='3069' tid='3070' class='m'>NULL</a>;

        <span class='d'>if</span> <span class='d'>(argc == 1)</span> <span class='d'>{
          cur = reinterpret_cast&lt;byte*&gt;(sim_-&gt;get_pc());
          end = cur + (10 * Instruction::kInstrSize);
        }</span> <a id='3959' tid='3960' class='m'>else</a> <span class='d'>if</span> <span class='d'>(argc == 2)</span> {
          <a id='3087' tid='3088' class='m'>int</a> <a id='3089' tid='3090' class='m'>regnum</a> = <a id='3091' tid='3092' class='m'>Registers</a><a id='3093' tid='3094' class='m'>::</a><a id='3095' tid='3096' class='m'>Number</a>(<a id='3097' tid='3098' class='m'>arg1</a>);
          <a id='3099' tid='3100' class='m'>if</a> (<span class='d'>regnum != kInvalidRegister</span> <span class='d'>||</span> <a id='3101' tid='3102' class='m'>strncmp</a>(<a id='3103' tid='3104' class='m'>arg1</a>, <a id='3105' tid='3106' class='m'>&quot;0x&quot;</a>, <a id='3107' tid='3108' class='m'>2</a>) <a id='3109' tid='3110' class='m'>==</a> <a id='3111' tid='3112' class='m'>0</a>) {
            // The argument is an address or a register name.
            <span class='d'>int32_t value;</span>
            <span class='d'>if</span> (<a id='3961' tid='3962' class='m'>GetValue</a>(<a id='3963' tid='3964' class='m'>arg1</a>, <a id='3965' tid='3966' class='m'>&</a><a id='3967' tid='3968' class='m'>value</a>)) {
              <a id='3433' tid='3434' class='m'>cur</a> <a id='3435' tid='3436' class='m'>=</a> <a id='3437' tid='3438' class='m'>reinterpret_cast</a>&lt;<a id='3439' tid='3440' class='m'>byte</a><a id='3441' tid='3442' class='m'>*</a>&gt;<span class='d'>(value)</span>;
              // Disassemble 10 instructions at &lt;arg1&gt;.
              <a id='3113' tid='3114' class='m'>end</a> <a id='3115' tid='3116' class='m'>=</a> <a id='3117' tid='3118' class='m'>cur</a> <a id='3119' tid='3120' class='m'>+</a> (<a id='3121' tid='3122' class='m'>10</a> <a id='3123' tid='3124' class='m'>*</a> <a id='3125' tid='3126' class='m'>Instruction</a><a id='3127' tid='3128' class='m'>::</a><a id='3129' tid='3130' class='m'>kInstrSize</a>);
            }
          } <a id='3407' tid='3408' class='m'>else</a> {
            // The argument is the number of instructions.
            <span class='d'>int32_t value;</span>
            <a id='3131' tid='3132' class='m'>if</a> (<a id='3133' tid='3134' class='m'>GetValue</a>(<a id='3135' tid='3136' class='m'>arg1</a>, <a id='3137' tid='3138' class='m'>&</a><a id='3139' tid='3140' class='m'>value</a>)) {
              <a id='3409' tid='3410' class='m'>cur</a> <a id='3411' tid='3412' class='m'>=</a> <a id='3413' tid='3414' class='m'>reinterpret_cast</a>&lt;<a id='3415' tid='3416' class='m'>byte</a><a id='3417' tid='3418' class='m'>*</a>&gt;<span class='d'>(sim_-&gt;get_pc())</span>;
              // Disassemble &lt;arg1&gt; instructions.
              <a id='3419' tid='3420' class='m'>end</a> <a id='3421' tid='3422' class='m'>=</a> <a id='3423' tid='3424' class='m'>cur</a> <a id='3425' tid='3426' class='m'>+</a> (<span class='d'>value</span> <span class='d'>*</span> <a id='3427' tid='3428' class='m'>Instruction</a><a id='3429' tid='3430' class='m'>::</a><a id='3431' tid='3432' class='m'>kInstrSize</a>);
            }
          }
        } <span class='d'>else</span> {
          <span class='d'>int32_t value1;</span>
          <span class='d'>int32_t value2;</span>
          <span class='d'>if</span> <span class='d'>(GetValue(arg1, &value1) && GetValue(arg2, &value2))</span> {
            <a id='3383' tid='3384' class='m'>cur</a> <a id='3385' tid='3386' class='m'>=</a> <a id='3387' tid='3388' class='m'>reinterpret_cast</a>&lt;<a id='3389' tid='3390' class='m'>byte</a><a id='3391' tid='3392' class='m'>*</a>&gt;<span class='d'>(value1)</span>;
            <a id='3393' tid='3394' class='m'>end</a> <a id='3395' tid='3396' class='m'>=</a> <a id='3397' tid='3398' class='m'>cur</a> <a id='3399' tid='3400' class='m'>+</a> (<span class='d'>value2</span> <span class='d'>*</span> <a id='3401' tid='3402' class='m'>Instruction</a><a id='3403' tid='3404' class='m'>::</a><a id='3405' tid='3406' class='m'>kInstrSize</a>);
          }
        }

        <a id='3071' tid='3072' class='m'>while</a> (<a id='3073' tid='3074' class='m'>cur</a> <a id='3075' tid='3076' class='m'>&lt;</a> <a id='3077' tid='3078' class='m'>end</a>) {
          <a id='3079' tid='3080' class='m'>dasm</a>.<a id='3081' tid='3082' class='m'>InstructionDecode</a>(<a id='3083' tid='3084' class='m'>buffer</a>, <a id='3085' tid='3086' class='m'>cur</a>);
          <span class='d'>PrintF(&quot;  0x%08x  %s\n&quot;,
              reinterpret_cast&lt;intptr_t&gt;(cur), buffer.start());</span>
          <span class='d'>cur += Instruction::kInstrSize;</span>
        }
      } <a id='5337' tid='5338' class='m'>else</a> <a id='5339' tid='5340' class='m'>if</a> (<a id='5341' tid='5342' class='m'>strcmp</a>(<a id='5343' tid='5344' class='m'>cmd</a>, <a id='5345' tid='5346' class='m'>&quot;gdb&quot;</a>) <a id='5347' tid='5348' class='m'>==</a> <a id='5349' tid='5350' class='m'>0</a>) {
        <a id='5351' tid='5352' class='m'>PrintF</a>(<a id='5353' tid='5354' class='m'>&quot;relinquishing control to gdb\n&quot;</a>);
        <a id='5355' tid='5356' class='m'>v8</a><a id='5357' tid='5358' class='m'>::</a><a id='5359' tid='5360' class='m'>internal</a><a id='5361' tid='5362' class='m'>::</a><a id='5363' tid='5364' class='m'>OS</a><a id='5365' tid='5366' class='m'>::</a><a id='5367' tid='5368' class='m'>DebugBreak</a>();
        <a id='5369' tid='5370' class='m'>PrintF</a>(<a id='5371' tid='5372' class='m'>&quot;regaining control from gdb\n&quot;</a>);
      } <a id='5373' tid='5374' class='m'>else</a> <a id='5375' tid='5376' class='m'>if</a> (<a id='5377' tid='5378' class='m'>strcmp</a>(<a id='5379' tid='5380' class='m'>cmd</a>, <a id='5381' tid='5382' class='m'>&quot;break&quot;</a>) <a id='5383' tid='5384' class='m'>==</a> <a id='5385' tid='5386' class='m'>0</a>) {
        <a id='5387' tid='5388' class='m'>if</a> (<a id='5389' tid='5390' class='m'>argc</a> <a id='5391' tid='5392' class='m'>==</a> <a id='5393' tid='5394' class='m'>2</a>) {
          <a id='5395' tid='5396' class='m'>int32_t</a> <a id='5397' tid='5398' class='m'>value</a>;
          <a id='5399' tid='5400' class='m'>if</a> (<a id='5401' tid='5402' class='m'>GetValue</a>(<a id='5403' tid='5404' class='m'>arg1</a>, <a id='5405' tid='5406' class='m'>&</a><a id='5407' tid='5408' class='m'>value</a>)) {
            <a id='5409' tid='5410' class='m'>if</a> (<a id='5411' tid='5412' class='m'>!</a><a id='5413' tid='5414' class='m'>SetBreakpoint</a>(<a id='5415' tid='5416' class='m'>reinterpret_cast</a>&lt;<a id='5417' tid='5418' class='m'>Instruction</a><a id='5419' tid='5420' class='m'>*</a>&gt;(<a id='5421' tid='5422' class='m'>value</a>))) {
              <a id='5423' tid='5424' class='m'>PrintF</a>(<a id='5425' tid='5426' class='m'>&quot;setting breakpoint failed\n&quot;</a>);
            }
          } <a id='5427' tid='5428' class='m'>else</a> {
            <a id='5429' tid='5430' class='m'>PrintF</a>(<a id='5431' tid='5432' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='5433' tid='5434' class='m'>arg1</a>);
          }
        } <a id='5435' tid='5436' class='m'>else</a> {
          <a id='5437' tid='5438' class='m'>PrintF</a>(<a id='5439' tid='5440' class='m'>&quot;break &lt;address&gt;\n&quot;</a>);
        }
      } <a id='5441' tid='5442' class='m'>else</a> <a id='5443' tid='5444' class='m'>if</a> (<a id='5445' tid='5446' class='m'>strcmp</a>(<a id='5447' tid='5448' class='m'>cmd</a>, <a id='5449' tid='5450' class='m'>&quot;del&quot;</a>) <a id='5451' tid='5452' class='m'>==</a> <a id='5453' tid='5454' class='m'>0</a>) {
        <a id='5455' tid='5456' class='m'>if</a> (<a id='5457' tid='5458' class='m'>!</a><a id='5459' tid='5460' class='m'>DeleteBreakpoint</a>(<a id='5461' tid='5462' class='m'>NULL</a>)) {
          <a id='5463' tid='5464' class='m'>PrintF</a>(<a id='5465' tid='5466' class='m'>&quot;deleting breakpoint failed\n&quot;</a>);
        }
      } <a id='5467' tid='5468' class='m'>else</a> <span class='d'>if</span> (<a id='5469' tid='5470' class='m'>strcmp</a>(<a id='5471' tid='5472' class='m'>cmd</a>, <a id='5473' tid='5474' class='m'>&quot;flags&quot;</a>) <a id='5475' tid='5476' class='m'>==</a> <a id='5477' tid='5478' class='m'>0</a>) <span class='d'>{
        PrintF(&quot;No flags on MIPS !\n&quot;);
      }</span> <span class='d'>else</span> <a id='4061' tid='4062' class='m'>if</a> (<a id='4441' tid='4442' class='m'>strcmp</a>(<a id='4443' tid='4444' class='m'>cmd</a>, <a id='4445' tid='4446' class='m'>&quot;stop&quot;</a>) <a id='4447' tid='4448' class='m'>==</a> <a id='4449' tid='4450' class='m'>0</a>) {
        <a id='4063' tid='4064' class='m'>int32_t</a> <a id='4065' tid='4066' class='m'>value</a>;
        <a id='4067' tid='4068' class='m'>intptr_t</a> <a id='4069' tid='4070' class='m'>stop_pc</a> = <a id='4071' tid='4072' class='m'>sim_</a>-&gt;<a id='4073' tid='4074' class='m'>get_pc</a>() <a id='4075' tid='4076' class='m'>-</a>
            <a id='4077' tid='4078' class='m'>2</a> <a id='4079' tid='4080' class='m'>*</a> <a id='4081' tid='4082' class='m'>Instruction</a><a id='4083' tid='4084' class='m'>::</a><a id='4085' tid='4086' class='m'>kInstrSize</a>;
        <a id='4087' tid='4088' class='m'>Instruction</a><a id='4089' tid='4090' class='m'>*</a> <a id='4091' tid='4092' class='m'>stop_instr</a> = <a id='4093' tid='4094' class='m'>reinterpret_cast</a>&lt;<a id='4095' tid='4096' class='m'>Instruction</a><a id='4097' tid='4098' class='m'>*</a>&gt;(<a id='4099' tid='4100' class='m'>stop_pc</a>);
        <a id='4101' tid='4102' class='m'>Instruction</a><a id='4103' tid='4104' class='m'>*</a> <a id='4105' tid='4106' class='m'>msg_address</a> =
          <a id='4107' tid='4108' class='m'>reinterpret_cast</a>&lt;<a id='4109' tid='4110' class='m'>Instruction</a><a id='4111' tid='4112' class='m'>*</a>&gt;(<a id='4113' tid='4114' class='m'>stop_pc</a> <a id='4115' tid='4116' class='m'>+</a>
              <a id='4117' tid='4118' class='m'>Instruction</a><a id='4119' tid='4120' class='m'>::</a><a id='4121' tid='4122' class='m'>kInstrSize</a>);
        <a id='4123' tid='4124' class='m'>if</a> ((<a id='4125' tid='4126' class='m'>argc</a> <a id='4127' tid='4128' class='m'>==</a> <a id='4129' tid='4130' class='m'>2</a>) <a id='4131' tid='4132' class='m'>&&</a> (<a id='4133' tid='4134' class='m'>strcmp</a>(<a id='4135' tid='4136' class='m'>arg1</a>, <a id='4137' tid='4138' class='m'>&quot;unstop&quot;</a>) <a id='4139' tid='4140' class='m'>==</a> <a id='4141' tid='4142' class='m'>0</a>)) {
          // Remove the current stop.
          <span class='d'>if</span> <span class='d'>(sim_-&gt;IsStopInstruction(stop_instr))</span> {
            <a id='4143' tid='4144' class='m'>stop_instr</a>-&gt;<a id='4145' tid='4146' class='m'>SetInstructionBits</a>(<a id='4147' tid='4148' class='m'>kNopInstr</a>);
            <a id='4149' tid='4150' class='m'>msg_address</a>-&gt;<a id='4151' tid='4152' class='m'>SetInstructionBits</a>(<a id='4153' tid='4154' class='m'>kNopInstr</a>);
          } <a id='3761' tid='3762' class='m'>else</a> {
            <a id='3763' tid='3764' class='m'>PrintF</a>(<a id='3765' tid='3766' class='m'>&quot;Not at debugger stop.\n&quot;</a>);
          }
        } <a id='4155' tid='4156' class='m'>else</a> <a id='4157' tid='4158' class='m'>if</a> (<a id='4159' tid='4160' class='m'>argc</a> <a id='4161' tid='4162' class='m'>==</a> <a id='4163' tid='4164' class='m'>3</a>) {
          // Print information about all/the specified breakpoint(s).
          <a id='4165' tid='4166' class='m'>if</a> (<a id='4167' tid='4168' class='m'>strcmp</a>(<a id='4169' tid='4170' class='m'>arg1</a>, <a id='4171' tid='4172' class='m'>&quot;info&quot;</a>) <a id='4173' tid='4174' class='m'>==</a> <a id='4175' tid='4176' class='m'>0</a>) {
            <a id='4177' tid='4178' class='m'>if</a> (<a id='4179' tid='4180' class='m'>strcmp</a>(<a id='4181' tid='4182' class='m'>arg2</a>, <a id='4183' tid='4184' class='m'>&quot;all&quot;</a>) <a id='4185' tid='4186' class='m'>==</a> <a id='4187' tid='4188' class='m'>0</a>) {
              <a id='4189' tid='4190' class='m'>PrintF</a>(<a id='4191' tid='4192' class='m'>&quot;Stop information:\n&quot;</a>);
              <a id='4193' tid='4194' class='m'>for</a> (<span class='d'>uint32_t i = kMaxWatchpointCode + 1</span>;
                   <span class='d'>i &lt;= kMaxStopCode</span>;
                   <a id='4195' tid='4196' class='m'>i</a><a id='4197' tid='4198' class='m'>++</a>) {
                <a id='4199' tid='4200' class='m'>sim_</a>-&gt;<a id='4201' tid='4202' class='m'>PrintStopInfo</a>(<a id='4203' tid='4204' class='m'>i</a>);
              }
            } <a id='4205' tid='4206' class='m'>else</a> <a id='4207' tid='4208' class='m'>if</a> (<a id='4209' tid='4210' class='m'>GetValue</a>(<a id='4211' tid='4212' class='m'>arg2</a>, <a id='4213' tid='4214' class='m'>&</a><a id='4215' tid='4216' class='m'>value</a>)) {
              <a id='4217' tid='4218' class='m'>sim_</a>-&gt;<a id='4219' tid='4220' class='m'>PrintStopInfo</a>(<a id='4221' tid='4222' class='m'>value</a>);
            } <a id='4223' tid='4224' class='m'>else</a> {
              <a id='4225' tid='4226' class='m'>PrintF</a>(<a id='4227' tid='4228' class='m'>&quot;Unrecognized argument.\n&quot;</a>);
            }
          } <a id='4229' tid='4230' class='m'>else</a> <a id='4231' tid='4232' class='m'>if</a> (<a id='4233' tid='4234' class='m'>strcmp</a>(<a id='4235' tid='4236' class='m'>arg1</a>, <a id='4237' tid='4238' class='m'>&quot;enable&quot;</a>) <a id='4239' tid='4240' class='m'>==</a> <a id='4241' tid='4242' class='m'>0</a>) {
            // Enable all/the specified breakpoint(s).
            <a id='4243' tid='4244' class='m'>if</a> (<a id='4245' tid='4246' class='m'>strcmp</a>(<a id='4247' tid='4248' class='m'>arg2</a>, <a id='4249' tid='4250' class='m'>&quot;all&quot;</a>) <a id='4251' tid='4252' class='m'>==</a> <a id='4253' tid='4254' class='m'>0</a>) {
              <a id='4255' tid='4256' class='m'>for</a> (<span class='d'>uint32_t i = kMaxWatchpointCode + 1</span>;
                   <span class='d'>i &lt;= kMaxStopCode</span>;
                   <a id='4257' tid='4258' class='m'>i</a><a id='4259' tid='4260' class='m'>++</a>) {
                <a id='4261' tid='4262' class='m'>sim_</a>-&gt;<a id='4263' tid='4264' class='m'>EnableStop</a>(<a id='4265' tid='4266' class='m'>i</a>);
              }
            } <a id='4267' tid='4268' class='m'>else</a> <a id='4269' tid='4270' class='m'>if</a> (<a id='4271' tid='4272' class='m'>GetValue</a>(<a id='4273' tid='4274' class='m'>arg2</a>, <a id='4275' tid='4276' class='m'>&</a><a id='4277' tid='4278' class='m'>value</a>)) {
              <a id='4279' tid='4280' class='m'>sim_</a>-&gt;<a id='4281' tid='4282' class='m'>EnableStop</a>(<a id='4283' tid='4284' class='m'>value</a>);
            } <a id='4285' tid='4286' class='m'>else</a> {
              <a id='4287' tid='4288' class='m'>PrintF</a>(<a id='4289' tid='4290' class='m'>&quot;Unrecognized argument.\n&quot;</a>);
            }
          } <a id='4291' tid='4292' class='m'>else</a> <a id='4293' tid='4294' class='m'>if</a> (<a id='4295' tid='4296' class='m'>strcmp</a>(<a id='4297' tid='4298' class='m'>arg1</a>, <a id='4299' tid='4300' class='m'>&quot;disable&quot;</a>) <a id='4301' tid='4302' class='m'>==</a> <a id='4303' tid='4304' class='m'>0</a>) {
            // Disable all/the specified breakpoint(s).
            <a id='4305' tid='4306' class='m'>if</a> (<a id='4307' tid='4308' class='m'>strcmp</a>(<a id='4309' tid='4310' class='m'>arg2</a>, <a id='4311' tid='4312' class='m'>&quot;all&quot;</a>) <a id='4313' tid='4314' class='m'>==</a> <a id='4315' tid='4316' class='m'>0</a>) {
              <a id='4317' tid='4318' class='m'>for</a> (<span class='d'>uint32_t i = kMaxWatchpointCode + 1</span>;
                   <span class='d'>i &lt;= kMaxStopCode</span>;
                   <a id='4319' tid='4320' class='m'>i</a><a id='4321' tid='4322' class='m'>++</a>) {
                <a id='4323' tid='4324' class='m'>sim_</a>-&gt;<a id='4325' tid='4326' class='m'>DisableStop</a>(<a id='4327' tid='4328' class='m'>i</a>);
              }
            } <a id='4329' tid='4330' class='m'>else</a> <a id='4331' tid='4332' class='m'>if</a> (<a id='4333' tid='4334' class='m'>GetValue</a>(<a id='4335' tid='4336' class='m'>arg2</a>, <a id='4337' tid='4338' class='m'>&</a><a id='4339' tid='4340' class='m'>value</a>)) {
              <a id='4341' tid='4342' class='m'>sim_</a>-&gt;<a id='4343' tid='4344' class='m'>DisableStop</a>(<a id='4345' tid='4346' class='m'>value</a>);
            } <a id='4347' tid='4348' class='m'>else</a> {
              <a id='4349' tid='4350' class='m'>PrintF</a>(<a id='4351' tid='4352' class='m'>&quot;Unrecognized argument.\n&quot;</a>);
            }
          }
        } <a id='4353' tid='4354' class='m'>else</a> {
          <a id='4355' tid='4356' class='m'>PrintF</a>(<a id='4357' tid='4358' class='m'>&quot;Wrong usage. Use help command for more information.\n&quot;</a>);
        }
      } <a id='4359' tid='4360' class='m'>else</a> <span class='d'>if</span> <span class='d'>((strcmp(cmd, &quot;stat&quot;) == 0) || (strcmp(cmd, &quot;st&quot;) == 0))</span> {
        // Print registers and disassemble.
        <span class='d'>PrintAllRegs();</span>
        <a id='2983' tid='2984' class='m'>PrintF</a>(<a id='2985' tid='2986' class='m'>&quot;\n&quot;</a>);

        <span class='d'>disasm::NameConverter converter;</span>
        <span class='d'>disasm::Disassembler dasm(converter)</span>;
        // Use a reasonably large buffer.
        <span class='d'>v8::internal::EmbeddedVector&lt;char, 256&gt; buffer;</span>

        <a id='3969' tid='3970' class='m'>byte</a><a id='3971' tid='3972' class='m'>*</a> <span class='d'>cur = NULL</span>;
        <a id='3443' tid='3444' class='m'>byte</a><a id='3445' tid='3446' class='m'>*</a> <span class='d'>end = NULL</span>;

        <span class='d'>if</span> <span class='d'>(argc == 1)</span> <span class='d'>{
          cur = reinterpret_cast&lt;byte*&gt;(sim_-&gt;get_pc());
          end = cur + (10 * Instruction::kInstrSize);
        }</span> <span class='d'>else</span> <span class='d'>if</span> <span class='d'>(argc == 2)</span> {
          <span class='d'>int32_t value;</span>
          <span class='d'>if</span> (<a id='2987' tid='2988' class='m'>GetValue</a>(<a id='2989' tid='2990' class='m'>arg1</a>, <a id='2991' tid='2992' class='m'>&</a><a id='2993' tid='2994' class='m'>value</a>)) <span class='d'>{
            cur = reinterpret_cast&lt;byte*&gt;(value);
            // no length parameter passed, assume 10 instructions
            end = cur + (10 * Instruction::kInstrSize);
          }</span>
        } <span class='d'>else</span> {
          <span class='d'>int32_t value1;</span>
          <span class='d'>int32_t value2;</span>
          <span class='d'>if</span> (<a id='3141' tid='3142' class='m'>GetValue</a>(<a id='3143' tid='3144' class='m'>arg1</a>, <a id='3145' tid='3146' class='m'>&</a><a id='3147' tid='3148' class='m'>value1</a>) <a id='3149' tid='3150' class='m'>&&</a> <a id='3151' tid='3152' class='m'>GetValue</a>(<a id='3153' tid='3154' class='m'>arg2</a>, <a id='3155' tid='3156' class='m'>&</a><a id='3157' tid='3158' class='m'>value2</a>)) {
            <span class='d'>cur = reinterpret_cast&lt;byte*&gt;(value1);</span>
            <a id='2995' tid='2996' class='m'>end</a> <a id='2997' tid='2998' class='m'>=</a> <a id='2999' tid='3000' class='m'>cur</a> <a id='3001' tid='3002' class='m'>+</a> (<span class='d'>value2</span> <span class='d'>*</span> <a id='3003' tid='3004' class='m'>Instruction</a><a id='3005' tid='3006' class='m'>::</a><a id='3007' tid='3008' class='m'>kInstrSize</a>);
          }
        }

        <span class='d'>while</span> <span class='d'>(cur &lt; end)</span> {
          <span class='d'>dasm.InstructionDecode(buffer, cur);</span>
          <a id='2909' tid='2910' class='m'>PrintF</a>(<a id='2911' tid='2912' class='m'>&quot;  0x%08x  %s\n&quot;</a>,
                 <a id='2913' tid='2914' class='m'>reinterpret_cast</a>&lt;<a id='2915' tid='2916' class='m'>intptr_t</a>&gt;<span class='d'>(cur)</span>, <a id='2917' tid='2918' class='m'>buffer</a>.<a id='2919' tid='2920' class='m'>start</a>());
          <span class='d'>cur += Instruction::kInstrSize;</span>
        }
      } <a id='4361' tid='4362' class='m'>else</a> <a id='4363' tid='4364' class='m'>if</a> ((<a id='4365' tid='4366' class='m'>strcmp</a>(<a id='4367' tid='4368' class='m'>cmd</a>, <a id='4369' tid='4370' class='m'>&quot;h&quot;</a>) <a id='4371' tid='4372' class='m'>==</a> <a id='4373' tid='4374' class='m'>0</a>) <a id='4375' tid='4376' class='m'>||</a> (<a id='4377' tid='4378' class='m'>strcmp</a>(<a id='4379' tid='4380' class='m'>cmd</a>, <a id='4381' tid='4382' class='m'>&quot;help&quot;</a>) <a id='4383' tid='4384' class='m'>==</a> <a id='4385' tid='4386' class='m'>0</a>)) {
        <a id='4387' tid='4388' class='m'>PrintF</a>(<a id='4389' tid='4390' class='m'>&quot;cont\n&quot;</a>);
        <a id='3973' tid='3974' class='m'>PrintF</a>(<a id='3975' tid='3976' class='m'>&quot;  continue execution (alias &#39;c&#39;)\n&quot;</a>);
        <a id='3767' tid='3768' class='m'>PrintF</a>(<a id='3769' tid='3770' class='m'>&quot;stepi\n&quot;</a>);
        <a id='3631' tid='3632' class='m'>PrintF</a>(<a id='3633' tid='3634' class='m'>&quot;  step one instruction (alias &#39;si&#39;)\n&quot;</a>);
        <a id='3447' tid='3448' class='m'>PrintF</a>(<a id='3449' tid='3450' class='m'>&quot;print &lt;register&gt;\n&quot;</a>);
        <a id='3159' tid='3160' class='m'>PrintF</a>(<a id='3161' tid='3162' class='m'>&quot;  print register content (alias &#39;p&#39;)\n&quot;</a>);
        <a id='3009' tid='3010' class='m'>PrintF</a>(<a id='3011' tid='3012' class='m'>&quot;  use register name &#39;all&#39; to print all registers\n&quot;</a>);
        <a id='2921' tid='2922' class='m'>PrintF</a>(<a id='2923' tid='2924' class='m'>&quot;printobject &lt;register&gt;\n&quot;</a>);
        <a id='2611' tid='2612' class='m'>PrintF</a>(<a id='2613' tid='2614' class='m'>&quot;  print an object from a register (alias &#39;po&#39;)\n&quot;</a>);
        <a id='2433' tid='2434' class='m'>PrintF</a>(<a id='2435' tid='2436' class='m'>&quot;stack [&lt;words&gt;]\n&quot;</a>);
        <a id='2385' tid='2386' class='m'>PrintF</a>(<a id='2387' tid='2388' class='m'>&quot;  dump stack content, default dump 10 words)\n&quot;</a>);
        <a id='2363' tid='2364' class='m'>PrintF</a>(<a id='2365' tid='2366' class='m'>&quot;mem &lt;address&gt; [&lt;words&gt;]\n&quot;</a>);
        <a id='2295' tid='2296' class='m'>PrintF</a>(<a id='2297' tid='2298' class='m'>&quot;  dump memory content, default dump 10 words)\n&quot;</a>);
        <a id='2551' tid='2552' class='m'>PrintF</a>(<a id='2553' tid='2554' class='m'>&quot;flags\n&quot;</a>);
        <a id='2495' tid='2496' class='m'>PrintF</a>(<a id='2497' tid='2498' class='m'>&quot;  print flags\n&quot;</a>);
        <a id='2271' tid='2272' class='m'>PrintF</a>(<a id='2273' tid='2274' class='m'>&quot;disasm [&lt;instructions&gt;]\n&quot;</a>);
        <a id='2231' tid='2232' class='m'>PrintF</a>(<a id='2233' tid='2234' class='m'>&quot;disasm [&lt;address/register&gt;]\n&quot;</a>);
        <a id='2213' tid='2214' class='m'>PrintF</a>(<a id='2215' tid='2216' class='m'>&quot;disasm [[&lt;address/register&gt;] &lt;instructions&gt;]\n&quot;</a>);
        <a id='2203' tid='2204' class='m'>PrintF</a>(<a id='2205' tid='2206' class='m'>&quot;  disassemble code, default is 10 instructions\n&quot;</a>);
        <a id='2161' tid='2162' class='m'>PrintF</a>(<a id='2163' tid='2164' class='m'>&quot;  from pc (alias &#39;di&#39;)\n&quot;</a>);
        <a id='2135' tid='2136' class='m'>PrintF</a>(<a id='2137' tid='2138' class='m'>&quot;gdb\n&quot;</a>);
        <a id='2093' tid='2094' class='m'>PrintF</a>(<a id='2095' tid='2096' class='m'>&quot;  enter gdb\n&quot;</a>);
        <a id='2039' tid='2040' class='m'>PrintF</a>(<a id='2041' tid='2042' class='m'>&quot;break &lt;address&gt;\n&quot;</a>);
        <a id='1987' tid='1988' class='m'>PrintF</a>(<a id='1989' tid='1990' class='m'>&quot;  set a break point on the address\n&quot;</a>);
        <a id='1927' tid='1928' class='m'>PrintF</a>(<a id='1929' tid='1930' class='m'>&quot;del\n&quot;</a>);
        <a id='1867' tid='1868' class='m'>PrintF</a>(<a id='1869' tid='1870' class='m'>&quot;  delete the breakpoint\n&quot;</a>);
        <a id='1817' tid='1818' class='m'>PrintF</a>(<a id='1819' tid='1820' class='m'>&quot;stop feature:\n&quot;</a>);
        <a id='1747' tid='1748' class='m'>PrintF</a>(<a id='1749' tid='1750' class='m'>&quot;  Description:\n&quot;</a>);
        <a id='1683' tid='1684' class='m'>PrintF</a>(<a id='1685' tid='1686' class='m'>&quot;    Stops are debug instructions inserted by\n&quot;</a>);
        <a id='1649' tid='1650' class='m'>PrintF</a>(<a id='1651' tid='1652' class='m'>&quot;    the Assembler::stop() function.\n&quot;</a>);
        <a id='1613' tid='1614' class='m'>PrintF</a>(<a id='1615' tid='1616' class='m'>&quot;    When hitting a stop, the Simulator will\n&quot;</a>);
        <span class='d'>PrintF(&quot;    stop and and give control to the Debugger.\n&quot;);</span>
        <span class='d'>PrintF(&quot;    All stop codes are watched:\n&quot;);</span>
        <a id='1551' tid='1552' class='m'>PrintF</a>(<a id='1553' tid='1554' class='m'>&quot;    - They can be enabled / disabled: the Simulator\n&quot;</a>);
        <span class='d'>PrintF(&quot;       will / won&#39;t stop when hitting them.\n&quot;);</span>
        <a id='1509' tid='1510' class='m'>PrintF</a>(<a id='1511' tid='1512' class='m'>&quot;    - The Simulator keeps track of how many times they \n&quot;</a>);
        <a id='1495' tid='1496' class='m'>PrintF</a>(<a id='1497' tid='1498' class='m'>&quot;      are met. (See the info command.) Going over a\n&quot;</a>);
        <a id='1479' tid='1480' class='m'>PrintF</a>(<a id='1481' tid='1482' class='m'>&quot;      disabled stop still increases its counter. \n&quot;</a>);
        <a id='1441' tid='1442' class='m'>PrintF</a>(<a id='1443' tid='1444' class='m'>&quot;  Commands:\n&quot;</a>);
        <a id='1405' tid='1406' class='m'>PrintF</a>(<a id='1407' tid='1408' class='m'>&quot;    stop info all/&lt;code&gt; : print infos about number &lt;code&gt;\n&quot;</a>);
        <a id='1377' tid='1378' class='m'>PrintF</a>(<a id='1379' tid='1380' class='m'>&quot;      or all stop(s).\n&quot;</a>);
        <a id='1351' tid='1352' class='m'>PrintF</a>(<a id='1353' tid='1354' class='m'>&quot;    stop enable/disable all/&lt;code&gt; : enables / disables\n&quot;</a>);
        <a id='1321' tid='1322' class='m'>PrintF</a>(<a id='1323' tid='1324' class='m'>&quot;      all or number &lt;code&gt; stop(s)\n&quot;</a>);
        <a id='1269' tid='1270' class='m'>PrintF</a>(<a id='1271' tid='1272' class='m'>&quot;    stop unstop\n&quot;</a>);
        <a id='1189' tid='1190' class='m'>PrintF</a>(<a id='1191' tid='1192' class='m'>&quot;      ignore the stop instruction at the current location\n&quot;</a>);
        <a id='1149' tid='1150' class='m'>PrintF</a>(<a id='1151' tid='1152' class='m'>&quot;      from now on\n&quot;</a>);
      } <a id='4391' tid='4392' class='m'>else</a> {
        <a id='4393' tid='4394' class='m'>PrintF</a>(<a id='4395' tid='4396' class='m'>&quot;Unknown command: %s\n&quot;</a>, <a id='4397' tid='4398' class='m'>cmd</a>);
      }
    }
    <a id='5479' tid='5480' class='m'>DeleteArray</a>(<a id='5481' tid='5482' class='m'>line</a>);
  }

  // Add all the breakpoints back to stop execution and enter the debugger
  // shell when hit.
  <a id='5483' tid='5484' class='m'>RedoBreakpoints</a>();

#<a id='5485' tid='5486' class='m'>undef</a> <a id='5487' tid='5488' class='m'>COMMAND_SIZE</a>
#<a id='5489' tid='5490' class='m'>undef</a> <a id='5491' tid='5492' class='m'>ARG_SIZE</a>

#<a id='5493' tid='5494' class='m'>undef</a> <a id='5495' tid='5496' class='m'>STR</a>
#<a id='5497' tid='5498' class='m'>undef</a> <a id='5499' tid='5500' class='m'>XSTR</a>
}


<a id='4451' tid='4452' class='m'>static</a> <a id='4453' tid='4454' class='m'>bool</a> <a id='4455' tid='4456' class='m'>ICacheMatch</a>(<a id='4457' tid='4458' class='m'>void</a><a id='4459' tid='4460' class='m'>*</a> <a id='4461' tid='4462' class='m'>one</a>, <a id='4463' tid='4464' class='m'>void</a><a id='4465' tid='4466' class='m'>*</a> <a id='4467' tid='4468' class='m'>two</a>) {
  <a id='4469' tid='4470' class='m'>ASSERT</a>((<a id='4471' tid='4472' class='m'>reinterpret_cast</a>&lt;<a id='4473' tid='4474' class='m'>intptr_t</a>&gt;(<a id='4475' tid='4476' class='m'>one</a>) <a id='4477' tid='4478' class='m'>&</a> <a id='4479' tid='4480' class='m'>CachePage</a><a id='4481' tid='4482' class='m'>::</a><a id='4483' tid='4484' class='m'>kPageMask</a>) <a id='4485' tid='4486' class='m'>==</a> <a id='4487' tid='4488' class='m'>0</a>);
  <a id='4489' tid='4490' class='m'>ASSERT</a>((<a id='4491' tid='4492' class='m'>reinterpret_cast</a>&lt;<a id='4493' tid='4494' class='m'>intptr_t</a>&gt;(<a id='4495' tid='4496' class='m'>two</a>) <a id='4497' tid='4498' class='m'>&</a> <a id='4499' tid='4500' class='m'>CachePage</a><a id='4501' tid='4502' class='m'>::</a><a id='4503' tid='4504' class='m'>kPageMask</a>) <a id='4505' tid='4506' class='m'>==</a> <a id='4507' tid='4508' class='m'>0</a>);
  <a id='4509' tid='4510' class='m'>return</a> <a id='4511' tid='4512' class='m'>one</a> <a id='4513' tid='4514' class='m'>==</a> <a id='4515' tid='4516' class='m'>two</a>;
}


<a id='4399' tid='4400' class='m'>static</a> <a id='4401' tid='4402' class='m'>uint32_t</a> <a id='4403' tid='4404' class='m'>ICacheHash</a>(<a id='4405' tid='4406' class='m'>void</a><a id='4407' tid='4408' class='m'>*</a> <a id='4409' tid='4410' class='m'>key</a>) {
  <a id='4411' tid='4412' class='m'>return</a> <a id='4413' tid='4414' class='m'>static_cast</a>&lt;<a id='4415' tid='4416' class='m'>uint32_t</a>&gt;(<a id='4417' tid='4418' class='m'>reinterpret_cast</a>&lt;<a id='4419' tid='4420' class='m'>uintptr_t</a>&gt;(<a id='4421' tid='4422' class='m'>key</a>)) <a id='4423' tid='4424' class='m'>&gt;&gt;</a> <a id='4425' tid='4426' class='m'>2</a>;
}


<a id='3977' tid='3978' class='m'>static</a> <a id='3979' tid='3980' class='m'>bool</a> <a id='3981' tid='3982' class='m'>AllOnOnePage</a>(<a id='3983' tid='3984' class='m'>uintptr_t</a> <a id='3985' tid='3986' class='m'>start</a>, <a id='3987' tid='3988' class='m'>int</a> <a id='3989' tid='3990' class='m'>size</a>) {
  <a id='3991' tid='3992' class='m'>intptr_t</a> <a id='3993' tid='3994' class='m'>start_page</a> = (<a id='3995' tid='3996' class='m'>start</a> <a id='3997' tid='3998' class='m'>&</a> <a id='3999' tid='4000' class='m'>~</a><a id='4001' tid='4002' class='m'>CachePage</a><a id='4003' tid='4004' class='m'>::</a><a id='4005' tid='4006' class='m'>kPageMask</a>);
  <a id='4007' tid='4008' class='m'>intptr_t</a> <a id='4009' tid='4010' class='m'>end_page</a> = ((<a id='4011' tid='4012' class='m'>start</a> <a id='4013' tid='4014' class='m'>+</a> <a id='4015' tid='4016' class='m'>size</a>) <a id='4017' tid='4018' class='m'>&</a> <a id='4019' tid='4020' class='m'>~</a><a id='4021' tid='4022' class='m'>CachePage</a><a id='4023' tid='4024' class='m'>::</a><a id='4025' tid='4026' class='m'>kPageMask</a>);
  <a id='4027' tid='4028' class='m'>return</a> <a id='4029' tid='4030' class='m'>start_page</a> <a id='4031' tid='4032' class='m'>==</a> <a id='4033' tid='4034' class='m'>end_page</a>;
}


<a id='3771' tid='3772' class='m'>void</a> <a id='3773' tid='3774' class='m'>Simulator</a><a id='3775' tid='3776' class='m'>::</a><a id='3777' tid='3778' class='m'>FlushICache</a>(<a id='3779' tid='3780' class='m'>v8</a><a id='3781' tid='3782' class='m'>::</a><a id='3783' tid='3784' class='m'>internal</a><a id='3785' tid='3786' class='m'>::</a><a id='3787' tid='3788' class='m'>HashMap</a><a id='3789' tid='3790' class='m'>*</a> <a id='3791' tid='3792' class='m'>i_cache</a>,
                            <a id='3793' tid='3794' class='m'>void</a><a id='3795' tid='3796' class='m'>*</a> <a id='3797' tid='3798' class='m'>start_addr</a>,
                            <a id='3799' tid='3800' class='m'>size_t</a> <a id='3801' tid='3802' class='m'>size</a>) {
  <a id='3803' tid='3804' class='m'>intptr_t</a> <a id='3805' tid='3806' class='m'>start</a> = <a id='3807' tid='3808' class='m'>reinterpret_cast</a>&lt;<a id='3809' tid='3810' class='m'>intptr_t</a>&gt;(<a id='3811' tid='3812' class='m'>start_addr</a>);
  <a id='3813' tid='3814' class='m'>int</a> <a id='3815' tid='3816' class='m'>intra_line</a> = (<a id='3817' tid='3818' class='m'>start</a> <a id='3819' tid='3820' class='m'>&</a> <a id='3821' tid='3822' class='m'>CachePage</a><a id='3823' tid='3824' class='m'>::</a><a id='3825' tid='3826' class='m'>kLineMask</a>);
  <a id='3827' tid='3828' class='m'>start</a> <a id='3829' tid='3830' class='m'>-=</a> <a id='3831' tid='3832' class='m'>intra_line</a>;
  <a id='3833' tid='3834' class='m'>size</a> <a id='3835' tid='3836' class='m'>+=</a> <a id='3837' tid='3838' class='m'>intra_line</a>;
  <a id='3839' tid='3840' class='m'>size</a> <a id='3841' tid='3842' class='m'>=</a> ((<a id='3843' tid='3844' class='m'>size</a> <a id='3845' tid='3846' class='m'>-</a> <a id='3847' tid='3848' class='m'>1</a>) <a id='3849' tid='3850' class='m'>|</a> <a id='3851' tid='3852' class='m'>CachePage</a><a id='3853' tid='3854' class='m'>::</a><a id='3855' tid='3856' class='m'>kLineMask</a>) <a id='3857' tid='3858' class='m'>+</a> <a id='3859' tid='3860' class='m'>1</a>;
  <a id='3861' tid='3862' class='m'>int</a> <a id='3863' tid='3864' class='m'>offset</a> = (<a id='3865' tid='3866' class='m'>start</a> <a id='3867' tid='3868' class='m'>&</a> <a id='3869' tid='3870' class='m'>CachePage</a><a id='3871' tid='3872' class='m'>::</a><a id='3873' tid='3874' class='m'>kPageMask</a>);
  <a id='3875' tid='3876' class='m'>while</a> (<a id='3877' tid='3878' class='m'>!</a><a id='3879' tid='3880' class='m'>AllOnOnePage</a>(<a id='3881' tid='3882' class='m'>start</a>, <a id='3883' tid='3884' class='m'>size</a> <a id='3885' tid='3886' class='m'>-</a> <a id='3887' tid='3888' class='m'>1</a>)) {
    <a id='3889' tid='3890' class='m'>int</a> <a id='3891' tid='3892' class='m'>bytes_to_flush</a> = <a id='3893' tid='3894' class='m'>CachePage</a><a id='3895' tid='3896' class='m'>::</a><a id='3897' tid='3898' class='m'>kPageSize</a> <a id='3899' tid='3900' class='m'>-</a> <a id='3901' tid='3902' class='m'>offset</a>;
    <a id='3903' tid='3904' class='m'>FlushOnePage</a>(<a id='3905' tid='3906' class='m'>i_cache</a>, <a id='3907' tid='3908' class='m'>start</a>, <a id='3909' tid='3910' class='m'>bytes_to_flush</a>);
    <a id='3911' tid='3912' class='m'>start</a> <a id='3913' tid='3914' class='m'>+=</a> <a id='3915' tid='3916' class='m'>bytes_to_flush</a>;
    <a id='3917' tid='3918' class='m'>size</a> <a id='3919' tid='3920' class='m'>-=</a> <a id='3921' tid='3922' class='m'>bytes_to_flush</a>;
    <a id='3923' tid='3924' class='m'>ASSERT_EQ</a>(<a id='3925' tid='3926' class='m'>0</a>, <a id='3927' tid='3928' class='m'>start</a> <a id='3929' tid='3930' class='m'>&</a> <a id='3931' tid='3932' class='m'>CachePage</a><a id='3933' tid='3934' class='m'>::</a><a id='3935' tid='3936' class='m'>kPageMask</a>);
    <a id='3937' tid='3938' class='m'>offset</a> <a id='3939' tid='3940' class='m'>=</a> <a id='3941' tid='3942' class='m'>0</a>;
  }
  <a id='3943' tid='3944' class='m'>if</a> (<a id='3945' tid='3946' class='m'>size</a> <a id='3947' tid='3948' class='m'>!=</a> <a id='3949' tid='3950' class='m'>0</a>) {
    <a id='3951' tid='3952' class='m'>FlushOnePage</a>(<a id='3953' tid='3954' class='m'>i_cache</a>, <a id='3955' tid='3956' class='m'>start</a>, <a id='3957' tid='3958' class='m'>size</a>);
  }
}


<a id='3635' tid='3636' class='m'>CachePage</a><a id='3637' tid='3638' class='m'>*</a> <a id='3639' tid='3640' class='m'>Simulator</a><a id='3641' tid='3642' class='m'>::</a><a id='3643' tid='3644' class='m'>GetCachePage</a>(<a id='3645' tid='3646' class='m'>v8</a><a id='3647' tid='3648' class='m'>::</a><a id='3649' tid='3650' class='m'>internal</a><a id='3651' tid='3652' class='m'>::</a><a id='3653' tid='3654' class='m'>HashMap</a><a id='3655' tid='3656' class='m'>*</a> <a id='3657' tid='3658' class='m'>i_cache</a>, <a id='3659' tid='3660' class='m'>void</a><a id='3661' tid='3662' class='m'>*</a> <a id='3663' tid='3664' class='m'>page</a>) {
  <a id='3665' tid='3666' class='m'>v8</a><a id='3667' tid='3668' class='m'>::</a><a id='3669' tid='3670' class='m'>internal</a><a id='3671' tid='3672' class='m'>::</a><a id='3673' tid='3674' class='m'>HashMap</a><a id='3675' tid='3676' class='m'>::</a><a id='3677' tid='3678' class='m'>Entry</a><a id='3679' tid='3680' class='m'>*</a> <a id='3681' tid='3682' class='m'>entry</a> = <a id='3683' tid='3684' class='m'>i_cache</a>-&gt;<a id='3685' tid='3686' class='m'>Lookup</a>(<a id='3687' tid='3688' class='m'>page</a>,
                                                        <a id='3689' tid='3690' class='m'>ICacheHash</a>(<a id='3691' tid='3692' class='m'>page</a>),
                                                        <a id='3693' tid='3694' class='m'>true</a>);
  <a id='3695' tid='3696' class='m'>if</a> (<a id='3697' tid='3698' class='m'>entry</a>-&gt;<a id='3699' tid='3700' class='m'>value</a> <a id='3701' tid='3702' class='m'>==</a> <a id='3703' tid='3704' class='m'>NULL</a>) {
    <a id='3705' tid='3706' class='m'>CachePage</a><a id='3707' tid='3708' class='m'>*</a> <a id='3709' tid='3710' class='m'>new_page</a> = <a id='3711' tid='3712' class='m'>new</a> <a id='3713' tid='3714' class='m'>CachePage</a>();
    <a id='3715' tid='3716' class='m'>entry</a>-&gt;<a id='3717' tid='3718' class='m'>value</a> <a id='3719' tid='3720' class='m'>=</a> <a id='3721' tid='3722' class='m'>new_page</a>;
  }
  <a id='3723' tid='3724' class='m'>return</a> <a id='3725' tid='3726' class='m'>reinterpret_cast</a>&lt;<a id='3727' tid='3728' class='m'>CachePage</a><a id='3729' tid='3730' class='m'>*</a>&gt;(<a id='3731' tid='3732' class='m'>entry</a>-&gt;<a id='3733' tid='3734' class='m'>value</a>);
}


// Flush from start up to and not including start + size.
<a id='3451' tid='3452' class='m'>void</a> <a id='3453' tid='3454' class='m'>Simulator</a><a id='3455' tid='3456' class='m'>::</a><a id='3457' tid='3458' class='m'>FlushOnePage</a>(<a id='3459' tid='3460' class='m'>v8</a><a id='3461' tid='3462' class='m'>::</a><a id='3463' tid='3464' class='m'>internal</a><a id='3465' tid='3466' class='m'>::</a><a id='3467' tid='3468' class='m'>HashMap</a><a id='3469' tid='3470' class='m'>*</a> <a id='3471' tid='3472' class='m'>i_cache</a>,
                             <a id='3473' tid='3474' class='m'>intptr_t</a> <a id='3475' tid='3476' class='m'>start</a>,
                             <a id='3477' tid='3478' class='m'>int</a> <a id='3479' tid='3480' class='m'>size</a>) {
  <a id='3481' tid='3482' class='m'>ASSERT</a>(<a id='3483' tid='3484' class='m'>size</a> <a id='3485' tid='3486' class='m'>&lt;=</a> <a id='3487' tid='3488' class='m'>CachePage</a><a id='3489' tid='3490' class='m'>::</a><a id='3491' tid='3492' class='m'>kPageSize</a>);
  <a id='3493' tid='3494' class='m'>ASSERT</a>(<a id='3495' tid='3496' class='m'>AllOnOnePage</a>(<a id='3497' tid='3498' class='m'>start</a>, <a id='3499' tid='3500' class='m'>size</a> <a id='3501' tid='3502' class='m'>-</a> <a id='3503' tid='3504' class='m'>1</a>));
  <a id='3505' tid='3506' class='m'>ASSERT</a>((<a id='3507' tid='3508' class='m'>start</a> <a id='3509' tid='3510' class='m'>&</a> <a id='3511' tid='3512' class='m'>CachePage</a><a id='3513' tid='3514' class='m'>::</a><a id='3515' tid='3516' class='m'>kLineMask</a>) <a id='3517' tid='3518' class='m'>==</a> <a id='3519' tid='3520' class='m'>0</a>);
  <a id='3521' tid='3522' class='m'>ASSERT</a>((<a id='3523' tid='3524' class='m'>size</a> <a id='3525' tid='3526' class='m'>&</a> <a id='3527' tid='3528' class='m'>CachePage</a><a id='3529' tid='3530' class='m'>::</a><a id='3531' tid='3532' class='m'>kLineMask</a>) <a id='3533' tid='3534' class='m'>==</a> <a id='3535' tid='3536' class='m'>0</a>);
  <a id='3537' tid='3538' class='m'>void</a><a id='3539' tid='3540' class='m'>*</a> <a id='3541' tid='3542' class='m'>page</a> = <a id='3543' tid='3544' class='m'>reinterpret_cast</a>&lt;<a id='3545' tid='3546' class='m'>void</a><a id='3547' tid='3548' class='m'>*</a>&gt;(<a id='3549' tid='3550' class='m'>start</a> <a id='3551' tid='3552' class='m'>&</a> (<a id='3553' tid='3554' class='m'>~</a><a id='3555' tid='3556' class='m'>CachePage</a><a id='3557' tid='3558' class='m'>::</a><a id='3559' tid='3560' class='m'>kPageMask</a>));
  <a id='3561' tid='3562' class='m'>int</a> <a id='3563' tid='3564' class='m'>offset</a> = (<a id='3565' tid='3566' class='m'>start</a> <a id='3567' tid='3568' class='m'>&</a> <a id='3569' tid='3570' class='m'>CachePage</a><a id='3571' tid='3572' class='m'>::</a><a id='3573' tid='3574' class='m'>kPageMask</a>);
  <a id='3575' tid='3576' class='m'>CachePage</a><a id='3577' tid='3578' class='m'>*</a> <a id='3579' tid='3580' class='m'>cache_page</a> = <a id='3581' tid='3582' class='m'>GetCachePage</a>(<a id='3583' tid='3584' class='m'>i_cache</a>, <a id='3585' tid='3586' class='m'>page</a>);
  <a id='3587' tid='3588' class='m'>char</a><a id='3589' tid='3590' class='m'>*</a> <a id='3591' tid='3592' class='m'>valid_bytemap</a> = <a id='3593' tid='3594' class='m'>cache_page</a>-&gt;<a id='3595' tid='3596' class='m'>ValidityByte</a>(<a id='3597' tid='3598' class='m'>offset</a>);
  <a id='3599' tid='3600' class='m'>memset</a>(<a id='3601' tid='3602' class='m'>valid_bytemap</a>, <a id='3603' tid='3604' class='m'>CachePage</a><a id='3605' tid='3606' class='m'>::</a><a id='3607' tid='3608' class='m'>LINE_INVALID</a>, <a id='3609' tid='3610' class='m'>size</a> <a id='3611' tid='3612' class='m'>&gt;&gt;</a> <a id='3613' tid='3614' class='m'>CachePage</a><a id='3615' tid='3616' class='m'>::</a><a id='3617' tid='3618' class='m'>kLineShift</a>);
}


<a id='3163' tid='3164' class='m'>void</a> <a id='3165' tid='3166' class='m'>Simulator</a><a id='3167' tid='3168' class='m'>::</a><a id='3169' tid='3170' class='m'>CheckICache</a>(<a id='3171' tid='3172' class='m'>v8</a><a id='3173' tid='3174' class='m'>::</a><a id='3175' tid='3176' class='m'>internal</a><a id='3177' tid='3178' class='m'>::</a><a id='3179' tid='3180' class='m'>HashMap</a><a id='3181' tid='3182' class='m'>*</a> <a id='3183' tid='3184' class='m'>i_cache</a>,
                            <a id='3185' tid='3186' class='m'>Instruction</a><a id='3187' tid='3188' class='m'>*</a> <a id='3189' tid='3190' class='m'>instr</a>) {
  <a id='3191' tid='3192' class='m'>intptr_t</a> <a id='3193' tid='3194' class='m'>address</a> = <a id='3195' tid='3196' class='m'>reinterpret_cast</a>&lt;<a id='3197' tid='3198' class='m'>intptr_t</a>&gt;(<a id='3199' tid='3200' class='m'>instr</a>);
  <a id='3201' tid='3202' class='m'>void</a><a id='3203' tid='3204' class='m'>*</a> <a id='3205' tid='3206' class='m'>page</a> = <a id='3207' tid='3208' class='m'>reinterpret_cast</a>&lt;<a id='3209' tid='3210' class='m'>void</a><a id='3211' tid='3212' class='m'>*</a>&gt;(<a id='3213' tid='3214' class='m'>address</a> <a id='3215' tid='3216' class='m'>&</a> (<a id='3217' tid='3218' class='m'>~</a><a id='3219' tid='3220' class='m'>CachePage</a><a id='3221' tid='3222' class='m'>::</a><a id='3223' tid='3224' class='m'>kPageMask</a>));
  <a id='3225' tid='3226' class='m'>void</a><a id='3227' tid='3228' class='m'>*</a> <a id='3229' tid='3230' class='m'>line</a> = <a id='3231' tid='3232' class='m'>reinterpret_cast</a>&lt;<a id='3233' tid='3234' class='m'>void</a><a id='3235' tid='3236' class='m'>*</a>&gt;(<a id='3237' tid='3238' class='m'>address</a> <a id='3239' tid='3240' class='m'>&</a> (<a id='3241' tid='3242' class='m'>~</a><a id='3243' tid='3244' class='m'>CachePage</a><a id='3245' tid='3246' class='m'>::</a><a id='3247' tid='3248' class='m'>kLineMask</a>));
  <a id='3249' tid='3250' class='m'>int</a> <a id='3251' tid='3252' class='m'>offset</a> = (<a id='3253' tid='3254' class='m'>address</a> <a id='3255' tid='3256' class='m'>&</a> <a id='3257' tid='3258' class='m'>CachePage</a><a id='3259' tid='3260' class='m'>::</a><a id='3261' tid='3262' class='m'>kPageMask</a>);
  <a id='3263' tid='3264' class='m'>CachePage</a><a id='3265' tid='3266' class='m'>*</a> <a id='3267' tid='3268' class='m'>cache_page</a> = <a id='3269' tid='3270' class='m'>GetCachePage</a>(<a id='3271' tid='3272' class='m'>i_cache</a>, <a id='3273' tid='3274' class='m'>page</a>);
  <a id='3275' tid='3276' class='m'>char</a><a id='3277' tid='3278' class='m'>*</a> <a id='3279' tid='3280' class='m'>cache_valid_byte</a> = <a id='3281' tid='3282' class='m'>cache_page</a>-&gt;<a id='3283' tid='3284' class='m'>ValidityByte</a>(<a id='3285' tid='3286' class='m'>offset</a>);
  <a id='3287' tid='3288' class='m'>bool</a> <a id='3289' tid='3290' class='m'>cache_hit</a> = (<a id='3291' tid='3292' class='m'>*</a><a id='3293' tid='3294' class='m'>cache_valid_byte</a> <a id='3295' tid='3296' class='m'>==</a> <a id='3297' tid='3298' class='m'>CachePage</a><a id='3299' tid='3300' class='m'>::</a><a id='3301' tid='3302' class='m'>LINE_VALID</a>);
  <a id='3303' tid='3304' class='m'>char</a><a id='3305' tid='3306' class='m'>*</a> <a id='3307' tid='3308' class='m'>cached_line</a> = <a id='3309' tid='3310' class='m'>cache_page</a>-&gt;<a id='3311' tid='3312' class='m'>CachedData</a>(<a id='3313' tid='3314' class='m'>offset</a> <a id='3315' tid='3316' class='m'>&</a> <a id='3317' tid='3318' class='m'>~</a><a id='3319' tid='3320' class='m'>CachePage</a><a id='3321' tid='3322' class='m'>::</a><a id='3323' tid='3324' class='m'>kLineMask</a>);
  <a id='3325' tid='3326' class='m'>if</a> (<a id='3327' tid='3328' class='m'>cache_hit</a>) {
    // Check that the data in memory matches the contents of the I-cache.
    <a id='3329' tid='3330' class='m'>CHECK</a>(<a id='3331' tid='3332' class='m'>memcmp</a>(<a id='3333' tid='3334' class='m'>reinterpret_cast</a>&lt;<a id='3335' tid='3336' class='m'>void</a><a id='3337' tid='3338' class='m'>*</a>&gt;(<a id='3339' tid='3340' class='m'>instr</a>),
                 <a id='3341' tid='3342' class='m'>cache_page</a>-&gt;<a id='3343' tid='3344' class='m'>CachedData</a>(<a id='3345' tid='3346' class='m'>offset</a>),
                 <a id='3347' tid='3348' class='m'>Instruction</a><a id='3349' tid='3350' class='m'>::</a><a id='3351' tid='3352' class='m'>kInstrSize</a>) <a id='3353' tid='3354' class='m'>==</a> <a id='3355' tid='3356' class='m'>0</a>);
  } <a id='3357' tid='3358' class='m'>else</a> {
    // Cache miss.  Load memory into the cache.
    <a id='3359' tid='3360' class='m'>memcpy</a>(<a id='3361' tid='3362' class='m'>cached_line</a>, <a id='3363' tid='3364' class='m'>line</a>, <a id='3365' tid='3366' class='m'>CachePage</a><a id='3367' tid='3368' class='m'>::</a><a id='3369' tid='3370' class='m'>kLineLength</a>);
    <a id='3371' tid='3372' class='m'>*</a><a id='3373' tid='3374' class='m'>cache_valid_byte</a> <a id='3375' tid='3376' class='m'>=</a> <a id='3377' tid='3378' class='m'>CachePage</a><a id='3379' tid='3380' class='m'>::</a><a id='3381' tid='3382' class='m'>LINE_VALID</a>;
  }
}


<a id='3013' tid='3014' class='m'>void</a> <a id='3015' tid='3016' class='m'>Simulator</a><a id='3017' tid='3018' class='m'>::</a><a id='3019' tid='3020' class='m'>Initialize</a>(<a id='3021' tid='3022' class='m'>Isolate</a><a id='3023' tid='3024' class='m'>*</a> <a id='3025' tid='3026' class='m'>isolate</a>) {
  <a id='3027' tid='3028' class='m'>if</a> (<a id='3029' tid='3030' class='m'>isolate</a>-&gt;<a id='3031' tid='3032' class='m'>simulator_initialized</a>()) <a id='3033' tid='3034' class='m'>return</a>;
  <a id='3035' tid='3036' class='m'>isolate</a>-&gt;<a id='3037' tid='3038' class='m'>set_simulator_initialized</a>(<a id='3039' tid='3040' class='m'>true</a>);
  <a id='3041' tid='3042' class='m'>::</a><a id='3043' tid='3044' class='m'>v8</a><a id='3045' tid='3046' class='m'>::</a><a id='3047' tid='3048' class='m'>internal</a><a id='3049' tid='3050' class='m'>::</a><a id='3051' tid='3052' class='m'>ExternalReference</a><a id='3053' tid='3054' class='m'>::</a><a id='3055' tid='3056' class='m'>set_redirector</a>(<a id='3057' tid='3058' class='m'>isolate</a>,
                                                    <a id='3059' tid='3060' class='m'>&</a><a id='3061' tid='3062' class='m'>RedirectExternalReference</a>);
}


<a id='2959' tid='2960' class='m'>Simulator</a><a id='2961' tid='2962' class='m'>::</a><a id='2963' tid='2964' class='m'>Simulator</a>(<a id='2965' tid='2966' class='m'>Isolate</a><a id='2967' tid='2968' class='m'>*</a> <a id='2969' tid='2970' class='m'>isolate</a>) : <a id='2971' tid='2972' class='m'>isolate_</a>(<a id='2973' tid='2974' class='m'>isolate</a>) {
  <a id='2975' tid='2976' class='m'>i_cache_</a> <a id='2977' tid='2978' class='m'>=</a> <a id='2979' tid='2980' class='m'>isolate_</a>-&gt;<a id='2981' tid='2982' class='m'>simulator_i_cache</a>();
  <a id='2925' tid='2926' class='m'>if</a> (<a id='2927' tid='2928' class='m'>i_cache_</a> <a id='2929' tid='2930' class='m'>==</a> <a id='2931' tid='2932' class='m'>NULL</a>) {
    <a id='2933' tid='2934' class='m'>i_cache_</a> <a id='2935' tid='2936' class='m'>=</a> <a id='2937' tid='2938' class='m'>new</a> <a id='2939' tid='2940' class='m'>v8</a><a id='2941' tid='2942' class='m'>::</a><a id='2943' tid='2944' class='m'>internal</a><a id='2945' tid='2946' class='m'>::</a><a id='2947' tid='2948' class='m'>HashMap</a>(<a id='2949' tid='2950' class='m'>&</a><a id='2951' tid='2952' class='m'>ICacheMatch</a>);
    <a id='2953' tid='2954' class='m'>isolate_</a>-&gt;<a id='2955' tid='2956' class='m'>set_simulator_i_cache</a>(<a id='2957' tid='2958' class='m'>i_cache_</a>);
  }
  <a id='2615' tid='2616' class='m'>Initialize</a>(<a id='2617' tid='2618' class='m'>isolate</a>);
  // Setup simulator support first. Some of this information is needed to
  // setup the architecture state.
  <a id='2555' tid='2556' class='m'>stack_</a> <a id='2557' tid='2558' class='m'>=</a> <a id='2559' tid='2560' class='m'>reinterpret_cast</a>&lt;<a id='2561' tid='2562' class='m'>char</a><a id='2563' tid='2564' class='m'>*</a>&gt;<span class='d'>(malloc(stack_size_))</span>;
  <a id='2499' tid='2500' class='m'>pc_modified_</a> <a id='2501' tid='2502' class='m'>=</a> <a id='2503' tid='2504' class='m'>false</a>;
  <a id='2437' tid='2438' class='m'>icount_</a> <a id='2439' tid='2440' class='m'>=</a> <a id='2441' tid='2442' class='m'>0</a>;
  <span class='d'>break_count_ = 0;</span>
  <a id='2389' tid='2390' class='m'>break_pc_</a> <a id='2391' tid='2392' class='m'>=</a> <a id='2393' tid='2394' class='m'>NULL</a>;
  <a id='2367' tid='2368' class='m'>break_instr_</a> <a id='2369' tid='2370' class='m'>=</a> <a id='2371' tid='2372' class='m'>0</a>;

  // Setup architecture state.
  // All registers are initialized to zero to start with.
  <a id='2299' tid='2300' class='m'>for</a> (<a id='2301' tid='2302' class='m'>int</a> <a id='2303' tid='2304' class='m'>i</a> = <a id='2305' tid='2306' class='m'>0</a>; <span class='d'>i &lt; kNumSimuRegisters</span>; <a id='2281' tid='2282' class='m'>i</a><a id='2283' tid='2284' class='m'>++</a>) {
    <a id='2307' tid='2308' class='m'>registers_</a>[<a id='2309' tid='2310' class='m'>i</a>] <a id='2311' tid='2312' class='m'>=</a> <a id='2313' tid='2314' class='m'>0</a>;
  }
  <span class='d'>for</span> (<a id='2275' tid='2276' class='m'>int</a> <a id='2277' tid='2278' class='m'>i</a> = <a id='2279' tid='2280' class='m'>0</a>; <span class='d'>i &lt; kNumFPURegisters</span>; <a id='2251' tid='2252' class='m'>i</a><a id='2253' tid='2254' class='m'>++</a>) <span class='d'>{
    FPUregisters_[i] = 0;
  }</span>
  <span class='d'>FCSR_ = 0;</span>

  // The sp is initialized to point to the bottom (high address) of the
  // allocated stack area. To be safe in potential stack underflows we leave
  // some buffer below.
  <a id='2235' tid='2236' class='m'>registers_</a>[<a id='2237' tid='2238' class='m'>sp</a>] <a id='2239' tid='2240' class='m'>=</a> <a id='2241' tid='2242' class='m'>reinterpret_cast</a>&lt;<a id='2243' tid='2244' class='m'>int32_t</a>&gt;(<a id='2245' tid='2246' class='m'>stack_</a>) <span class='d'>+</span> <span class='d'>stack_size_</span> <a id='2247' tid='2248' class='m'>-</a> <a id='2249' tid='2250' class='m'>64</a>;
  // The ra and pc are initialized to a known bad value that will cause an
  // access violation if the simulator ever tries to execute it.
  <a id='2217' tid='2218' class='m'>registers_</a>[<a id='2219' tid='2220' class='m'>pc</a>] <span class='d'>=</span> <span class='d'>bad_ra</span>;
  <span class='d'>registers_[ra] = bad_ra;</span>
  <span class='d'>InitializeCoverage();</span>
  <span class='d'>for (int i = 0; i &lt; kNumExceptions; i++) {
    exceptions[i] = 0;
  }</span>
}


// When the generated code calls an external reference we need to catch that in
// the simulator.  The external reference will be a function compiled for the
// host architecture.  We need to call that function instead of trying to
// execute it with the simulator.  We do that by redirecting the external
// reference to a swi (software-interrupt) instruction that is handled by
// the simulator.  We write the original destination of the jump just at a known
// offset from the swi instruction so the simulator knows what to call.
<a id='2623' tid='2624' class='m'>class</a> <a id='2625' tid='2626' class='m'>Redirection</a> {
 <a id='2881' tid='2882' class='m'>public</a>:
  <a id='2765' tid='2766' class='m'>Redirection</a>(<a id='2767' tid='2768' class='m'>void</a><a id='2769' tid='2770' class='m'>*</a> <a id='2771' tid='2772' class='m'>external_function</a>, <a id='2773' tid='2774' class='m'>ExternalReference</a><a id='2775' tid='2776' class='m'>::</a><a id='2777' tid='2778' class='m'>Type</a> <a id='2779' tid='2780' class='m'>type</a>)
      : <a id='2781' tid='2782' class='m'>external_function_</a>(<a id='2783' tid='2784' class='m'>external_function</a>),
        <span class='d'>swi_instruction_(rtCallRedirInstr)</span>,
        <a id='2619' tid='2620' class='m'>type_</a>(<a id='2621' tid='2622' class='m'>type</a>),
        <span class='d'>next_(NULL)</span> {
    <a id='2785' tid='2786' class='m'>Isolate</a><a id='2787' tid='2788' class='m'>*</a> <a id='2789' tid='2790' class='m'>isolate</a> = <a id='2791' tid='2792' class='m'>Isolate</a><a id='2793' tid='2794' class='m'>::</a><a id='2795' tid='2796' class='m'>Current</a>();
    <a id='2797' tid='2798' class='m'>next_</a> <a id='2799' tid='2800' class='m'>=</a> <a id='2801' tid='2802' class='m'>isolate</a>-&gt;<a id='2803' tid='2804' class='m'>simulator_redirection</a>();
    <a id='2805' tid='2806' class='m'>Simulator</a><a id='2807' tid='2808' class='m'>::</a><a id='2809' tid='2810' class='m'>current</a>(<a id='2811' tid='2812' class='m'>isolate</a>)-&gt;
        <a id='2813' tid='2814' class='m'>FlushICache</a>(<a id='2815' tid='2816' class='m'>isolate</a>-&gt;<a id='2817' tid='2818' class='m'>simulator_i_cache</a>(),
                    <a id='2819' tid='2820' class='m'>reinterpret_cast</a>&lt;<a id='2821' tid='2822' class='m'>void</a><a id='2823' tid='2824' class='m'>*</a>&gt;(<a id='2825' tid='2826' class='m'>&</a><a id='2827' tid='2828' class='m'>swi_instruction_</a>),
                    <a id='2829' tid='2830' class='m'>Instruction</a><a id='2831' tid='2832' class='m'>::</a><a id='2833' tid='2834' class='m'>kInstrSize</a>);
    <a id='2835' tid='2836' class='m'>isolate</a>-&gt;<a id='2837' tid='2838' class='m'>set_simulator_redirection</a>(<a id='2839' tid='2840' class='m'>this</a>);
  }

  <a id='2841' tid='2842' class='m'>void</a><a id='2843' tid='2844' class='m'>*</a> <a id='2845' tid='2846' class='m'>address_of_swi_instruction</a>() {
    <a id='2847' tid='2848' class='m'>return</a> <a id='2849' tid='2850' class='m'>reinterpret_cast</a>&lt;<a id='2851' tid='2852' class='m'>void</a><a id='2853' tid='2854' class='m'>*</a>&gt;(<a id='2855' tid='2856' class='m'>&</a><a id='2857' tid='2858' class='m'>swi_instruction_</a>);
  }

  <a id='2859' tid='2860' class='m'>void</a><a id='2861' tid='2862' class='m'>*</a> <a id='2863' tid='2864' class='m'>external_function</a>() { <a id='2865' tid='2866' class='m'>return</a> <a id='2867' tid='2868' class='m'>external_function_</a>; }
  <a id='2869' tid='2870' class='m'>ExternalReference</a><a id='2871' tid='2872' class='m'>::</a><a id='2873' tid='2874' class='m'>Type</a> <a id='2875' tid='2876' class='m'>type</a>() { <a id='2877' tid='2878' class='m'>return</a> <a id='2879' tid='2880' class='m'>type_</a>; }

  <a id='2681' tid='2682' class='m'>static</a> <a id='2683' tid='2684' class='m'>Redirection</a><a id='2685' tid='2686' class='m'>*</a> <a id='2687' tid='2688' class='m'>Get</a>(<a id='2689' tid='2690' class='m'>void</a><a id='2691' tid='2692' class='m'>*</a> <a id='2693' tid='2694' class='m'>external_function</a>,
                          <a id='2695' tid='2696' class='m'>ExternalReference</a><a id='2697' tid='2698' class='m'>::</a><a id='2699' tid='2700' class='m'>Type</a> <a id='2701' tid='2702' class='m'>type</a>) {
    <a id='2703' tid='2704' class='m'>Isolate</a><a id='2705' tid='2706' class='m'>*</a> <a id='2707' tid='2708' class='m'>isolate</a> = <a id='2709' tid='2710' class='m'>Isolate</a><a id='2711' tid='2712' class='m'>::</a><a id='2713' tid='2714' class='m'>Current</a>();
    <a id='2715' tid='2716' class='m'>Redirection</a><a id='2717' tid='2718' class='m'>*</a> <a id='2719' tid='2720' class='m'>current</a> = <a id='2721' tid='2722' class='m'>isolate</a>-&gt;<a id='2723' tid='2724' class='m'>simulator_redirection</a>();
    <a id='2725' tid='2726' class='m'>for</a> (; <a id='2727' tid='2728' class='m'>current</a> <a id='2729' tid='2730' class='m'>!=</a> <a id='2731' tid='2732' class='m'>NULL</a>; <a id='2733' tid='2734' class='m'>current</a> <a id='2735' tid='2736' class='m'>=</a> <a id='2737' tid='2738' class='m'>current</a>-&gt;<a id='2739' tid='2740' class='m'>next_</a>) {
      <a id='2741' tid='2742' class='m'>if</a> (<a id='2743' tid='2744' class='m'>current</a>-&gt;<a id='2745' tid='2746' class='m'>external_function_</a> <a id='2747' tid='2748' class='m'>==</a> <a id='2749' tid='2750' class='m'>external_function</a>) <a id='2751' tid='2752' class='m'>return</a> <a id='2753' tid='2754' class='m'>current</a>;
    }
    <a id='2755' tid='2756' class='m'>return</a> <a id='2757' tid='2758' class='m'>new</a> <a id='2759' tid='2760' class='m'>Redirection</a>(<a id='2761' tid='2762' class='m'>external_function</a>, <a id='2763' tid='2764' class='m'>type</a>);
  }

  <a id='2627' tid='2628' class='m'>static</a> <a id='2629' tid='2630' class='m'>Redirection</a><a id='2631' tid='2632' class='m'>*</a> <a id='2633' tid='2634' class='m'>FromSwiInstruction</a>(<a id='2635' tid='2636' class='m'>Instruction</a><a id='2637' tid='2638' class='m'>*</a> <a id='2639' tid='2640' class='m'>swi_instruction</a>) {
    <a id='2641' tid='2642' class='m'>char</a><a id='2643' tid='2644' class='m'>*</a> <a id='2645' tid='2646' class='m'>addr_of_swi</a> = <a id='2647' tid='2648' class='m'>reinterpret_cast</a>&lt;<a id='2649' tid='2650' class='m'>char</a><a id='2651' tid='2652' class='m'>*</a>&gt;(<a id='2653' tid='2654' class='m'>swi_instruction</a>);
    <a id='2655' tid='2656' class='m'>char</a><a id='2657' tid='2658' class='m'>*</a> <a id='2659' tid='2660' class='m'>addr_of_redirection</a> =
        <a id='2661' tid='2662' class='m'>addr_of_swi</a> <a id='2663' tid='2664' class='m'>-</a> <a id='2665' tid='2666' class='m'>OFFSET_OF</a>(<a id='2667' tid='2668' class='m'>Redirection</a>, <a id='2669' tid='2670' class='m'>swi_instruction_</a>);
    <a id='2671' tid='2672' class='m'>return</a> <a id='2673' tid='2674' class='m'>reinterpret_cast</a>&lt;<a id='2675' tid='2676' class='m'>Redirection</a><a id='2677' tid='2678' class='m'>*</a>&gt;(<a id='2679' tid='2680' class='m'>addr_of_redirection</a>);
  }

 <a id='2883' tid='2884' class='m'>private</a>:
  <a id='2885' tid='2886' class='m'>void</a><a id='2887' tid='2888' class='m'>*</a> <a id='2889' tid='2890' class='m'>external_function_</a>;
  <a id='2891' tid='2892' class='m'>uint32_t</a> <a id='2893' tid='2894' class='m'>swi_instruction_</a>;
  <a id='2895' tid='2896' class='m'>ExternalReference</a><a id='2897' tid='2898' class='m'>::</a><a id='2899' tid='2900' class='m'>Type</a> <a id='2901' tid='2902' class='m'>type_</a>;
  <a id='2903' tid='2904' class='m'>Redirection</a><a id='2905' tid='2906' class='m'>*</a> <a id='2907' tid='2908' class='m'>next_</a>;
};


<a id='2565' tid='2566' class='m'>void</a><a id='2567' tid='2568' class='m'>*</a> <a id='2569' tid='2570' class='m'>Simulator</a><a id='2571' tid='2572' class='m'>::</a><a id='2573' tid='2574' class='m'>RedirectExternalReference</a>(<a id='2575' tid='2576' class='m'>void</a><a id='2577' tid='2578' class='m'>*</a> <a id='2579' tid='2580' class='m'>external_function</a>,
                                           <a id='2581' tid='2582' class='m'>ExternalReference</a><a id='2583' tid='2584' class='m'>::</a><a id='2585' tid='2586' class='m'>Type</a> <a id='2587' tid='2588' class='m'>type</a>) {
  <a id='2589' tid='2590' class='m'>Redirection</a><a id='2591' tid='2592' class='m'>*</a> <a id='2593' tid='2594' class='m'>redirection</a> = <a id='2595' tid='2596' class='m'>Redirection</a><a id='2597' tid='2598' class='m'>::</a><a id='2599' tid='2600' class='m'>Get</a>(<a id='2601' tid='2602' class='m'>external_function</a>, <a id='2603' tid='2604' class='m'>type</a>);
  <a id='2605' tid='2606' class='m'>return</a> <a id='2607' tid='2608' class='m'>redirection</a>-&gt;<a id='2609' tid='2610' class='m'>address_of_swi_instruction</a>();
}


// Get the active Simulator for the current thread.
<a id='2513' tid='2514' class='m'>Simulator</a><a id='2515' tid='2516' class='m'>*</a> <a id='2517' tid='2518' class='m'>Simulator</a><a id='2519' tid='2520' class='m'>::</a><a id='2521' tid='2522' class='m'>current</a>(<a id='2523' tid='2524' class='m'>Isolate</a><a id='2525' tid='2526' class='m'>*</a> <a id='2527' tid='2528' class='m'>isolate</a>) {
  <a id='2529' tid='2530' class='m'>v8</a><a id='2531' tid='2532' class='m'>::</a><a id='2533' tid='2534' class='m'>internal</a><a id='2535' tid='2536' class='m'>::</a><a id='2537' tid='2538' class='m'>Isolate</a><a id='2539' tid='2540' class='m'>::</a><a id='2541' tid='2542' class='m'>PerIsolateThreadData</a><a id='2543' tid='2544' class='m'>*</a> <a id='2545' tid='2546' class='m'>isolate_data</a> =
       <a id='2547' tid='2548' class='m'>isolate</a>-&gt;<a id='2549' tid='2550' class='m'>FindOrAllocatePerThreadDataForThisThread</a>();
  <a id='2505' tid='2506' class='m'>ASSERT</a>(<a id='2507' tid='2508' class='m'>isolate_data</a> <a id='2509' tid='2510' class='m'>!=</a> <a id='2511' tid='2512' class='m'>NULL</a>);
  <span class='d'>ASSERT(isolate_data != NULL);</span>

  <a id='2443' tid='2444' class='m'>Simulator</a><a id='2445' tid='2446' class='m'>*</a> <a id='2447' tid='2448' class='m'>sim</a> = <a id='2449' tid='2450' class='m'>isolate_data</a>-&gt;<a id='2451' tid='2452' class='m'>simulator</a>();
  <a id='2395' tid='2396' class='m'>if</a> (<a id='2397' tid='2398' class='m'>sim</a> <a id='2399' tid='2400' class='m'>==</a> <a id='2401' tid='2402' class='m'>NULL</a>) {
    // TODO(146): delete the simulator object when a thread/isolate goes away.
    <a id='2403' tid='2404' class='m'>sim</a> <a id='2405' tid='2406' class='m'>=</a> <a id='2407' tid='2408' class='m'>new</a> <a id='2409' tid='2410' class='m'>Simulator</a>(<a id='2411' tid='2412' class='m'>isolate</a>);
    <a id='2413' tid='2414' class='m'>isolate_data</a>-&gt;<a id='2415' tid='2416' class='m'>set_simulator</a>(<a id='2417' tid='2418' class='m'>sim</a>);
  }
  <span class='d'>return sim;</span>
}


// Sets the register in the architecture state. It will also deal with updating
// Simulator internal state for special registers such as PC.
<a id='2453' tid='2454' class='m'>void</a> <a id='2455' tid='2456' class='m'>Simulator</a><a id='2457' tid='2458' class='m'>::</a><a id='2459' tid='2460' class='m'>set_register</a>(<a id='2461' tid='2462' class='m'>int</a> <a id='2463' tid='2464' class='m'>reg</a>, <a id='2465' tid='2466' class='m'>int32_t</a> <a id='2467' tid='2468' class='m'>value</a>) {
  <a id='2469' tid='2470' class='m'>ASSERT</a>((<a id='2471' tid='2472' class='m'>reg</a> <a id='2473' tid='2474' class='m'>&gt;=</a> <a id='2475' tid='2476' class='m'>0</a>) <span class='d'>&&</span> (<span class='d'>reg &lt; kNumSimuRegisters</span>));
  <a id='2477' tid='2478' class='m'>if</a> (<a id='2479' tid='2480' class='m'>reg</a> <a id='2481' tid='2482' class='m'>==</a> <a id='2483' tid='2484' class='m'>pc</a>) {
    <a id='2485' tid='2486' class='m'>pc_modified_</a> <a id='2487' tid='2488' class='m'>=</a> <a id='2489' tid='2490' class='m'>true</a>;
  }

  // Zero register always holds 0.
  <a id='2491' tid='2492' class='m'>registers_</a>[<a id='2493' tid='2494' class='m'>reg</a>] <span class='d'>=</span> (<span class='d'>reg == 0) ? 0 : value</span>;
}


<span class='d'>void Simulator::set_fpu_register(int fpureg, int32_t value) {
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  FPUregisters_[fpureg] = value;
}</span>


<span class='d'>void Simulator::set_fpu_register_float(int fpureg, float value) {
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  *BitCast&lt;float*&gt;(&FPUregisters_[fpureg]) = value;
}</span>


<span class='d'>void Simulator::set_fpu_register_double(int fpureg, double value) {
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters) && ((fpureg % 2) == 0));
  *BitCast&lt;double*&gt;(&FPUregisters_[fpureg]) = value;
}</span>


// Get the register from the architecture state. This function does handle
// the special case of accessing the PC register.
<a id='2419' tid='2420' class='m'>int32_t</a> <a id='2421' tid='2422' class='m'>Simulator</a><a id='2423' tid='2424' class='m'>::</a><a id='2425' tid='2426' class='m'>get_register</a>(<a id='2427' tid='2428' class='m'>int</a> <a id='2429' tid='2430' class='m'>reg</a>) <a id='2431' tid='2432' class='m'>const</a> {
  <a id='2377' tid='2378' class='m'>ASSERT</a>((<a id='2379' tid='2380' class='m'>reg</a> <a id='2381' tid='2382' class='m'>&gt;=</a> <a id='2383' tid='2384' class='m'>0</a>) <span class='d'>&&</span> (<span class='d'>reg &lt; kNumSimuRegisters</span>));
  <span class='d'>if</span> <span class='d'>(reg == 0)</span>
    <a id='2373' tid='2374' class='m'>return</a> <a id='2375' tid='2376' class='m'>0</a>;
  <span class='d'>else</span>
    <a id='2315' tid='2316' class='m'>return</a> <a id='2317' tid='2318' class='m'>registers_</a>[<a id='2319' tid='2320' class='m'>reg</a>] <a id='2321' tid='2322' class='m'>+</a> ((<a id='2323' tid='2324' class='m'>reg</a> <a id='2325' tid='2326' class='m'>==</a> <a id='2327' tid='2328' class='m'>pc</a>) ? <a id='2329' tid='2330' class='m'>Instruction</a><a id='2331' tid='2332' class='m'>::</a><a id='2333' tid='2334' class='m'>kPCReadOffset</a> : <a id='2335' tid='2336' class='m'>0</a>);
}


<span class='d'>int32_t Simulator::get_fpu_register(int fpureg) const</span> <span class='d'>{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  return FPUregisters_[fpureg];
}</span>


<span class='d'>int64_t Simulator::get_fpu_register_long(int fpureg) const</span> <span class='d'>{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters) && ((fpureg % 2) == 0));
  return *BitCast&lt;int64_t*&gt;(
      const_cast&lt;int32_t*&gt;(&FPUregisters_[fpureg]));
}</span>


<span class='d'>float Simulator::get_fpu_register_float(int fpureg) const</span> <span class='d'>{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters));
  return *BitCast&lt;float*&gt;(
      const_cast&lt;int32_t*&gt;(&FPUregisters_[fpureg]));
}</span>


<span class='d'>double Simulator::get_fpu_register_double(int fpureg) const</span> <span class='d'>{
  ASSERT((fpureg &gt;= 0) && (fpureg &lt; kNumFPURegisters) && ((fpureg % 2) == 0));
  return *BitCast&lt;double*&gt;(const_cast&lt;int32_t*&gt;(&FPUregisters_[fpureg]));
}</span>


// For use in calls that take two double values, constructed either
// from a0-a3 or f12 and f14.
<a id='2175' tid='2176' class='m'>void</a> <a id='2177' tid='2178' class='m'>Simulator</a><a id='2179' tid='2180' class='m'>::</a><a id='2181' tid='2182' class='m'>GetFpArgs</a>(<a id='2183' tid='2184' class='m'>double</a><a id='2185' tid='2186' class='m'>*</a> <a id='2187' tid='2188' class='m'>x</a>, <a id='2189' tid='2190' class='m'>double</a><a id='2191' tid='2192' class='m'>*</a> <a id='2193' tid='2194' class='m'>y</a>) {
  <span class='d'>if</span> <span class='d'>(!IsMipsSoftFloatABI)</span> {
    <a id='2195' tid='2196' class='m'>*</a><a id='2197' tid='2198' class='m'>x</a> <span class='d'>=</span> <span class='d'>get_fpu_register_double(12)</span>;
    <a id='2199' tid='2200' class='m'>*</a><a id='2201' tid='2202' class='m'>y</a> <span class='d'>=</span> <span class='d'>get_fpu_register_double(14)</span>;
  } <span class='d'>else</span> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <a id='2165' tid='2166' class='m'>char</a> <a id='2167' tid='2168' class='m'>buffer</a>[<a id='2169' tid='2170' class='m'>sizeof</a>(<a id='2171' tid='2172' class='m'>*</a><a id='2173' tid='2174' class='m'>x</a>)];
    <span class='d'>int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>

    // Registers a0 and a1 -&gt; x.
    <span class='d'>reg_buffer[0] = get_register(a0);</span>
    <span class='d'>reg_buffer[1] = get_register(a1);</span>
    <span class='d'>memcpy(x, buffer, sizeof(buffer));</span>

    // Registers a2 and a3 -&gt; y.
    <span class='d'>reg_buffer[0] = get_register(a2);</span>
    <span class='d'>reg_buffer[1] = get_register(a3);</span>
    <span class='d'>memcpy(y, buffer, sizeof(buffer));</span>
  }
}


// For use in calls that take one double value, constructed either
// from a0 and a1 or f12.
<a id='2143' tid='2144' class='m'>void</a> <a id='2145' tid='2146' class='m'>Simulator</a><a id='2147' tid='2148' class='m'>::</a><a id='2149' tid='2150' class='m'>GetFpArgs</a>(<a id='2151' tid='2152' class='m'>double</a><a id='2153' tid='2154' class='m'>*</a> <a id='2155' tid='2156' class='m'>x</a>) {
  <span class='d'>if</span> <span class='d'>(!IsMipsSoftFloatABI)</span> {
    <a id='2157' tid='2158' class='m'>*</a><a id='2159' tid='2160' class='m'>x</a> <span class='d'>=</span> <span class='d'>get_fpu_register_double(12)</span>;
  } <span class='d'>else</span> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <span class='d'>char</span> <span class='d'>buffer</span>[<span class='d'>sizeof</span>(<a id='2139' tid='2140' class='m'>*</a><a id='2141' tid='2142' class='m'>x</a>)];
    <span class='d'>int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>
    // Registers a0 and a1 -&gt; x.
    <span class='d'>reg_buffer[0] = get_register(a0);</span>
    <span class='d'>reg_buffer[1] = get_register(a1);</span>
    <span class='d'>memcpy(x, buffer, sizeof(buffer));</span>
  }
}


// For use in calls that take one double value constructed either
// from a0 and a1 or f12 and one integer value.
<a id='2107' tid='2108' class='m'>void</a> <a id='2109' tid='2110' class='m'>Simulator</a><a id='2111' tid='2112' class='m'>::</a><a id='2113' tid='2114' class='m'>GetFpArgs</a>(<a id='2115' tid='2116' class='m'>double</a><a id='2117' tid='2118' class='m'>*</a> <a id='2119' tid='2120' class='m'>x</a>, <a id='2121' tid='2122' class='m'>int32_t</a><a id='2123' tid='2124' class='m'>*</a> <a id='2125' tid='2126' class='m'>y</a>) {
  <span class='d'>if</span> <span class='d'>(!IsMipsSoftFloatABI)</span> {
    <a id='2127' tid='2128' class='m'>*</a><a id='2129' tid='2130' class='m'>x</a> <span class='d'>=</span> <span class='d'>get_fpu_register_double(12)</span>;
    <a id='2131' tid='2132' class='m'>*</a><a id='2133' tid='2134' class='m'>y</a> <span class='d'>=</span> <span class='d'>get_register(a2)</span>;
  } <span class='d'>else</span> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <a id='2097' tid='2098' class='m'>char</a> <a id='2099' tid='2100' class='m'>buffer</a>[<a id='2101' tid='2102' class='m'>sizeof</a>(<a id='2103' tid='2104' class='m'>*</a><a id='2105' tid='2106' class='m'>x</a>)];
    <span class='d'>int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>
    // Registers 0 and 1 -&gt; x.
    <span class='d'>reg_buffer[0] = get_register(a0);</span>
    <span class='d'>reg_buffer[1] = get_register(a1);</span>
    <span class='d'>memcpy(x, buffer, sizeof(buffer));</span>

    // Register 2 -&gt; y.
    <span class='d'>reg_buffer[0] = get_register(a2);</span>
    <a id='2043' tid='2044' class='m'>memcpy</a>(<span class='d'>y</span>, <span class='d'>buffer</span>, <a id='2045' tid='2046' class='m'>sizeof</a>(<a id='2047' tid='2048' class='m'>*</a><a id='2049' tid='2050' class='m'>y</a>));
  }
}


// The return value is either in v0/v1 or f0.
<a id='2065' tid='2066' class='m'>void</a> <a id='2067' tid='2068' class='m'>Simulator</a><a id='2069' tid='2070' class='m'>::</a><a id='2071' tid='2072' class='m'>SetFpResult</a>(<a id='2073' tid='2074' class='m'>const</a> <a id='2075' tid='2076' class='m'>double</a><a id='2077' tid='2078' class='m'>&</a> <a id='2079' tid='2080' class='m'>result</a>) {
  <span class='d'>if</span> <span class='d'>(!IsMipsSoftFloatABI)</span> <span class='d'>{
    set_fpu_register_double(0, result);
  }</span> <span class='d'>else</span> {
    <a id='2051' tid='2052' class='m'>char</a> <a id='2053' tid='2054' class='m'>buffer</a>[<a id='2055' tid='2056' class='m'>2</a> <a id='2057' tid='2058' class='m'>*</a> <a id='2059' tid='2060' class='m'>sizeof</a>(<a id='2061' tid='2062' class='m'>registers_</a>[<a id='2063' tid='2064' class='m'>0</a>])];
    <span class='d'>int32_t* reg_buffer = reinterpret_cast&lt;int32_t*&gt;(buffer);</span>
    <a id='2081' tid='2082' class='m'>memcpy</a>(<a id='2083' tid='2084' class='m'>buffer</a>, <a id='2085' tid='2086' class='m'>&</a><a id='2087' tid='2088' class='m'>result</a>, <a id='2089' tid='2090' class='m'>sizeof</a>(<a id='2091' tid='2092' class='m'>buffer</a>));
    // Copy result to v0 and v1.
    <span class='d'>set_register(v0, reg_buffer[0]);</span>
    <span class='d'>set_register(v1, reg_buffer[1]);</span>
  }
}


// Helper functions for setting and testing the FCSR register&#39;s bits.
<span class='d'>void Simulator::set_fcsr_bit(uint32_t cc, bool value) {
  if (value) {
    FCSR_ |= (1 &lt;&lt; cc);
  } else {
    FCSR_ &= ~(1 &lt;&lt; cc);
  }
}</span>


<span class='d'>bool Simulator::test_fcsr_bit(uint32_t cc) {
  return FCSR_ & (1 &lt;&lt; cc);
}</span>


// Sets the rounding error codes in FCSR based on the result of the rounding.
// Returns true if the operation was invalid.
<span class='d'>bool Simulator::set_fcsr_round_error(double original, double rounded) {
  bool ret = false;

  if (!isfinite(original) || !isfinite(rounded)) {
    set_fcsr_bit(kFCSRInvalidOpFlagBit, true);
    ret = true;
  }

  if (original != rounded) {
    set_fcsr_bit(kFCSRInexactFlagBit, true);
  }

  if (rounded &lt; DBL_MIN && rounded &gt; -DBL_MIN && rounded != 0) {
    set_fcsr_bit(kFCSRUnderflowFlagBit, true);
    ret = true;
  }

  if (rounded &gt; INT_MAX || rounded &lt; INT_MIN) {
    set_fcsr_bit(kFCSROverflowFlagBit, true);
    // The reference is not really clear but it seems this is required:
    set_fcsr_bit(kFCSRInvalidOpFlagBit, true);
    ret = true;
  }

  return ret;
}</span>


// Raw access to the PC register.
<a id='2337' tid='2338' class='m'>void</a> <a id='2339' tid='2340' class='m'>Simulator</a><a id='2341' tid='2342' class='m'>::</a><a id='2343' tid='2344' class='m'>set_pc</a>(<a id='2345' tid='2346' class='m'>int32_t</a> <a id='2347' tid='2348' class='m'>value</a>) {
  <a id='2349' tid='2350' class='m'>pc_modified_</a> <a id='2351' tid='2352' class='m'>=</a> <a id='2353' tid='2354' class='m'>true</a>;
  <a id='2355' tid='2356' class='m'>registers_</a>[<a id='2357' tid='2358' class='m'>pc</a>] <a id='2359' tid='2360' class='m'>=</a> <a id='2361' tid='2362' class='m'>value</a>;
}


<a id='2285' tid='2286' class='m'>bool</a> <a id='2287' tid='2288' class='m'>Simulator</a><a id='2289' tid='2290' class='m'>::</a><a id='2291' tid='2292' class='m'>has_bad_pc</a>() <a id='2293' tid='2294' class='m'>const</a> {
  <a id='2255' tid='2256' class='m'>return</a> ((<a id='2257' tid='2258' class='m'>registers_</a>[<a id='2259' tid='2260' class='m'>pc</a>] <span class='d'>==</span> <span class='d'>bad_ra</span>) <a id='2261' tid='2262' class='m'>||</a> (<a id='2263' tid='2264' class='m'>registers_</a>[<a id='2265' tid='2266' class='m'>pc</a>] <a id='2267' tid='2268' class='m'>==</a> <a id='2269' tid='2270' class='m'>end_sim_pc</a>));
}


// Raw access to the PC register without the special adjustment when reading.
<a id='2221' tid='2222' class='m'>int32_t</a> <a id='2223' tid='2224' class='m'>Simulator</a><a id='2225' tid='2226' class='m'>::</a><a id='2227' tid='2228' class='m'>get_pc</a>() <a id='2229' tid='2230' class='m'>const</a> {
  <a id='2207' tid='2208' class='m'>return</a> <a id='2209' tid='2210' class='m'>registers_</a>[<a id='2211' tid='2212' class='m'>pc</a>];
}


// The MIPS cannot do unaligned reads and writes.  On some MIPS platforms an
// interrupt is caused.  On others it does a funky rotation thing.  For now we
// simply disallow unaligned reads, but at some point we may want to move to
// emulating the rotate behaviour.  Note that simulator runs have the runtime
// system running directly on the host system and only generated code is
// executed in the simulator.  Since the host is typically IA32 we will not
// get the correct MIPS-like behaviour on unaligned accesses.

<a id='2007' tid='2008' class='m'>int</a> <a id='2009' tid='2010' class='m'>Simulator</a><a id='2011' tid='2012' class='m'>::</a><a id='2013' tid='2014' class='m'>ReadW</a>(<a id='2015' tid='2016' class='m'>int32_t</a> <a id='2017' tid='2018' class='m'>addr</a>, <a id='2019' tid='2020' class='m'>Instruction</a><a id='2021' tid='2022' class='m'>*</a> <a id='2023' tid='2024' class='m'>instr</a>) {
  <span class='d'>if (addr &gt;=0 && addr &lt; 0x400) {
    // This has to be a NULL-dereference, drop into debugger.
    MipsDebugger dbg(this);
    dbg.Debug();
  }</span>
  <span class='d'>if</span> <span class='d'>((addr & kPointerAlignmentMask) == 0)</span> {
    <a id='2025' tid='2026' class='m'>intptr_t</a><a id='2027' tid='2028' class='m'>*</a> <a id='2029' tid='2030' class='m'>ptr</a> = <a id='2031' tid='2032' class='m'>reinterpret_cast</a>&lt;<a id='2033' tid='2034' class='m'>intptr_t</a><a id='2035' tid='2036' class='m'>*</a>&gt;(<a id='2037' tid='2038' class='m'>addr</a>);
    <span class='d'>return *ptr;</span>
  }
  <a id='1991' tid='1992' class='m'>PrintF</a>(<a id='1993' tid='1994' class='m'>&quot;Unaligned read at 0x%08x, pc=0x%08&quot;</a> <a id='1995' tid='1996' class='m'>V8PRIxPTR</a> <a id='1997' tid='1998' class='m'>&quot;\n&quot;</a>,
         <a id='1999' tid='2000' class='m'>addr</a>,
         <a id='2001' tid='2002' class='m'>reinterpret_cast</a>&lt;<a id='2003' tid='2004' class='m'>intptr_t</a>&gt;(<a id='2005' tid='2006' class='m'>instr</a>));
  <span class='d'>MipsDebugger dbg(this)</span>;
  <span class='d'>dbg.Debug();</span>
  <a id='1931' tid='1932' class='m'>return</a> <a id='1933' tid='1934' class='m'>0</a>;
}


<a id='1951' tid='1952' class='m'>void</a> <a id='1953' tid='1954' class='m'>Simulator</a><a id='1955' tid='1956' class='m'>::</a><a id='1957' tid='1958' class='m'>WriteW</a>(<a id='1959' tid='1960' class='m'>int32_t</a> <a id='1961' tid='1962' class='m'>addr</a>, <a id='1963' tid='1964' class='m'>int</a> <a id='1965' tid='1966' class='m'>value</a>, <a id='1967' tid='1968' class='m'>Instruction</a><a id='1969' tid='1970' class='m'>*</a> <a id='1971' tid='1972' class='m'>instr</a>) {
  <span class='d'>if (addr &gt;= 0 && addr &lt; 0x400) {
    // This has to be a NULL-dereference, drop into debugger.
    MipsDebugger dbg(this);
    dbg.Debug();
  }</span>
  <span class='d'>if</span> <span class='d'>((addr & kPointerAlignmentMask) == 0)</span> {
    <a id='1973' tid='1974' class='m'>intptr_t</a><a id='1975' tid='1976' class='m'>*</a> <a id='1977' tid='1978' class='m'>ptr</a> = <a id='1979' tid='1980' class='m'>reinterpret_cast</a>&lt;<a id='1981' tid='1982' class='m'>intptr_t</a><a id='1983' tid='1984' class='m'>*</a>&gt;(<a id='1985' tid='1986' class='m'>addr</a>);
    <a id='1871' tid='1872' class='m'>*</a><a id='1873' tid='1874' class='m'>ptr</a> <a id='1875' tid='1876' class='m'>=</a> <a id='1877' tid='1878' class='m'>value</a>;
    <span class='d'>return;</span>
  }
  <a id='1935' tid='1936' class='m'>PrintF</a>(<a id='1937' tid='1938' class='m'>&quot;Unaligned write at 0x%08x, pc=0x%08&quot;</a> <a id='1939' tid='1940' class='m'>V8PRIxPTR</a> <a id='1941' tid='1942' class='m'>&quot;\n&quot;</a>,
         <a id='1943' tid='1944' class='m'>addr</a>,
         <a id='1945' tid='1946' class='m'>reinterpret_cast</a>&lt;<a id='1947' tid='1948' class='m'>intptr_t</a>&gt;(<a id='1949' tid='1950' class='m'>instr</a>));
  <span class='d'>MipsDebugger dbg(this)</span>;
  <span class='d'>dbg.Debug();</span>
}


<span class='d'>double Simulator::ReadD(int32_t addr, Instruction* instr) {
  if ((addr & kDoubleAlignmentMask) == 0) {
    double* ptr = reinterpret_cast&lt;double*&gt;(addr);
    return *ptr;
  }
  PrintF(&quot;Unaligned (double) read at 0x%08x, pc=0x%08&quot; V8PRIxPTR &quot;\n&quot;,
         addr,
         reinterpret_cast&lt;intptr_t&gt;(instr));
  OS::Abort();
  return 0;
}</span>


<span class='d'>void Simulator::WriteD(int32_t addr, double value, Instruction* instr) {
  if ((addr & kDoubleAlignmentMask) == 0) {
    double* ptr = reinterpret_cast&lt;double*&gt;(addr);
    *ptr = value;
    return;
  }
  PrintF(&quot;Unaligned (double) write at 0x%08x, pc=0x%08&quot; V8PRIxPTR &quot;\n&quot;,
         addr,
         reinterpret_cast&lt;intptr_t&gt;(instr));
  OS::Abort();
}</span>


<a id='1895' tid='1896' class='m'>uint16_t</a> <a id='1897' tid='1898' class='m'>Simulator</a><a id='1899' tid='1900' class='m'>::</a><a id='1901' tid='1902' class='m'>ReadHU</a>(<a id='1903' tid='1904' class='m'>int32_t</a> <a id='1905' tid='1906' class='m'>addr</a>, <a id='1907' tid='1908' class='m'>Instruction</a><a id='1909' tid='1910' class='m'>*</a> <a id='1911' tid='1912' class='m'>instr</a>) {
  <span class='d'>if</span> ((<a id='1821' tid='1822' class='m'>addr</a> <a id='1823' tid='1824' class='m'>&</a> <a id='1825' tid='1826' class='m'>1</a>) <a id='1827' tid='1828' class='m'>==</a> <a id='1829' tid='1830' class='m'>0</a>) {
    <a id='1913' tid='1914' class='m'>uint16_t</a><a id='1915' tid='1916' class='m'>*</a> <a id='1917' tid='1918' class='m'>ptr</a> = <a id='1919' tid='1920' class='m'>reinterpret_cast</a>&lt;<a id='1921' tid='1922' class='m'>uint16_t</a><a id='1923' tid='1924' class='m'>*</a>&gt;(<a id='1925' tid='1926' class='m'>addr</a>);
    <span class='d'>return *ptr;</span>
  }
  <a id='1879' tid='1880' class='m'>PrintF</a>(<a id='1881' tid='1882' class='m'>&quot;Unaligned unsigned halfword read at 0x%08x, pc=0x%08&quot;</a> <a id='1883' tid='1884' class='m'>V8PRIxPTR</a> <a id='1885' tid='1886' class='m'>&quot;\n&quot;</a>,
         <a id='1887' tid='1888' class='m'>addr</a>,
         <a id='1889' tid='1890' class='m'>reinterpret_cast</a>&lt;<a id='1891' tid='1892' class='m'>intptr_t</a>&gt;(<a id='1893' tid='1894' class='m'>instr</a>));
  <span class='d'>OS::Abort();</span>
  <a id='1751' tid='1752' class='m'>return</a> <a id='1753' tid='1754' class='m'>0</a>;
}


<a id='1835' tid='1836' class='m'>int16_t</a> <a id='1837' tid='1838' class='m'>Simulator</a><a id='1839' tid='1840' class='m'>::</a><a id='1841' tid='1842' class='m'>ReadH</a>(<a id='1843' tid='1844' class='m'>int32_t</a> <a id='1845' tid='1846' class='m'>addr</a>, <a id='1847' tid='1848' class='m'>Instruction</a><a id='1849' tid='1850' class='m'>*</a> <a id='1851' tid='1852' class='m'>instr</a>) {
  <span class='d'>if</span> ((<a id='1755' tid='1756' class='m'>addr</a> <a id='1757' tid='1758' class='m'>&</a> <a id='1759' tid='1760' class='m'>1</a>) <a id='1761' tid='1762' class='m'>==</a> <a id='1763' tid='1764' class='m'>0</a>) {
    <a id='1853' tid='1854' class='m'>int16_t</a><a id='1855' tid='1856' class='m'>*</a> <a id='1857' tid='1858' class='m'>ptr</a> = <a id='1859' tid='1860' class='m'>reinterpret_cast</a>&lt;<a id='1861' tid='1862' class='m'>int16_t</a><a id='1863' tid='1864' class='m'>*</a>&gt;(<a id='1865' tid='1866' class='m'>addr</a>);
    <span class='d'>return *ptr;</span>
  }
  <span class='d'>PrintF(&quot;Unaligned signed halfword read at 0x%08x, pc=0x%08&quot; V8PRIxPTR &quot;\n&quot;,
         addr,
         reinterpret_cast&lt;intptr_t&gt;(instr));</span>
  <span class='d'>OS::Abort();</span>
  <a id='1831' tid='1832' class='m'>return</a> <a id='1833' tid='1834' class='m'>0</a>;
}


<a id='1781' tid='1782' class='m'>void</a> <a id='1783' tid='1784' class='m'>Simulator</a><a id='1785' tid='1786' class='m'>::</a><a id='1787' tid='1788' class='m'>WriteH</a>(<a id='1789' tid='1790' class='m'>int32_t</a> <a id='1791' tid='1792' class='m'>addr</a>, <a id='1793' tid='1794' class='m'>uint16_t</a> <a id='1795' tid='1796' class='m'>value</a>, <a id='1797' tid='1798' class='m'>Instruction</a><a id='1799' tid='1800' class='m'>*</a> <a id='1801' tid='1802' class='m'>instr</a>) {
  <span class='d'>if</span> ((<a id='1653' tid='1654' class='m'>addr</a> <a id='1655' tid='1656' class='m'>&</a> <a id='1657' tid='1658' class='m'>1</a>) <a id='1659' tid='1660' class='m'>==</a> <a id='1661' tid='1662' class='m'>0</a>) {
    <a id='1803' tid='1804' class='m'>uint16_t</a><a id='1805' tid='1806' class='m'>*</a> <a id='1807' tid='1808' class='m'>ptr</a> = <a id='1809' tid='1810' class='m'>reinterpret_cast</a>&lt;<a id='1811' tid='1812' class='m'>uint16_t</a><a id='1813' tid='1814' class='m'>*</a>&gt;(<a id='1815' tid='1816' class='m'>addr</a>);
    <a id='1687' tid='1688' class='m'>*</a><a id='1689' tid='1690' class='m'>ptr</a> <a id='1691' tid='1692' class='m'>=</a> <a id='1693' tid='1694' class='m'>value</a>;
    <span class='d'>return;</span>
  }
  <a id='1765' tid='1766' class='m'>PrintF</a>(<a id='1767' tid='1768' class='m'>&quot;Unaligned unsigned halfword write at 0x%08x, pc=0x%08&quot;</a> <a id='1769' tid='1770' class='m'>V8PRIxPTR</a> <a id='1771' tid='1772' class='m'>&quot;\n&quot;</a>,
         <a id='1773' tid='1774' class='m'>addr</a>,
         <a id='1775' tid='1776' class='m'>reinterpret_cast</a>&lt;<a id='1777' tid='1778' class='m'>intptr_t</a>&gt;(<a id='1779' tid='1780' class='m'>instr</a>));
  <span class='d'>OS::Abort();</span>
}


<a id='1711' tid='1712' class='m'>void</a> <a id='1713' tid='1714' class='m'>Simulator</a><a id='1715' tid='1716' class='m'>::</a><a id='1717' tid='1718' class='m'>WriteH</a>(<a id='1719' tid='1720' class='m'>int32_t</a> <a id='1721' tid='1722' class='m'>addr</a>, <a id='1723' tid='1724' class='m'>int16_t</a> <a id='1725' tid='1726' class='m'>value</a>, <a id='1727' tid='1728' class='m'>Instruction</a><a id='1729' tid='1730' class='m'>*</a> <a id='1731' tid='1732' class='m'>instr</a>) {
  <span class='d'>if</span> ((<a id='1663' tid='1664' class='m'>addr</a> <a id='1665' tid='1666' class='m'>&</a> <a id='1667' tid='1668' class='m'>1</a>) <a id='1669' tid='1670' class='m'>==</a> <a id='1671' tid='1672' class='m'>0</a>) {
    <a id='1733' tid='1734' class='m'>int16_t</a><a id='1735' tid='1736' class='m'>*</a> <a id='1737' tid='1738' class='m'>ptr</a> = <a id='1739' tid='1740' class='m'>reinterpret_cast</a>&lt;<a id='1741' tid='1742' class='m'>int16_t</a><a id='1743' tid='1744' class='m'>*</a>&gt;(<a id='1745' tid='1746' class='m'>addr</a>);
    <a id='1617' tid='1618' class='m'>*</a><a id='1619' tid='1620' class='m'>ptr</a> <a id='1621' tid='1622' class='m'>=</a> <a id='1623' tid='1624' class='m'>value</a>;
    <span class='d'>return;</span>
  }
  <a id='1695' tid='1696' class='m'>PrintF</a>(<a id='1697' tid='1698' class='m'>&quot;Unaligned halfword write at 0x%08x, pc=0x%08&quot;</a> <a id='1699' tid='1700' class='m'>V8PRIxPTR</a> <a id='1701' tid='1702' class='m'>&quot;\n&quot;</a>,
         <a id='1703' tid='1704' class='m'>addr</a>,
         <a id='1705' tid='1706' class='m'>reinterpret_cast</a>&lt;<a id='1707' tid='1708' class='m'>intptr_t</a>&gt;(<a id='1709' tid='1710' class='m'>instr</a>));
  <span class='d'>OS::Abort();</span>
}


<span class='d'>uint32_t</span> <a id='1677' tid='1678' class='m'>Simulator</a><a id='1679' tid='1680' class='m'>::</a><a id='1681' tid='1682' class='m'>ReadBU</a>(<a id='1673' tid='1674' class='m'>int32_t</a> <a id='1675' tid='1676' class='m'>addr</a>) {
  <a id='1625' tid='1626' class='m'>uint8_t</a><a id='1627' tid='1628' class='m'>*</a> <a id='1629' tid='1630' class='m'>ptr</a> = <a id='1631' tid='1632' class='m'>reinterpret_cast</a>&lt;<a id='1633' tid='1634' class='m'>uint8_t</a><a id='1635' tid='1636' class='m'>*</a>&gt;(<a id='1637' tid='1638' class='m'>addr</a>);
  <span class='d'>return *ptr & 0xff;</span>
}


<span class='d'>int32_t</span> <a id='1643' tid='1644' class='m'>Simulator</a><a id='1645' tid='1646' class='m'>::</a><a id='1647' tid='1648' class='m'>ReadB</a>(<a id='1639' tid='1640' class='m'>int32_t</a> <a id='1641' tid='1642' class='m'>addr</a>) {
  <a id='1555' tid='1556' class='m'>int8_t</a><a id='1557' tid='1558' class='m'>*</a> <a id='1559' tid='1560' class='m'>ptr</a> = <a id='1561' tid='1562' class='m'>reinterpret_cast</a>&lt;<a id='1563' tid='1564' class='m'>int8_t</a><a id='1565' tid='1566' class='m'>*</a>&gt;(<a id='1567' tid='1568' class='m'>addr</a>);
  <a id='1569' tid='1570' class='m'>return</a> <a id='1571' tid='1572' class='m'>*</a><a id='1573' tid='1574' class='m'>ptr</a>;
}


<a id='1575' tid='1576' class='m'>void</a> <a id='1577' tid='1578' class='m'>Simulator</a><a id='1579' tid='1580' class='m'>::</a><a id='1581' tid='1582' class='m'>WriteB</a>(<a id='1583' tid='1584' class='m'>int32_t</a> <a id='1585' tid='1586' class='m'>addr</a>, <a id='1587' tid='1588' class='m'>uint8_t</a> <a id='1589' tid='1590' class='m'>value</a>) {
  <a id='1591' tid='1592' class='m'>uint8_t</a><a id='1593' tid='1594' class='m'>*</a> <a id='1595' tid='1596' class='m'>ptr</a> = <a id='1597' tid='1598' class='m'>reinterpret_cast</a>&lt;<a id='1599' tid='1600' class='m'>uint8_t</a><a id='1601' tid='1602' class='m'>*</a>&gt;(<a id='1603' tid='1604' class='m'>addr</a>);
  <a id='1605' tid='1606' class='m'>*</a><a id='1607' tid='1608' class='m'>ptr</a> <a id='1609' tid='1610' class='m'>=</a> <a id='1611' tid='1612' class='m'>value</a>;
}


<a id='1513' tid='1514' class='m'>void</a> <a id='1515' tid='1516' class='m'>Simulator</a><a id='1517' tid='1518' class='m'>::</a><a id='1519' tid='1520' class='m'>WriteB</a>(<a id='1521' tid='1522' class='m'>int32_t</a> <a id='1523' tid='1524' class='m'>addr</a>, <a id='1525' tid='1526' class='m'>int8_t</a> <a id='1527' tid='1528' class='m'>value</a>) {
  <a id='1529' tid='1530' class='m'>int8_t</a><a id='1531' tid='1532' class='m'>*</a> <a id='1533' tid='1534' class='m'>ptr</a> = <a id='1535' tid='1536' class='m'>reinterpret_cast</a>&lt;<a id='1537' tid='1538' class='m'>int8_t</a><a id='1539' tid='1540' class='m'>*</a>&gt;(<a id='1541' tid='1542' class='m'>addr</a>);
  <a id='1543' tid='1544' class='m'>*</a><a id='1545' tid='1546' class='m'>ptr</a> <a id='1547' tid='1548' class='m'>=</a> <a id='1549' tid='1550' class='m'>value</a>;
}


// Returns the limit of the stack area to enable checking for stack overflows.
<a id='1499' tid='1500' class='m'>uintptr_t</a> <a id='1501' tid='1502' class='m'>Simulator</a><a id='1503' tid='1504' class='m'>::</a><a id='1505' tid='1506' class='m'>StackLimit</a>() <a id='1507' tid='1508' class='m'>const</a> {
  // Leave a safety margin of 256 bytes to prevent overrunning the stack when
  // pushing values.
  <a id='1483' tid='1484' class='m'>return</a> <a id='1485' tid='1486' class='m'>reinterpret_cast</a>&lt;<a id='1487' tid='1488' class='m'>uintptr_t</a>&gt;(<a id='1489' tid='1490' class='m'>stack_</a>) <a id='1491' tid='1492' class='m'>+</a> <a id='1493' tid='1494' class='m'>256</a>;
}


// Unsupported instructions use Format to print an error and stop execution.
<a id='1445' tid='1446' class='m'>void</a> <a id='1447' tid='1448' class='m'>Simulator</a><a id='1449' tid='1450' class='m'>::</a><a id='1451' tid='1452' class='m'>Format</a>(<a id='1453' tid='1454' class='m'>Instruction</a><a id='1455' tid='1456' class='m'>*</a> <a id='1457' tid='1458' class='m'>instr</a>, <a id='1459' tid='1460' class='m'>const</a> <a id='1461' tid='1462' class='m'>char</a><a id='1463' tid='1464' class='m'>*</a> <a id='1465' tid='1466' class='m'>format</a>) {
  <a id='1467' tid='1468' class='m'>PrintF</a>(<a id='1469' tid='1470' class='m'>&quot;Simulator found unsupported instruction:\n 0x%08x: %s\n&quot;</a>,
         <a id='1471' tid='1472' class='m'>reinterpret_cast</a>&lt;<a id='1473' tid='1474' class='m'>intptr_t</a>&gt;(<a id='1475' tid='1476' class='m'>instr</a>), <a id='1477' tid='1478' class='m'>format</a>);
  <span class='d'>UNIMPLEMENTED_MIPS();</span>
}


// Calls into the V8 runtime are based on this very simple interface.
// Note: To be able to return two values from some calls the code in runtime.cc
// uses the ObjectPair which is essentially two 32-bit values stuffed into a
// 64-bit value. With the code below we assume that all runtime calls return
// 64 bits of result. If they don&#39;t, the v1 result register contains a bogus
// value, which is fine because it is caller-saved.
<a id='1409' tid='1410' class='m'>typedef</a> <a id='1411' tid='1412' class='m'>int64_t</a> (<a id='1413' tid='1414' class='m'>*</a><a id='1415' tid='1416' class='m'>SimulatorRuntimeCall</a>)(<a id='1417' tid='1418' class='m'>int32_t</a> <a id='1419' tid='1420' class='m'>arg0</a>,
                                        <a id='1421' tid='1422' class='m'>int32_t</a> <a id='1423' tid='1424' class='m'>arg1</a>,
                                        <a id='1425' tid='1426' class='m'>int32_t</a> <a id='1427' tid='1428' class='m'>arg2</a>,
                                        <a id='1429' tid='1430' class='m'>int32_t</a> <a id='1431' tid='1432' class='m'>arg3</a>,
                                        <a id='1433' tid='1434' class='m'>int32_t</a> <a id='1435' tid='1436' class='m'>arg4</a>,
                                        <a id='1437' tid='1438' class='m'>int32_t</a> <a id='1439' tid='1440' class='m'>arg5</a>);
<a id='1381' tid='1382' class='m'>typedef</a> <a id='1383' tid='1384' class='m'>double</a> (<a id='1385' tid='1386' class='m'>*</a><a id='1387' tid='1388' class='m'>SimulatorRuntimeFPCall</a>)(<a id='1389' tid='1390' class='m'>int32_t</a> <a id='1391' tid='1392' class='m'>arg0</a>,
                                         <a id='1393' tid='1394' class='m'>int32_t</a> <a id='1395' tid='1396' class='m'>arg1</a>,
                                         <a id='1397' tid='1398' class='m'>int32_t</a> <a id='1399' tid='1400' class='m'>arg2</a>,
                                         <a id='1401' tid='1402' class='m'>int32_t</a> <a id='1403' tid='1404' class='m'>arg3</a>);

// This signature supports direct call in to API function native callback
// (refer to InvocationCallback in v8.h).
<a id='1355' tid='1356' class='m'>typedef</a> <a id='1357' tid='1358' class='m'>v8</a><a id='1359' tid='1360' class='m'>::</a><a id='1361' tid='1362' class='m'>Handle</a>&lt;<a id='1363' tid='1364' class='m'>v8</a><a id='1365' tid='1366' class='m'>::</a><a id='1367' tid='1368' class='m'>Value</a>&gt; (<a id='1369' tid='1370' class='m'>*</a><a id='1371' tid='1372' class='m'>SimulatorRuntimeDirectApiCall</a>)(<a id='1373' tid='1374' class='m'>int32_t</a> <a id='1375' tid='1376' class='m'>arg0</a>);

// This signature supports direct call to accessor getter callback.
<a id='1325' tid='1326' class='m'>typedef</a> <a id='1327' tid='1328' class='m'>v8</a><a id='1329' tid='1330' class='m'>::</a><a id='1331' tid='1332' class='m'>Handle</a>&lt;<a id='1333' tid='1334' class='m'>v8</a><a id='1335' tid='1336' class='m'>::</a><a id='1337' tid='1338' class='m'>Value</a>&gt; (<a id='1339' tid='1340' class='m'>*</a><a id='1341' tid='1342' class='m'>SimulatorRuntimeDirectGetterCall</a>)(<a id='1343' tid='1344' class='m'>int32_t</a> <a id='1345' tid='1346' class='m'>arg0</a>,
                                                                  <a id='1347' tid='1348' class='m'>int32_t</a> <a id='1349' tid='1350' class='m'>arg1</a>);

// Software interrupt instructions are used by the simulator to call into the
// C-based V8 runtime. They are also used for debugging with simulator.
<a id='1293' tid='1294' class='m'>void</a> <a id='1295' tid='1296' class='m'>Simulator</a><a id='1297' tid='1298' class='m'>::</a><a id='1299' tid='1300' class='m'>SoftwareInterrupt</a>(<a id='1301' tid='1302' class='m'>Instruction</a><a id='1303' tid='1304' class='m'>*</a> <a id='1305' tid='1306' class='m'>instr</a>) {
  // There are several instructions that could get us here,
  // the break_ instruction, or several variants of traps. All
  // Are &quot;SPECIAL&quot; class opcode, and are distinuished by function.
  <span class='d'>int32_t func = instr-&gt;FunctionFieldRaw();</span>
  <span class='d'>uint32_t code = (func == BREAK) ? instr-&gt;Bits(25, 6) : -1;</span>

  // We first check if we met a call_rt_redirected.
  <span class='d'>if</span> <span class='d'>(instr-&gt;InstructionBits() == rtCallRedirInstr)</span> {
    <a id='1307' tid='1308' class='m'>Redirection</a><a id='1309' tid='1310' class='m'>*</a> <a id='1311' tid='1312' class='m'>redirection</a> = <a id='1313' tid='1314' class='m'>Redirection</a><a id='1315' tid='1316' class='m'>::</a><a id='1317' tid='1318' class='m'>FromSwiInstruction</a>(<a id='1319' tid='1320' class='m'>instr</a>);
    <span class='d'>int32_t arg0 = get_register(a0);</span>
    <span class='d'>int32_t arg1 = get_register(a1);</span>
    <span class='d'>int32_t arg2 = get_register(a2);</span>
    <span class='d'>int32_t arg3 = get_register(a3);</span>
    <span class='d'>int32_t arg4 = 0;</span>
    <span class='d'>int32_t arg5 = 0;</span>

    // Need to check if sp is valid before assigning arg4, arg5.
    // This is a fix for cctest test-api/CatchStackOverflow which causes
    // the stack to overflow. For some reason arm doesn&#39;t need this
    // stack check here.
    <a id='1277' tid='1278' class='m'>int32_t</a><a id='1279' tid='1280' class='m'>*</a> <a id='1281' tid='1282' class='m'>stack_pointer</a> = <a id='1283' tid='1284' class='m'>reinterpret_cast</a>&lt;<a id='1285' tid='1286' class='m'>int32_t</a><a id='1287' tid='1288' class='m'>*</a>&gt;(<a id='1289' tid='1290' class='m'>get_register</a>(<a id='1291' tid='1292' class='m'>sp</a>));
    <span class='d'>int32_t* stack = reinterpret_cast&lt;int32_t*&gt;(stack_);</span>
    <span class='d'>if (stack_pointer &gt;= stack && stack_pointer &lt; stack + stack_size_ - 5) {
      // Args 4 and 5 are on the stack after the reserved space for args 0..3.
      arg4 = stack_pointer[4];
      arg5 = stack_pointer[5];
    }</span>

    <a id='1193' tid='1194' class='m'>bool</a> <a id='1195' tid='1196' class='m'>fp_call</a> =
         (<a id='1197' tid='1198' class='m'>redirection</a>-&gt;<a id='1199' tid='1200' class='m'>type</a>() <a id='1201' tid='1202' class='m'>==</a> <a id='1203' tid='1204' class='m'>ExternalReference</a><a id='1205' tid='1206' class='m'>::</a><a id='1207' tid='1208' class='m'>BUILTIN_FP_FP_CALL</a>) <a id='1209' tid='1210' class='m'>||</a>
         (<a id='1211' tid='1212' class='m'>redirection</a>-&gt;<a id='1213' tid='1214' class='m'>type</a>() <a id='1215' tid='1216' class='m'>==</a> <a id='1217' tid='1218' class='m'>ExternalReference</a><a id='1219' tid='1220' class='m'>::</a><a id='1221' tid='1222' class='m'>BUILTIN_COMPARE_CALL</a>) <a id='1223' tid='1224' class='m'>||</a>
         (<a id='1225' tid='1226' class='m'>redirection</a>-&gt;<a id='1227' tid='1228' class='m'>type</a>() <a id='1229' tid='1230' class='m'>==</a> <a id='1231' tid='1232' class='m'>ExternalReference</a><a id='1233' tid='1234' class='m'>::</a><a id='1235' tid='1236' class='m'>BUILTIN_FP_CALL</a>) <a id='1237' tid='1238' class='m'>||</a>
         (<a id='1239' tid='1240' class='m'>redirection</a>-&gt;<a id='1241' tid='1242' class='m'>type</a>() <a id='1243' tid='1244' class='m'>==</a> <a id='1245' tid='1246' class='m'>ExternalReference</a><a id='1247' tid='1248' class='m'>::</a><a id='1249' tid='1250' class='m'>BUILTIN_FP_INT_CALL</a>);

    <span class='d'>if</span> <span class='d'>(!IsMipsSoftFloatABI)</span> {
      // With the hard floating point calling convention, double
      // arguments are passed in FPU registers. Fetch the arguments
      // from there and call the builtin using soft floating point
      // convention.
      <a id='1153' tid='1154' class='m'>switch</a> (<a id='1155' tid='1156' class='m'>redirection</a>-&gt;<a id='1157' tid='1158' class='m'>type</a>()) {
      <span class='d'>case</span> <a id='1159' tid='1160' class='m'>ExternalReference</a><a id='1161' tid='1162' class='m'>::</a><a id='1163' tid='1164' class='m'>BUILTIN_FP_FP_CALL</a>:
      <a id='1119' tid='1120' class='m'>case</a> <a id='1121' tid='1122' class='m'>ExternalReference</a><a id='1123' tid='1124' class='m'>::</a><a id='1125' tid='1126' class='m'>BUILTIN_COMPARE_CALL</a>:
        <span class='d'>arg0 = get_fpu_register(f12)</span>;
        <span class='d'>arg1 = get_fpu_register(f13);</span>
        <span class='d'>arg2 = get_fpu_register(f14);</span>
        <span class='d'>arg3 = get_fpu_register(f15);</span>
        <span class='d'>break;</span>
      <a id='1059' tid='1060' class='m'>case</a> <a id='1061' tid='1062' class='m'>ExternalReference</a><a id='1063' tid='1064' class='m'>::</a><a id='1065' tid='1066' class='m'>BUILTIN_FP_CALL</a>:
        <span class='d'>arg0 = get_fpu_register(f12)</span>;
        <span class='d'>arg1 = get_fpu_register(f13);</span>
        <span class='d'>break;</span>
      <a id='795' tid='796' class='m'>case</a> <a id='797' tid='798' class='m'>ExternalReference</a><a id='799' tid='800' class='m'>::</a><a id='801' tid='802' class='m'>BUILTIN_FP_INT_CALL</a>:
        <span class='d'>arg0 = get_fpu_register(f12)</span>;
        <span class='d'>arg1 = get_fpu_register(f13);</span>
        <span class='d'>arg2 = get_register(a2);</span>
        <span class='d'>break;</span>
      <a id='601' tid='602' class='m'>default</a>:
        <a id='603' tid='604' class='m'>break</a>;
      }
    }

    // This is dodgy but it works because the C entry stubs are never moved.
    // See comment in codegen-arm.cc and bug 1242173.
    <span class='d'>int32_t saved_ra = get_register(ra);</span>

    <a id='1107' tid='1108' class='m'>intptr_t</a> <a id='1109' tid='1110' class='m'>external</a> =
          <a id='1111' tid='1112' class='m'>reinterpret_cast</a>&lt;<a id='1113' tid='1114' class='m'>intptr_t</a>&gt;(<a id='1115' tid='1116' class='m'>redirection</a>-&gt;<a id='1117' tid='1118' class='m'>external_function</a>());

    // Based on CpuFeatures::IsSupported(FPU), Mips will use either hardware
    // FPU, or gcc soft-float routines. Hardware FPU is simulated in this
    // simulator. Soft-float has additional abstraction of ExternalReference,
    // to support serialization.
    <span class='d'>if</span> <span class='d'>(fp_call)</span> {
      <a id='1049' tid='1050' class='m'>SimulatorRuntimeFPCall</a> <a id='1051' tid='1052' class='m'>target</a> =
                  <a id='1053' tid='1054' class='m'>reinterpret_cast</a>&lt;<a id='1055' tid='1056' class='m'>SimulatorRuntimeFPCall</a>&gt;(<a id='1057' tid='1058' class='m'>external</a>);
      <span class='d'>if</span> (<a id='617' tid='618' class='m'>::</a><a id='619' tid='620' class='m'>v8</a><a id='621' tid='622' class='m'>::</a><a id='623' tid='624' class='m'>internal</a><a id='625' tid='626' class='m'>::</a><a id='627' tid='628' class='m'>FLAG_trace_sim</a>) {
        <a id='977' tid='978' class='m'>double</a> <a id='979' tid='980' class='m'>dval0</a>, <a id='981' tid='982' class='m'>dval1</a>;
        <a id='815' tid='816' class='m'>int32_t</a> <a id='817' tid='818' class='m'>ival</a>;
        <span class='d'>switch</span> (<span class='d'>redirection-&gt;type()</span>) {
          <a id='117' tid='118' class='m'>case</a> <a id='531' tid='532' class='m'>ExternalReference</a><a id='533' tid='534' class='m'>::</a><a id='535' tid='536' class='m'>BUILTIN_FP_FP_CALL</a>:
          <a id='425' tid='426' class='m'>case</a> <a id='427' tid='428' class='m'>ExternalReference</a><a id='429' tid='430' class='m'>::</a><a id='431' tid='432' class='m'>BUILTIN_COMPARE_CALL</a>:
            <a id='433' tid='434' class='m'>GetFpArgs</a>(<a id='435' tid='436' class='m'>&</a><a id='437' tid='438' class='m'>dval0</a>, <a id='439' tid='440' class='m'>&</a><a id='441' tid='442' class='m'>dval1</a>);
            <a id='629' tid='630' class='m'>PrintF</a>(<span class='d'>&quot;Call to host function at %p with args %f, %f&quot;</span>,
                <a id='631' tid='632' class='m'>FUNCTION_ADDR</a>(<a id='633' tid='634' class='m'>target</a>), <span class='d'>dval0</span>, <span class='d'>dval1</span>);
            <a id='119' tid='120' class='m'>break</a>;
          <a id='313' tid='314' class='m'>case</a> <a id='315' tid='316' class='m'>ExternalReference</a><a id='317' tid='318' class='m'>::</a><a id='319' tid='320' class='m'>BUILTIN_FP_CALL</a>:
            <a id='321' tid='322' class='m'>GetFpArgs</a>(<a id='323' tid='324' class='m'>&</a><a id='325' tid='326' class='m'>dval0</a>);
            <a id='353' tid='354' class='m'>PrintF</a>(<span class='d'>&quot;Call to host function at %p with arg %f&quot;</span>,
                <a id='355' tid='356' class='m'>FUNCTION_ADDR</a>(<a id='357' tid='358' class='m'>target</a>), <span class='d'>dval0</span>);
            <a id='121' tid='122' class='m'>break</a>;
          <a id='183' tid='184' class='m'>case</a> <a id='185' tid='186' class='m'>ExternalReference</a><a id='187' tid='188' class='m'>::</a><a id='189' tid='190' class='m'>BUILTIN_FP_INT_CALL</a>:
            <a id='191' tid='192' class='m'>GetFpArgs</a>(<a id='193' tid='194' class='m'>&</a><a id='195' tid='196' class='m'>dval0</a>, <a id='197' tid='198' class='m'>&</a><a id='199' tid='200' class='m'>ival</a>);
            <a id='215' tid='216' class='m'>PrintF</a>(<span class='d'>&quot;Call to host function at %p with args %f, %d&quot;</span>,
                <a id='217' tid='218' class='m'>FUNCTION_ADDR</a>(<a id='219' tid='220' class='m'>target</a>), <span class='d'>dval0</span>, <span class='d'>ival</span>);
            <a id='123' tid='124' class='m'>break</a>;
          <a id='125' tid='126' class='m'>default</a>:
            <a id='127' tid='128' class='m'>UNREACHABLE</a>();
            <a id='129' tid='130' class='m'>break</a>;
        }
      }
      <span class='d'>double</span> <a id='605' tid='606' class='m'>result</a> = <a id='607' tid='608' class='m'>target</a>(<a id='609' tid='610' class='m'>arg0</a>, <a id='611' tid='612' class='m'>arg1</a>, <a id='613' tid='614' class='m'>arg2</a>, <a id='615' tid='616' class='m'>arg3</a>);
      <span class='d'>if</span> (<a id='803' tid='804' class='m'>redirection</a>-&gt;<a id='805' tid='806' class='m'>type</a>() <a id='807' tid='808' class='m'>!=</a> <a id='809' tid='810' class='m'>ExternalReference</a><a id='811' tid='812' class='m'>::</a><a id='813' tid='814' class='m'>BUILTIN_COMPARE_CALL</a>) <span class='d'>{
          SetFpResult(result);
      }</span> <span class='d'>else {
        int32_t gpreg_pair[2];
        memcpy(&gpreg_pair[0], &result, 2 * sizeof(int32_t));
        set_register(v0, gpreg_pair[0]);
        set_register(v1, gpreg_pair[1]);
      }</span>
    } <span class='d'>else</span> <a id='819' tid='820' class='m'>if</a> (<a id='821' tid='822' class='m'>redirection</a>-&gt;<a id='823' tid='824' class='m'>type</a>() <a id='825' tid='826' class='m'>==</a> <a id='827' tid='828' class='m'>ExternalReference</a><a id='829' tid='830' class='m'>::</a><a id='831' tid='832' class='m'>DIRECT_API_CALL</a>) {
      // See DirectCEntryStub::GenerateCall for explanation of register usage.
      <a id='871' tid='872' class='m'>SimulatorRuntimeDirectApiCall</a> <a id='873' tid='874' class='m'>target</a> =
                  <a id='875' tid='876' class='m'>reinterpret_cast</a>&lt;<a id='877' tid='878' class='m'>SimulatorRuntimeDirectApiCall</a>&gt;(<a id='879' tid='880' class='m'>external</a>);
      <a id='881' tid='882' class='m'>if</a> (<a id='965' tid='966' class='m'>::</a><a id='967' tid='968' class='m'>v8</a><a id='969' tid='970' class='m'>::</a><a id='971' tid='972' class='m'>internal</a><a id='973' tid='974' class='m'>::</a><a id='975' tid='976' class='m'>FLAG_trace_sim</a>) {
        <span class='d'>PrintF</span>(<span class='d'>&quot;Call to host function at %p args %08x\n&quot;</span>,
               <a id='883' tid='884' class='m'>FUNCTION_ADDR</a>(<a id='885' tid='886' class='m'>target</a>), <span class='d'>arg1</span>);
      }
      <a id='443' tid='444' class='m'>v8</a><a id='445' tid='446' class='m'>::</a><a id='447' tid='448' class='m'>Handle</a>&lt;<a id='449' tid='450' class='m'>v8</a><a id='451' tid='452' class='m'>::</a><a id='453' tid='454' class='m'>Value</a>&gt; <span class='d'>result = target(arg1)</span>;
      <span class='d'>*(reinterpret_cast&lt;int*&gt;(arg0)</span>) <span class='d'>=</span> <span class='d'>(int32_t)</span> <a id='537' tid='538' class='m'>*</a><a id='539' tid='540' class='m'>result</a>;
      <span class='d'>set_register(v0, arg0);</span>
    } <a id='833' tid='834' class='m'>else</a> <a id='835' tid='836' class='m'>if</a> (<a id='837' tid='838' class='m'>redirection</a>-&gt;<a id='839' tid='840' class='m'>type</a>() <a id='841' tid='842' class='m'>==</a> <a id='843' tid='844' class='m'>ExternalReference</a><a id='845' tid='846' class='m'>::</a><a id='847' tid='848' class='m'>DIRECT_GETTER_CALL</a>) {
      // See DirectCEntryStub::GenerateCall for explanation of register usage.
      <a id='849' tid='850' class='m'>SimulatorRuntimeDirectGetterCall</a> <a id='851' tid='852' class='m'>target</a> =
                  <a id='853' tid='854' class='m'>reinterpret_cast</a>&lt;<a id='855' tid='856' class='m'>SimulatorRuntimeDirectGetterCall</a>&gt;(<a id='857' tid='858' class='m'>external</a>);
      <a id='635' tid='636' class='m'>if</a> (<a id='637' tid='638' class='m'>::</a><a id='639' tid='640' class='m'>v8</a><a id='641' tid='642' class='m'>::</a><a id='643' tid='644' class='m'>internal</a><a id='645' tid='646' class='m'>::</a><a id='647' tid='648' class='m'>FLAG_trace_sim</a>) {
        <span class='d'>PrintF</span>(<span class='d'>&quot;Call to host function at %p args %08x %08x\n&quot;</span>,
               <a id='649' tid='650' class='m'>FUNCTION_ADDR</a>(<a id='651' tid='652' class='m'>target</a>), <span class='d'>arg1</span>, <span class='d'>arg2</span>);
      }
      <a id='541' tid='542' class='m'>v8</a><a id='543' tid='544' class='m'>::</a><a id='545' tid='546' class='m'>Handle</a>&lt;<a id='547' tid='548' class='m'>v8</a><a id='549' tid='550' class='m'>::</a><a id='551' tid='552' class='m'>Value</a>&gt; <span class='d'>result = target(arg1, arg2)</span>;
      <span class='d'>*(reinterpret_cast&lt;int*&gt;(arg0)</span>) <span class='d'>=</span> <span class='d'>(int32_t)</span> <a id='455' tid='456' class='m'>*</a><a id='457' tid='458' class='m'>result</a>;
      <span class='d'>set_register(v0, arg0);</span>
    } <a id='859' tid='860' class='m'>else</a> {
      <a id='861' tid='862' class='m'>SimulatorRuntimeCall</a> <a id='863' tid='864' class='m'>target</a> =
                  <a id='865' tid='866' class='m'>reinterpret_cast</a>&lt;<a id='867' tid='868' class='m'>SimulatorRuntimeCall</a>&gt;(<a id='869' tid='870' class='m'>external</a>);
      <span class='d'>if</span> (<a id='653' tid='654' class='m'>::</a><a id='655' tid='656' class='m'>v8</a><a id='657' tid='658' class='m'>::</a><a id='659' tid='660' class='m'>internal</a><a id='661' tid='662' class='m'>::</a><a id='663' tid='664' class='m'>FLAG_trace_sim</a>) {
        <a id='145' tid='146' class='m'>PrintF</a>(
            <span class='d'>&quot;Call to host function at %p &quot;
            &quot;args %08x, %08x, %08x, %08x, %08x, %08x\n&quot;</span>,
            <a id='147' tid='148' class='m'>FUNCTION_ADDR</a>(<a id='149' tid='150' class='m'>target</a>),
            <span class='d'>arg0</span>,
            <span class='d'>arg1</span>,
            <span class='d'>arg2</span>,
            <span class='d'>arg3</span>,
            <span class='d'>arg4</span>,
            <span class='d'>arg5</span>);
      }
      <a id='553' tid='554' class='m'>int64_t</a> <a id='555' tid='556' class='m'>result</a> = <a id='557' tid='558' class='m'>target</a>(<a id='559' tid='560' class='m'>arg0</a>, <a id='561' tid='562' class='m'>arg1</a>, <a id='563' tid='564' class='m'>arg2</a>, <a id='565' tid='566' class='m'>arg3</a>, <a id='567' tid='568' class='m'>arg4</a>, <a id='569' tid='570' class='m'>arg5</a>);
      <span class='d'>set_register</span>(<span class='d'>v0</span>, <a id='459' tid='460' class='m'>static_cast</a>&lt;<a id='461' tid='462' class='m'>int32_t</a>&gt;(<a id='463' tid='464' class='m'>result</a>));
      <span class='d'>set_register</span>(<span class='d'>v1</span>, <a id='359' tid='360' class='m'>static_cast</a>&lt;<a id='361' tid='362' class='m'>int32_t</a>&gt;<span class='d'>(result &gt;&gt; 32)</span>);
    }
    <span class='d'>if</span> (<a id='953' tid='954' class='m'>::</a><a id='955' tid='956' class='m'>v8</a><a id='957' tid='958' class='m'>::</a><a id='959' tid='960' class='m'>internal</a><a id='961' tid='962' class='m'>::</a><a id='963' tid='964' class='m'>FLAG_trace_sim</a>) <span class='d'>{
      PrintF(&quot;Returned %08x : %08x\n&quot;, get_register(v1), get_register(v0));
    }</span>
    <span class='d'>set_register(ra, saved_ra);</span>
    <span class='d'>set_pc(get_register(ra));</span>

  } <span class='d'>else</span> <span class='d'>if</span> <span class='d'>(func == BREAK && code &lt;= kMaxStopCode)</span> {
    <span class='d'>if</span> <span class='d'>(IsWatchpoint(code))</span> <span class='d'>{
      PrintWatchpoint(code);
    }</span> <span class='d'>else</span> {
      <a id='1251' tid='1252' class='m'>IncreaseStopCounter</a>(<a id='1253' tid='1254' class='m'>code</a>);
      <span class='d'>HandleStop(code, instr);</span>
    }
  } <span class='d'>else</span> {
    // All remaining break_ codes, and all traps are handled here.
    <span class='d'>MipsDebugger dbg(this)</span>;
    <a id='1273' tid='1274' class='m'>dbg</a>.<a id='1275' tid='1276' class='m'>Debug</a>();
  }
}


// Stop helper functions.
<span class='d'>bool Simulator::IsWatchpoint(uint32_t code) {
  return (code &lt;= kMaxWatchpointCode);
}</span>


<span class='d'>void Simulator::PrintWatchpoint(uint32_t code) {
  MipsDebugger dbg(this);
  ++break_count_;
  PrintF(&quot;\n---- break %d marker: %3d  (instr count: %8d) ----------&quot;
         &quot;----------------------------------&quot;,
         code, break_count_, icount_);
  dbg.PrintAllRegs();  // Print registers and continue running.
}</span>


<span class='d'>void</span> <span class='d'>Simulator::HandleStop</span><span class='d'>(uint32_t code, Instruction* instr)</span> {
  // Stop if it is enabled, otherwise go on jumping over the stop
  // and the message address.
  <span class='d'>if</span> <span class='d'>(IsEnabledStop(code))</span> <span class='d'>{
    MipsDebugger dbg(this);
    dbg.Stop(instr);
  }</span> <a id='935' tid='936' class='m'>else</a> {
    <a id='937' tid='938' class='m'>set_pc</a>(<a id='939' tid='940' class='m'>get_pc</a>() <a id='941' tid='942' class='m'>+</a> <a id='943' tid='944' class='m'>2</a> <a id='945' tid='946' class='m'>*</a> <a id='947' tid='948' class='m'>Instruction</a><a id='949' tid='950' class='m'>::</a><a id='951' tid='952' class='m'>kInstrSize</a>);
  }
}


<span class='d'>bool Simulator::IsStopInstruction(Instruction* instr) {
  int32_t func = instr-&gt;FunctionFieldRaw();
  uint32_t code = static_cast&lt;uint32_t&gt;(instr-&gt;Bits(25, 6));
  return (func == BREAK) && code &gt; kMaxWatchpointCode && code &lt;= kMaxStopCode;
}</span>


<span class='d'>bool</span> <span class='d'>Simulator::IsEnabledStop</span><span class='d'>(uint32_t code)</span> {
  <span class='d'>ASSERT(code &lt;= kMaxStopCode);</span>
  <span class='d'>ASSERT(code &gt; kMaxWatchpointCode);</span>
  <a id='1255' tid='1256' class='m'>return</a> <a id='1257' tid='1258' class='m'>!</a>(<a id='1259' tid='1260' class='m'>watched_stops</a>[<a id='1261' tid='1262' class='m'>code</a>].<a id='1263' tid='1264' class='m'>count</a> <a id='1265' tid='1266' class='m'>&</a> <a id='1267' tid='1268' class='m'>kStopDisabledBit</a>);
}


<a id='1165' tid='1166' class='m'>void</a> <a id='1167' tid='1168' class='m'>Simulator</a><a id='1169' tid='1170' class='m'>::</a><a id='1171' tid='1172' class='m'>EnableStop</a>(<a id='1173' tid='1174' class='m'>uint32_t</a> <a id='1175' tid='1176' class='m'>code</a>) {
  <span class='d'>if</span> <span class='d'>(!IsEnabledStop(code))</span> {
    <a id='1177' tid='1178' class='m'>watched_stops</a>[<a id='1179' tid='1180' class='m'>code</a>].<a id='1181' tid='1182' class='m'>count</a> <a id='1183' tid='1184' class='m'>&=</a> <a id='1185' tid='1186' class='m'>~</a><a id='1187' tid='1188' class='m'>kStopDisabledBit</a>;
  }
}


<a id='1127' tid='1128' class='m'>void</a> <a id='1129' tid='1130' class='m'>Simulator</a><a id='1131' tid='1132' class='m'>::</a><a id='1133' tid='1134' class='m'>DisableStop</a>(<a id='1135' tid='1136' class='m'>uint32_t</a> <a id='1137' tid='1138' class='m'>code</a>) {
  <span class='d'>if</span> <span class='d'>(IsEnabledStop(code))</span> {
    <a id='1139' tid='1140' class='m'>watched_stops</a>[<a id='1141' tid='1142' class='m'>code</a>].<a id='1143' tid='1144' class='m'>count</a> <a id='1145' tid='1146' class='m'>|=</a> <a id='1147' tid='1148' class='m'>kStopDisabledBit</a>;
  }
}


<a id='1087' tid='1088' class='m'>void</a> <a id='1089' tid='1090' class='m'>Simulator</a><a id='1091' tid='1092' class='m'>::</a><a id='1093' tid='1094' class='m'>IncreaseStopCounter</a>(<a id='1095' tid='1096' class='m'>uint32_t</a> <a id='1097' tid='1098' class='m'>code</a>) {
  <a id='1099' tid='1100' class='m'>ASSERT</a>(<a id='1101' tid='1102' class='m'>code</a> <a id='1103' tid='1104' class='m'>&lt;=</a> <a id='1105' tid='1106' class='m'>kMaxStopCode</a>);
  <a id='983' tid='984' class='m'>if</a> ((<a id='1067' tid='1068' class='m'>watched_stops</a>[<a id='1069' tid='1070' class='m'>code</a>].<a id='1071' tid='1072' class='m'>count</a> <a id='1073' tid='1074' class='m'>&</a> <a id='1075' tid='1076' class='m'>~</a>(<a id='1077' tid='1078' class='m'>1</a> <a id='1079' tid='1080' class='m'>&lt;&lt;</a> <a id='1081' tid='1082' class='m'>31</a>)) <a id='1083' tid='1084' class='m'>==</a> <a id='1085' tid='1086' class='m'>0x7fffffff</a>) {
    <a id='985' tid='986' class='m'>PrintF</a>(<a id='987' tid='988' class='m'>&quot;Stop counter for code %i has overflowed.\n&quot;</a>
           <a id='989' tid='990' class='m'>&quot;Enabling this code and reseting the counter to 0.\n&quot;</a>, <a id='991' tid='992' class='m'>code</a>);
    <a id='993' tid='994' class='m'>watched_stops</a>[<a id='995' tid='996' class='m'>code</a>].<a id='997' tid='998' class='m'>count</a> <a id='999' tid='1000' class='m'>=</a> <a id='1001' tid='1002' class='m'>0</a>;
    <a id='1003' tid='1004' class='m'>EnableStop</a>(<a id='1005' tid='1006' class='m'>code</a>);
  } <a id='1007' tid='1008' class='m'>else</a> {
    <a id='1009' tid='1010' class='m'>watched_stops</a>[<a id='1011' tid='1012' class='m'>code</a>].<a id='1013' tid='1014' class='m'>count</a><a id='1015' tid='1016' class='m'>++</a>;
  }
}


// Print a stop status.
<a id='1033' tid='1034' class='m'>void</a> <a id='1035' tid='1036' class='m'>Simulator</a><a id='1037' tid='1038' class='m'>::</a><a id='1039' tid='1040' class='m'>PrintStopInfo</a>(<a id='1041' tid='1042' class='m'>uint32_t</a> <a id='1043' tid='1044' class='m'>code</a>) {
  <span class='d'>if (code &lt;= kMaxWatchpointCode) {
    PrintF(&quot;That is a watchpoint, not a stop.\n&quot;);
    return;
  } else if (code &gt; kMaxStopCode) {
    PrintF(&quot;Code too large, only %u stops can be used\n&quot;, kMaxStopCode + 1);
    return;
  }</span>
  <span class='d'>const</span> <a id='1045' tid='1046' class='m'>char</a><a id='1047' tid='1048' class='m'>*</a> <span class='d'>state = IsEnabledStop(code) ? &quot;Enabled&quot; : &quot;Disabled&quot;</span>;
  <a id='1017' tid='1018' class='m'>int32_t</a> <a id='1019' tid='1020' class='m'>count</a> = <a id='1021' tid='1022' class='m'>watched_stops</a>[<a id='1023' tid='1024' class='m'>code</a>].<a id='1025' tid='1026' class='m'>count</a> <a id='1027' tid='1028' class='m'>&</a> <a id='1029' tid='1030' class='m'>~</a><a id='1031' tid='1032' class='m'>kStopDisabledBit</a>;
  // Don&#39;t print the state of unused breakpoints.
  <a id='887' tid='888' class='m'>if</a> (<a id='889' tid='890' class='m'>count</a> <a id='891' tid='892' class='m'>!=</a> <a id='893' tid='894' class='m'>0</a>) {
    <a id='895' tid='896' class='m'>if</a> (<a id='897' tid='898' class='m'>watched_stops</a>[<a id='899' tid='900' class='m'>code</a>].<a id='901' tid='902' class='m'>desc</a>) {
      <a id='903' tid='904' class='m'>PrintF</a>(<a id='905' tid='906' class='m'>&quot;stop %i - 0x%x: \t%s, \tcounter = %i, \t%s\n&quot;</a>,
             <a id='907' tid='908' class='m'>code</a>, <a id='909' tid='910' class='m'>code</a>, <a id='911' tid='912' class='m'>state</a>, <a id='913' tid='914' class='m'>count</a>, <a id='915' tid='916' class='m'>watched_stops</a>[<a id='917' tid='918' class='m'>code</a>].<a id='919' tid='920' class='m'>desc</a>);
    } <a id='921' tid='922' class='m'>else</a> {
      <a id='923' tid='924' class='m'>PrintF</a>(<a id='925' tid='926' class='m'>&quot;stop %i - 0x%x: \t%s, \tcounter = %i\n&quot;</a>,
             <a id='927' tid='928' class='m'>code</a>, <a id='929' tid='930' class='m'>code</a>, <a id='931' tid='932' class='m'>state</a>, <a id='933' tid='934' class='m'>count</a>);
    }
  }
}


<span class='d'>void Simulator::SignalExceptions() {
  for (int i = 1; i &lt; kNumExceptions; i++) {
    if (exceptions[i] != 0) {
      V8_Fatal(__FILE__, __LINE__, &quot;Error: Exception %i raised.&quot;, i);
    }
  }
}</span>


// Handle execution based on instruction types.

<span class='d'>void Simulator::ConfigureTypeRegister(Instruction* instr,
                                      int32_t& alu_out,
                                      int64_t& i64hilo,
                                      uint64_t& u64hilo,
                                      int32_t& next_pc,
                                      bool& do_interrupt) {
  // Every local variable declared here needs to be const.
  // This is to make sure that changed values are sent back to
  // DecodeTypeRegister correctly.

  // Instruction fields.
  const Opcode   op     = instr-&gt;OpcodeFieldRaw();
  const int32_t  rs_reg = instr-&gt;RsValue();
  const int32_t  rs     = get_register(rs_reg);
  const uint32_t rs_u   = static_cast&lt;uint32_t&gt;(rs);
  const int32_t  rt_reg = instr-&gt;RtValue();
  const int32_t  rt     = get_register(rt_reg);
  const uint32_t rt_u   = static_cast&lt;uint32_t&gt;(rt);
  const int32_t  rd_reg = instr-&gt;RdValue();
  const uint32_t sa     = instr-&gt;SaValue();

  const int32_t  fs_reg = instr-&gt;FsValue();


  // ---------- Configuration.
  switch (op) {
    case COP1:    // Coprocessor instructions.
      switch (instr-&gt;RsFieldRaw()) {
        case BC1:   // Handled in DecodeTypeImmed, should never come here.
          UNREACHABLE();
          break;
        case CFC1:
          // At the moment only FCSR is supported.
          ASSERT(fs_reg == kFCSRRegister);
          alu_out = FCSR_;
          break;
        case MFC1:
          alu_out = get_fpu_register(fs_reg);
          break;
        case MFHC1:
          UNIMPLEMENTED_MIPS();
          break;
        case CTC1:
        case MTC1:
        case MTHC1:
          // Do the store in the execution step.
          break;
        case S:
        case D:
        case W:
        case L:
        case PS:
          // Do everything in the execution step.
          break;
        default:
          UNIMPLEMENTED_MIPS();
      };
      break;
    case SPECIAL:
      switch (instr-&gt;FunctionFieldRaw()) {
        case JR:
        case JALR:
          next_pc = get_register(instr-&gt;RsValue());
          break;
        case SLL:
          alu_out = rt &lt;&lt; sa;
          break;
        case SRL:
          if (rs_reg == 0) {
            // Regular logical right shift of a word by a fixed number of
            // bits instruction. RS field is always equal to 0.
            alu_out = rt_u &gt;&gt; sa;
          } else {
            // Logical right-rotate of a word by a fixed number of bits. This
            // is special case of SRL instruction, added in MIPS32 Release 2.
            // RS field is equal to 00001.
            alu_out = (rt_u &gt;&gt; sa) | (rt_u &lt;&lt; (32 - sa));
          }
          break;
        case SRA:
          alu_out = rt &gt;&gt; sa;
          break;
        case SLLV:
          alu_out = rt &lt;&lt; rs;
          break;
        case SRLV:
          if (sa == 0) {
            // Regular logical right-shift of a word by a variable number of
            // bits instruction. SA field is always equal to 0.
            alu_out = rt_u &gt;&gt; rs;
          } else {
            // Logical right-rotate of a word by a variable number of bits.
            // This is special case od SRLV instruction, added in MIPS32
            // Release 2. SA field is equal to 00001.
            alu_out = (rt_u &gt;&gt; rs_u) | (rt_u &lt;&lt; (32 - rs_u));
          }
          break;
        case SRAV:
          alu_out = rt &gt;&gt; rs;
          break;
        case MFHI:
          alu_out = get_register(HI);
          break;
        case MFLO:
          alu_out = get_register(LO);
          break;
        case MULT:
          i64hilo = static_cast&lt;int64_t&gt;(rs) * static_cast&lt;int64_t&gt;(rt);
          break;
        case MULTU:
          u64hilo = static_cast&lt;uint64_t&gt;(rs_u) * static_cast&lt;uint64_t&gt;(rt_u);
          break;
        case ADD:
          if (HaveSameSign(rs, rt)) {
            if (rs &gt; 0) {
              exceptions[kIntegerOverflow] = rs &gt; (Registers::kMaxValue - rt);
            } else if (rs &lt; 0) {
              exceptions[kIntegerUnderflow] = rs &lt; (Registers::kMinValue - rt);
            }
          }
          alu_out = rs + rt;
          break;
        case ADDU:
          alu_out = rs + rt;
          break;
        case SUB:
          if (!HaveSameSign(rs, rt)) {
            if (rs &gt; 0) {
              exceptions[kIntegerOverflow] = rs &gt; (Registers::kMaxValue + rt);
            } else if (rs &lt; 0) {
              exceptions[kIntegerUnderflow] = rs &lt; (Registers::kMinValue + rt);
            }
          }
          alu_out = rs - rt;
          break;
        case SUBU:
          alu_out = rs - rt;
          break;
        case AND:
          alu_out = rs & rt;
          break;
        case OR:
          alu_out = rs | rt;
          break;
        case XOR:
          alu_out = rs ^ rt;
          break;
        case NOR:
          alu_out = ~(rs | rt);
          break;
        case SLT:
          alu_out = rs &lt; rt ? 1 : 0;
          break;
        case SLTU:
          alu_out = rs_u &lt; rt_u ? 1 : 0;
          break;
        // Break and trap instructions.
        case BREAK:

          do_interrupt = true;
          break;
        case TGE:
          do_interrupt = rs &gt;= rt;
          break;
        case TGEU:
          do_interrupt = rs_u &gt;= rt_u;
          break;
        case TLT:
          do_interrupt = rs &lt; rt;
          break;
        case TLTU:
          do_interrupt = rs_u &lt; rt_u;
          break;
        case TEQ:
          do_interrupt = rs == rt;
          break;
        case TNE:
          do_interrupt = rs != rt;
          break;
        case MOVN:
        case MOVZ:
        case MOVCI:
          // No action taken on decode.
          break;
        case DIV:
        case DIVU:
          // div and divu never raise exceptions.
          break;
        default:
          UNREACHABLE();
      };
      break;
    case SPECIAL2:
      switch (instr-&gt;FunctionFieldRaw()) {
        case MUL:
          alu_out = rs_u * rt_u;  // Only the lower 32 bits are kept.
          break;
        case CLZ:
          alu_out = __builtin_clz(rs_u);
          break;
        default:
          UNREACHABLE();
      };
      break;
    case SPECIAL3:
      switch (instr-&gt;FunctionFieldRaw()) {
        case INS: {   // Mips32r2 instruction.
          // Interpret rd field as 5-bit msb of insert.
          uint16_t msb = rd_reg;
          // Interpret sa field as 5-bit lsb of insert.
          uint16_t lsb = sa;
          uint16_t size = msb - lsb + 1;
          uint32_t mask = (1 &lt;&lt; size) - 1;
          alu_out = (rt_u & ~(mask &lt;&lt; lsb)) | ((rs_u & mask) &lt;&lt; lsb);
          break;
        }
        case EXT: {   // Mips32r2 instruction.
          // Interpret rd field as 5-bit msb of extract.
          uint16_t msb = rd_reg;
          // Interpret sa field as 5-bit lsb of extract.
          uint16_t lsb = sa;
          uint16_t size = msb + 1;
          uint32_t mask = (1 &lt;&lt; size) - 1;
          alu_out = (rs_u & (mask &lt;&lt; lsb)) &gt;&gt; lsb;
          break;
        }
        default:
          UNREACHABLE();
      };
      break;
    default:
      UNREACHABLE();
  };
}</span>


<span class='d'>void Simulator::DecodeTypeRegister(Instruction* instr) {
  // Instruction fields.
  const Opcode   op     = instr-&gt;OpcodeFieldRaw();
  const int32_t  rs_reg = instr-&gt;RsValue();
  const int32_t  rs     = get_register(rs_reg);
  const uint32_t rs_u   = static_cast&lt;uint32_t&gt;(rs);
  const int32_t  rt_reg = instr-&gt;RtValue();
  const int32_t  rt     = get_register(rt_reg);
  const uint32_t rt_u   = static_cast&lt;uint32_t&gt;(rt);
  const int32_t  rd_reg = instr-&gt;RdValue();

  const int32_t  fs_reg = instr-&gt;FsValue();
  const int32_t  ft_reg = instr-&gt;FtValue();
  const int32_t  fd_reg = instr-&gt;FdValue();
  int64_t  i64hilo = 0;
  uint64_t u64hilo = 0;

  // ALU output.
  // It should not be used as is. Instructions using it should always
  // initialize it first.
  int32_t alu_out = 0x12345678;

  // For break and trap instructions.
  bool do_interrupt = false;

  // For jr and jalr.
  // Get current pc.
  int32_t current_pc = get_pc();
  // Next pc
  int32_t next_pc = 0;

  // Setup the variables if needed before executing the instruction.
  ConfigureTypeRegister(instr,
                        alu_out,
                        i64hilo,
                        u64hilo,
                        next_pc,
                        do_interrupt);

  // ---------- Raise exceptions triggered.
  SignalExceptions();

  // ---------- Execution.
  switch (op) {
    case COP1:
      switch (instr-&gt;RsFieldRaw()) {
        case BC1:   // Branch on coprocessor condition.
          UNREACHABLE();
          break;
        case CFC1:
          set_register(rt_reg, alu_out);
        case MFC1:
          set_register(rt_reg, alu_out);
          break;
        case MFHC1:
          UNIMPLEMENTED_MIPS();
          break;
        case CTC1:
          // At the moment only FCSR is supported.
          ASSERT(fs_reg == kFCSRRegister);
          FCSR_ = registers_[rt_reg];
          break;
        case MTC1:
          FPUregisters_[fs_reg] = registers_[rt_reg];
          break;
        case MTHC1:
          UNIMPLEMENTED_MIPS();
          break;
        case S:
          float f;
          switch (instr-&gt;FunctionFieldRaw()) {
            case CVT_D_S:
              f = get_fpu_register_float(fs_reg);
              set_fpu_register_double(fd_reg, static_cast&lt;double&gt;(f));
              break;
            case CVT_W_S:
            case CVT_L_S:
            case TRUNC_W_S:
            case TRUNC_L_S:
            case ROUND_W_S:
            case ROUND_L_S:
            case FLOOR_W_S:
            case FLOOR_L_S:
            case CEIL_W_S:
            case CEIL_L_S:
            case CVT_PS_S:
              UNIMPLEMENTED_MIPS();
              break;
            default:
              UNREACHABLE();
          }
          break;
        case D:
          double ft, fs;
          uint32_t cc, fcsr_cc;
          int64_t  i64;
          fs = get_fpu_register_double(fs_reg);
          ft = get_fpu_register_double(ft_reg);
          cc = instr-&gt;FCccValue();
          fcsr_cc = get_fcsr_condition_bit(cc);
          switch (instr-&gt;FunctionFieldRaw()) {
            case ADD_D:
              set_fpu_register_double(fd_reg, fs + ft);
              break;
            case SUB_D:
              set_fpu_register_double(fd_reg, fs - ft);
              break;
            case MUL_D:
              set_fpu_register_double(fd_reg, fs * ft);
              break;
            case DIV_D:
              set_fpu_register_double(fd_reg, fs / ft);
              break;
            case ABS_D:
              set_fpu_register_double(fd_reg, fs &lt; 0 ? -fs : fs);
              break;
            case MOV_D:
              set_fpu_register_double(fd_reg, fs);
              break;
            case NEG_D:
              set_fpu_register_double(fd_reg, -fs);
              break;
            case SQRT_D:
              set_fpu_register_double(fd_reg, sqrt(fs));
              break;
            case C_UN_D:
              set_fcsr_bit(fcsr_cc, isnan(fs) || isnan(ft));
              break;
            case C_EQ_D:
              set_fcsr_bit(fcsr_cc, (fs == ft));
              break;
            case C_UEQ_D:
              set_fcsr_bit(fcsr_cc, (fs == ft) || (isnan(fs) || isnan(ft)));
              break;
            case C_OLT_D:
              set_fcsr_bit(fcsr_cc, (fs &lt; ft));
              break;
            case C_ULT_D:
              set_fcsr_bit(fcsr_cc, (fs &lt; ft) || (isnan(fs) || isnan(ft)));
              break;
            case C_OLE_D:
              set_fcsr_bit(fcsr_cc, (fs &lt;= ft));
              break;
            case C_ULE_D:
              set_fcsr_bit(fcsr_cc, (fs &lt;= ft) || (isnan(fs) || isnan(ft)));
              break;
            case CVT_W_D:   // Convert double to word.
              // Rounding modes are not yet supported.
              ASSERT((FCSR_ & 3) == 0);
              // In rounding mode 0 it should behave like ROUND.
            case ROUND_W_D:  // Round double to word.
              {
                double rounded = fs &gt; 0 ? floor(fs + 0.5) : ceil(fs - 0.5);
                int32_t result = static_cast&lt;int32_t&gt;(rounded);
                set_fpu_register(fd_reg, result);
                if (set_fcsr_round_error(fs, rounded)) {
                  set_fpu_register(fd_reg, kFPUInvalidResult);
                }
              }
              break;
            case TRUNC_W_D:  // Truncate double to word (round towards 0).
              {
                double rounded = trunc(fs);
                int32_t result = static_cast&lt;int32_t&gt;(rounded);
                set_fpu_register(fd_reg, result);
                if (set_fcsr_round_error(fs, rounded)) {
                  set_fpu_register(fd_reg, kFPUInvalidResult);
                }
              }
              break;
            case FLOOR_W_D:  // Round double to word towards negative infinity.
              {
                double rounded = floor(fs);
                int32_t result = static_cast&lt;int32_t&gt;(rounded);
                set_fpu_register(fd_reg, result);
                if (set_fcsr_round_error(fs, rounded)) {
                  set_fpu_register(fd_reg, kFPUInvalidResult);
                }
              }
              break;
            case CEIL_W_D:  // Round double to word towards positive infinity.
              {
                double rounded = ceil(fs);
                int32_t result = static_cast&lt;int32_t&gt;(rounded);
                set_fpu_register(fd_reg, result);
                if (set_fcsr_round_error(fs, rounded)) {
                  set_fpu_register(fd_reg, kFPUInvalidResult);
                }
              }
              break;
            case CVT_S_D:  // Convert double to float (single).
              set_fpu_register_float(fd_reg, static_cast&lt;float&gt;(fs));
              break;
            case CVT_L_D: {  // Mips32r2: Truncate double to 64-bit long-word.
              double rounded = trunc(fs);
              i64 = static_cast&lt;int64_t&gt;(rounded);
              set_fpu_register(fd_reg, i64 & 0xffffffff);
              set_fpu_register(fd_reg + 1, i64 &gt;&gt; 32);
              break;
            }
            case TRUNC_L_D: {  // Mips32r2 instruction.
              double rounded = trunc(fs);
              i64 = static_cast&lt;int64_t&gt;(rounded);
              set_fpu_register(fd_reg, i64 & 0xffffffff);
              set_fpu_register(fd_reg + 1, i64 &gt;&gt; 32);
              break;
            }
            case ROUND_L_D: {  // Mips32r2 instruction.
              double rounded = fs &gt; 0 ? floor(fs + 0.5) : ceil(fs - 0.5);
              i64 = static_cast&lt;int64_t&gt;(rounded);
              set_fpu_register(fd_reg, i64 & 0xffffffff);
              set_fpu_register(fd_reg + 1, i64 &gt;&gt; 32);
              break;
            }
            case FLOOR_L_D:  // Mips32r2 instruction.
              i64 = static_cast&lt;int64_t&gt;(floor(fs));
              set_fpu_register(fd_reg, i64 & 0xffffffff);
              set_fpu_register(fd_reg + 1, i64 &gt;&gt; 32);
              break;
            case CEIL_L_D:  // Mips32r2 instruction.
              i64 = static_cast&lt;int64_t&gt;(ceil(fs));
              set_fpu_register(fd_reg, i64 & 0xffffffff);
              set_fpu_register(fd_reg + 1, i64 &gt;&gt; 32);
              break;
            case C_F_D:
              UNIMPLEMENTED_MIPS();
              break;
            default:
              UNREACHABLE();
          }
          break;
        case W:
          switch (instr-&gt;FunctionFieldRaw()) {
            case CVT_S_W:   // Convert word to float (single).
              alu_out = get_fpu_register(fs_reg);
              set_fpu_register_float(fd_reg, static_cast&lt;float&gt;(alu_out));
              break;
            case CVT_D_W:   // Convert word to double.
              alu_out = get_fpu_register(fs_reg);
              set_fpu_register_double(fd_reg, static_cast&lt;double&gt;(alu_out));
              break;
            default:
              UNREACHABLE();
          };
          break;
        case L:
          switch (instr-&gt;FunctionFieldRaw()) {
          case CVT_D_L:  // Mips32r2 instruction.
            // Watch the signs here, we want 2 32-bit vals
            // to make a sign-64.
            i64 = (uint32_t) get_fpu_register(fs_reg);
            i64 |= ((int64_t) get_fpu_register(fs_reg + 1) &lt;&lt; 32);
            set_fpu_register_double(fd_reg, static_cast&lt;double&gt;(i64));
            break;
            case CVT_S_L:
              UNIMPLEMENTED_MIPS();
              break;
            default:
              UNREACHABLE();
          }
          break;
        case PS:
          break;
        default:
          UNREACHABLE();
      };
      break;
    case SPECIAL:
      switch (instr-&gt;FunctionFieldRaw()) {
        case JR: {
          Instruction* branch_delay_instr = reinterpret_cast&lt;Instruction*&gt;(
              current_pc+Instruction::kInstrSize);
          BranchDelayInstructionDecode(branch_delay_instr);
          set_pc(next_pc);
          pc_modified_ = true;
          break;
        }
        case JALR: {
          Instruction* branch_delay_instr = reinterpret_cast&lt;Instruction*&gt;(
              current_pc+Instruction::kInstrSize);
          BranchDelayInstructionDecode(branch_delay_instr);
          set_register(31, current_pc + 2 * Instruction::kInstrSize);
          set_pc(next_pc);
          pc_modified_ = true;
          break;
        }
        // Instructions using HI and LO registers.
        case MULT:
          set_register(LO, static_cast&lt;int32_t&gt;(i64hilo & 0xffffffff));
          set_register(HI, static_cast&lt;int32_t&gt;(i64hilo &gt;&gt; 32));
          break;
        case MULTU:
          set_register(LO, static_cast&lt;int32_t&gt;(u64hilo & 0xffffffff));
          set_register(HI, static_cast&lt;int32_t&gt;(u64hilo &gt;&gt; 32));
          break;
        case DIV:
          // Divide by zero was not checked in the configuration step - div and
          // divu do not raise exceptions. On division by 0, the result will
          // be UNPREDICTABLE.
          if (rt != 0) {
            set_register(LO, rs / rt);
            set_register(HI, rs % rt);
          }
          break;
        case DIVU:
          if (rt_u != 0) {
            set_register(LO, rs_u / rt_u);
            set_register(HI, rs_u % rt_u);
          }
          break;
        // Break and trap instructions.
        case BREAK:
        case TGE:
        case TGEU:
        case TLT:
        case TLTU:
        case TEQ:
        case TNE:
          if (do_interrupt) {
            SoftwareInterrupt(instr);
          }
          break;
        // Conditional moves.
        case MOVN:
          if (rt) set_register(rd_reg, rs);
          break;
        case MOVCI: {
          uint32_t cc = instr-&gt;FBccValue();
          uint32_t fcsr_cc = get_fcsr_condition_bit(cc);
          if (instr-&gt;Bit(16)) {  // Read Tf bit.
            if (test_fcsr_bit(fcsr_cc)) set_register(rd_reg, rs);
          } else {
            if (!test_fcsr_bit(fcsr_cc)) set_register(rd_reg, rs);
          }
          break;
        }
        case MOVZ:
          if (!rt) set_register(rd_reg, rs);
          break;
        default:  // For other special opcodes we do the default operation.
          set_register(rd_reg, alu_out);
      };
      break;
    case SPECIAL2:
      switch (instr-&gt;FunctionFieldRaw()) {
        case MUL:
          set_register(rd_reg, alu_out);
          // HI and LO are UNPREDICTABLE after the operation.
          set_register(LO, Unpredictable);
          set_register(HI, Unpredictable);
          break;
        default:  // For other special2 opcodes we do the default operation.
          set_register(rd_reg, alu_out);
      }
      break;
    case SPECIAL3:
      switch (instr-&gt;FunctionFieldRaw()) {
        case INS:
          // Ins instr leaves result in Rt, rather than Rd.
          set_register(rt_reg, alu_out);
          break;
        case EXT:
          // Ext instr leaves result in Rt, rather than Rd.
          set_register(rt_reg, alu_out);
          break;
        default:
          UNREACHABLE();
      };
      break;
    // Unimplemented opcodes raised an error in the configuration step before,
    // so we can use the default here to set the destination register in common
    // cases.
    default:
      set_register(rd_reg, alu_out);
  };
}</span>


// Type 2: instructions using a 16 bytes immediate. (eg: addi, beq).
<span class='d'>void Simulator::DecodeTypeImmediate(Instruction* instr) {
  // Instruction fields.
  Opcode   op     = instr-&gt;OpcodeFieldRaw();
  int32_t  rs     = get_register(instr-&gt;RsValue());
  uint32_t rs_u   = static_cast&lt;uint32_t&gt;(rs);
  int32_t  rt_reg = instr-&gt;RtValue();  // Destination register.
  int32_t  rt     = get_register(rt_reg);
  int16_t  imm16  = instr-&gt;Imm16Value();

  int32_t  ft_reg = instr-&gt;FtValue();  // Destination register.

  // Zero extended immediate.
  uint32_t  oe_imm16 = 0xffff & imm16;
  // Sign extended immediate.
  int32_t   se_imm16 = imm16;

  // Get current pc.
  int32_t current_pc = get_pc();
  // Next pc.
  int32_t next_pc = bad_ra;

  // Used for conditional branch instructions.
  bool do_branch = false;
  bool execute_branch_delay_instruction = false;

  // Used for arithmetic instructions.
  int32_t alu_out = 0;
  // Floating point.
  double fp_out = 0.0;
  uint32_t cc, cc_value, fcsr_cc;

  // Used for memory instructions.
  int32_t addr = 0x0;
  // Value to be written in memory.
  uint32_t mem_value = 0x0;

  // ---------- Configuration (and execution for REGIMM).
  switch (op) {
    // ------------- COP1. Coprocessor instructions.
    case COP1:
      switch (instr-&gt;RsFieldRaw()) {
        case BC1:   // Branch on coprocessor condition.
          cc = instr-&gt;FBccValue();
          fcsr_cc = get_fcsr_condition_bit(cc);
          cc_value = test_fcsr_bit(fcsr_cc);
          do_branch = (instr-&gt;FBtrueValue()) ? cc_value : !cc_value;
          execute_branch_delay_instruction = true;
          // Set next_pc.
          if (do_branch) {
            next_pc = current_pc + (imm16 &lt;&lt; 2) + Instruction::kInstrSize;
          } else {
            next_pc = current_pc + kBranchReturnOffset;
          }
          break;
        default:
          UNREACHABLE();
      };
      break;
    // ------------- REGIMM class.
    case REGIMM:
      switch (instr-&gt;RtFieldRaw()) {
        case BLTZ:
          do_branch = (rs  &lt; 0);
          break;
        case BLTZAL:
          do_branch = rs  &lt; 0;
          break;
        case BGEZ:
          do_branch = rs &gt;= 0;
          break;
        case BGEZAL:
          do_branch = rs &gt;= 0;
          break;
        default:
          UNREACHABLE();
      };
      switch (instr-&gt;RtFieldRaw()) {
        case BLTZ:
        case BLTZAL:
        case BGEZ:
        case BGEZAL:
          // Branch instructions common part.
          execute_branch_delay_instruction = true;
          // Set next_pc.
          if (do_branch) {
            next_pc = current_pc + (imm16 &lt;&lt; 2) + Instruction::kInstrSize;
            if (instr-&gt;IsLinkingInstruction()) {
              set_register(31, current_pc + kBranchReturnOffset);
            }
          } else {
            next_pc = current_pc + kBranchReturnOffset;
          }
        default:
          break;
        };
    break;  // case REGIMM.
    // ------------- Branch instructions.
    // When comparing to zero, the encoding of rt field is always 0, so we don&#39;t
    // need to replace rt with zero.
    case BEQ:
      do_branch = (rs == rt);
      break;
    case BNE:
      do_branch = rs != rt;
      break;
    case BLEZ:
      do_branch = rs &lt;= 0;
      break;
    case BGTZ:
      do_branch = rs  &gt; 0;
      break;
    // ------------- Arithmetic instructions.
    case ADDI:
      if (HaveSameSign(rs, se_imm16)) {
        if (rs &gt; 0) {
          exceptions[kIntegerOverflow] = rs &gt; (Registers::kMaxValue - se_imm16);
        } else if (rs &lt; 0) {
          exceptions[kIntegerUnderflow] =
              rs &lt; (Registers::kMinValue - se_imm16);
        }
      }
      alu_out = rs + se_imm16;
      break;
    case ADDIU:
      alu_out = rs + se_imm16;
      break;
    case SLTI:
      alu_out = (rs &lt; se_imm16) ? 1 : 0;
      break;
    case SLTIU:
      alu_out = (rs_u &lt; static_cast&lt;uint32_t&gt;(se_imm16)) ? 1 : 0;
      break;
    case ANDI:
        alu_out = rs & oe_imm16;
      break;
    case ORI:
        alu_out = rs | oe_imm16;
      break;
    case XORI:
        alu_out = rs ^ oe_imm16;
      break;
    case LUI:
        alu_out = (oe_imm16 &lt;&lt; 16);
      break;
    // ------------- Memory instructions.
    case LB:
      addr = rs + se_imm16;
      alu_out = ReadB(addr);
      break;
    case LH:
      addr = rs + se_imm16;
      alu_out = ReadH(addr, instr);
      break;
    case LWL: {
      // al_offset is offset of the effective address within an aligned word.
      uint8_t al_offset = (rs + se_imm16) & kPointerAlignmentMask;
      uint8_t byte_shift = kPointerAlignmentMask - al_offset;
      uint32_t mask = (1 &lt;&lt; byte_shift * 8) - 1;
      addr = rs + se_imm16 - al_offset;
      alu_out = ReadW(addr, instr);
      alu_out &lt;&lt;= byte_shift * 8;
      alu_out |= rt & mask;
      break;
    }
    case LW:
      addr = rs + se_imm16;
      alu_out = ReadW(addr, instr);
      break;
    case LBU:
      addr = rs + se_imm16;
      alu_out = ReadBU(addr);
      break;
    case LHU:
      addr = rs + se_imm16;
      alu_out = ReadHU(addr, instr);
      break;
    case LWR: {
      // al_offset is offset of the effective address within an aligned word.
      uint8_t al_offset = (rs + se_imm16) & kPointerAlignmentMask;
      uint8_t byte_shift = kPointerAlignmentMask - al_offset;
      uint32_t mask = al_offset ? (~0 &lt;&lt; (byte_shift + 1) * 8) : 0;
      addr = rs + se_imm16 - al_offset;
      alu_out = ReadW(addr, instr);
      alu_out = static_cast&lt;uint32_t&gt; (alu_out) &gt;&gt; al_offset * 8;
      alu_out |= rt & mask;
      break;
    }
    case SB:
      addr = rs + se_imm16;
      break;
    case SH:
      addr = rs + se_imm16;
      break;
    case SWL: {
      uint8_t al_offset = (rs + se_imm16) & kPointerAlignmentMask;
      uint8_t byte_shift = kPointerAlignmentMask - al_offset;
      uint32_t mask = byte_shift ? (~0 &lt;&lt; (al_offset + 1) * 8) : 0;
      addr = rs + se_imm16 - al_offset;
      mem_value = ReadW(addr, instr) & mask;
      mem_value |= static_cast&lt;uint32_t&gt;(rt) &gt;&gt; byte_shift * 8;
      break;
    }
    case SW:
      addr = rs + se_imm16;
      break;
    case SWR: {
      uint8_t al_offset = (rs + se_imm16) & kPointerAlignmentMask;
      uint32_t mask = (1 &lt;&lt; al_offset * 8) - 1;
      addr = rs + se_imm16 - al_offset;
      mem_value = ReadW(addr, instr);
      mem_value = (rt &lt;&lt; al_offset * 8) | (mem_value & mask);
      break;
    }
    case LWC1:
      addr = rs + se_imm16;
      alu_out = ReadW(addr, instr);
      break;
    case LDC1:
      addr = rs + se_imm16;
      fp_out = ReadD(addr, instr);
      break;
    case SWC1:
    case SDC1:
      addr = rs + se_imm16;
      break;
    default:
      UNREACHABLE();
  };

  // ---------- Raise exceptions triggered.
  SignalExceptions();

  // ---------- Execution.
  switch (op) {
    // ------------- Branch instructions.
    case BEQ:
    case BNE:
    case BLEZ:
    case BGTZ:
      // Branch instructions common part.
      execute_branch_delay_instruction = true;
      // Set next_pc.
      if (do_branch) {
        next_pc = current_pc + (imm16 &lt;&lt; 2) + Instruction::kInstrSize;
        if (instr-&gt;IsLinkingInstruction()) {
          set_register(31, current_pc + 2* Instruction::kInstrSize);
        }
      } else {
        next_pc = current_pc + 2 * Instruction::kInstrSize;
      }
      break;
    // ------------- Arithmetic instructions.
    case ADDI:
    case ADDIU:
    case SLTI:
    case SLTIU:
    case ANDI:
    case ORI:
    case XORI:
    case LUI:
      set_register(rt_reg, alu_out);
      break;
    // ------------- Memory instructions.
    case LB:
    case LH:
    case LWL:
    case LW:
    case LBU:
    case LHU:
    case LWR:
      set_register(rt_reg, alu_out);
      break;
    case SB:
      WriteB(addr, static_cast&lt;int8_t&gt;(rt));
      break;
    case SH:
      WriteH(addr, static_cast&lt;uint16_t&gt;(rt), instr);
      break;
    case SWL:
      WriteW(addr, mem_value, instr);
      break;
    case SW:
      WriteW(addr, rt, instr);
      break;
    case SWR:
      WriteW(addr, mem_value, instr);
      break;
    case LWC1:
      set_fpu_register(ft_reg, alu_out);
      break;
    case LDC1:
      set_fpu_register_double(ft_reg, fp_out);
      break;
    case SWC1:
      addr = rs + se_imm16;
      WriteW(addr, get_fpu_register(ft_reg), instr);
      break;
    case SDC1:
      addr = rs + se_imm16;
      WriteD(addr, get_fpu_register_double(ft_reg), instr);
      break;
    default:
      break;
  };


  if (execute_branch_delay_instruction) {
    // Execute branch delay slot
    // We don&#39;t check for end_sim_pc. First it should not be met as the current
    // pc is valid. Secondly a jump should always execute its branch delay slot.
    Instruction* branch_delay_instr =
      reinterpret_cast&lt;Instruction*&gt;(current_pc+Instruction::kInstrSize);
    BranchDelayInstructionDecode(branch_delay_instr);
  }

  // If needed update pc after the branch delay execution.
  if (next_pc != bad_ra) {
    set_pc(next_pc);
  }
}</span>


// Type 3: instructions using a 26 bytes immediate. (eg: j, jal).
<span class='d'>void Simulator::DecodeTypeJump(Instruction* instr) {
  // Get current pc.
  int32_t current_pc = get_pc();
  // Get unchanged bits of pc.
  int32_t pc_high_bits = current_pc & 0xf0000000;
  // Next pc.
  int32_t next_pc = pc_high_bits | (instr-&gt;Imm26Value() &lt;&lt; 2);

  // Execute branch delay slot.
  // We don&#39;t check for end_sim_pc. First it should not be met as the current pc
  // is valid. Secondly a jump should always execute its branch delay slot.
  Instruction* branch_delay_instr =
      reinterpret_cast&lt;Instruction*&gt;(current_pc + Instruction::kInstrSize);
  BranchDelayInstructionDecode(branch_delay_instr);

  // Update pc and ra if necessary.
  // Do this after the branch delay execution.
  if (instr-&gt;IsLinkingInstruction()) {
    set_register(31, current_pc + 2 * Instruction::kInstrSize);
  }
  set_pc(next_pc);
  pc_modified_ = true;
}</span>


// Executes the current instruction.
<span class='d'>void</span> <a id='347' tid='348' class='m'>Simulator</a><a id='349' tid='350' class='m'>::</a><a id='351' tid='352' class='m'>InstructionDecode</a><span class='d'>(Instruction* instr)</span> {
  <a id='221' tid='222' class='m'>if</a> (<a id='223' tid='224' class='m'>v8</a><a id='225' tid='226' class='m'>::</a><a id='227' tid='228' class='m'>internal</a><a id='229' tid='230' class='m'>::</a><a id='231' tid='232' class='m'>FLAG_check_icache</a>) {
    <a id='233' tid='234' class='m'>CheckICache</a>(<a id='235' tid='236' class='m'>isolate_</a>-&gt;<a id='237' tid='238' class='m'>simulator_i_cache</a>(), <a id='239' tid='240' class='m'>instr</a>);
  }
  <a id='201' tid='202' class='m'>pc_modified_</a> <a id='203' tid='204' class='m'>=</a> <a id='205' tid='206' class='m'>false</a>;
  <a id='241' tid='242' class='m'>if</a> (<a id='327' tid='328' class='m'>::</a><a id='329' tid='330' class='m'>v8</a><a id='331' tid='332' class='m'>::</a><a id='333' tid='334' class='m'>internal</a><a id='335' tid='336' class='m'>::</a><a id='337' tid='338' class='m'>FLAG_trace_sim</a>) {
    <a id='253' tid='254' class='m'>disasm</a><a id='255' tid='256' class='m'>::</a><a id='257' tid='258' class='m'>NameConverter</a> <a id='259' tid='260' class='m'>converter</a>;
    <a id='243' tid='244' class='m'>disasm</a><a id='245' tid='246' class='m'>::</a><a id='247' tid='248' class='m'>Disassembler</a> <a id='249' tid='250' class='m'>dasm</a>(<a id='251' tid='252' class='m'>converter</a>);
    // Use a reasonably large buffer.
    <a id='261' tid='262' class='m'>v8</a><a id='263' tid='264' class='m'>::</a><a id='265' tid='266' class='m'>internal</a><a id='267' tid='268' class='m'>::</a><a id='269' tid='270' class='m'>EmbeddedVector</a>&lt;<a id='271' tid='272' class='m'>char</a>, <a id='273' tid='274' class='m'>256</a>&gt; <a id='275' tid='276' class='m'>buffer</a>;
    <a id='277' tid='278' class='m'>dasm</a>.<a id='279' tid='280' class='m'>InstructionDecode</a>(<a id='281' tid='282' class='m'>buffer</a>, <a id='283' tid='284' class='m'>reinterpret_cast</a>&lt;<a id='285' tid='286' class='m'>byte</a><a id='287' tid='288' class='m'>*</a>&gt;(<a id='289' tid='290' class='m'>instr</a>));
    <a id='291' tid='292' class='m'>PrintF</a>(<a id='293' tid='294' class='m'>&quot;  0x%08x  %s\n&quot;</a>, <a id='295' tid='296' class='m'>reinterpret_cast</a>&lt;<a id='297' tid='298' class='m'>intptr_t</a>&gt;(<a id='299' tid='300' class='m'>instr</a>),
        <a id='301' tid='302' class='m'>buffer</a>.<a id='303' tid='304' class='m'>start</a>());
  }

  <span class='d'>switch (instr-&gt;InstructionType()) {
    case Instruction::kRegisterType:
      DecodeTypeRegister(instr);
      break;
    case Instruction::kImmediateType:
      DecodeTypeImmediate(instr);
      break;
    case Instruction::kJumpType:
      DecodeTypeJump(instr);
      break;
    default:
      UNSUPPORTED();
  }</span>
  <a id='151' tid='152' class='m'>if</a> (<a id='153' tid='154' class='m'>!</a><a id='155' tid='156' class='m'>pc_modified_</a>) {
    <a id='157' tid='158' class='m'>set_register</a>(<a id='159' tid='160' class='m'>pc</a>, <a id='161' tid='162' class='m'>reinterpret_cast</a>&lt;<a id='163' tid='164' class='m'>int32_t</a>&gt;(<a id='165' tid='166' class='m'>instr</a>) <a id='167' tid='168' class='m'>+</a>
                 <a id='169' tid='170' class='m'>Instruction</a><a id='171' tid='172' class='m'>::</a><a id='173' tid='174' class='m'>kInstrSize</a>);
  }
}



<a id='665' tid='666' class='m'>void</a> <a id='667' tid='668' class='m'>Simulator</a><a id='669' tid='670' class='m'>::</a><a id='671' tid='672' class='m'>Execute</a>() {
  // Get the PC to simulate. Cannot use the accessor here as we need the
  // raw PC value and not the one used as input to arithmetic instructions.
  <a id='673' tid='674' class='m'>int</a> <a id='675' tid='676' class='m'>program_counter</a> = <a id='677' tid='678' class='m'>get_pc</a>();
  <a id='679' tid='680' class='m'>if</a> (<a id='681' tid='682' class='m'>::</a><a id='683' tid='684' class='m'>v8</a><a id='685' tid='686' class='m'>::</a><a id='687' tid='688' class='m'>internal</a><a id='689' tid='690' class='m'>::</a><a id='691' tid='692' class='m'>FLAG_stop_sim_at</a> <a id='693' tid='694' class='m'>==</a> <a id='695' tid='696' class='m'>0</a>) {
    // Fast version of the dispatch loop without checking whether the simulator
    // should be stopping at a particular executed instruction.
    <a id='697' tid='698' class='m'>while</a> (<a id='699' tid='700' class='m'>program_counter</a> <a id='701' tid='702' class='m'>!=</a> <a id='703' tid='704' class='m'>end_sim_pc</a>) {
      <a id='705' tid='706' class='m'>Instruction</a><a id='707' tid='708' class='m'>*</a> <a id='709' tid='710' class='m'>instr</a> = <a id='711' tid='712' class='m'>reinterpret_cast</a>&lt;<a id='713' tid='714' class='m'>Instruction</a><a id='715' tid='716' class='m'>*</a>&gt;(<a id='717' tid='718' class='m'>program_counter</a>);
      <a id='719' tid='720' class='m'>icount_</a><a id='721' tid='722' class='m'>++</a>;
      <a id='723' tid='724' class='m'>InstructionDecode</a>(<a id='725' tid='726' class='m'>instr</a>);
      <a id='727' tid='728' class='m'>program_counter</a> <a id='729' tid='730' class='m'>=</a> <a id='731' tid='732' class='m'>get_pc</a>();
    }
  } <a id='733' tid='734' class='m'>else</a> {
    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
    // we reach the particular instuction count.
    <a id='735' tid='736' class='m'>while</a> (<a id='737' tid='738' class='m'>program_counter</a> <a id='739' tid='740' class='m'>!=</a> <a id='741' tid='742' class='m'>end_sim_pc</a>) {
      <a id='743' tid='744' class='m'>Instruction</a><a id='745' tid='746' class='m'>*</a> <a id='747' tid='748' class='m'>instr</a> = <a id='749' tid='750' class='m'>reinterpret_cast</a>&lt;<a id='751' tid='752' class='m'>Instruction</a><a id='753' tid='754' class='m'>*</a>&gt;(<a id='755' tid='756' class='m'>program_counter</a>);
      <a id='757' tid='758' class='m'>icount_</a><a id='759' tid='760' class='m'>++</a>;
      <a id='761' tid='762' class='m'>if</a> (<a id='763' tid='764' class='m'>icount_</a> <a id='765' tid='766' class='m'>==</a> <a id='767' tid='768' class='m'>::</a><a id='769' tid='770' class='m'>v8</a><a id='771' tid='772' class='m'>::</a><a id='773' tid='774' class='m'>internal</a><a id='775' tid='776' class='m'>::</a><a id='777' tid='778' class='m'>FLAG_stop_sim_at</a>) {
        <span class='d'>MipsDebugger dbg(this)</span>;
        <a id='779' tid='780' class='m'>dbg</a>.<a id='781' tid='782' class='m'>Debug</a>();
      } <a id='783' tid='784' class='m'>else</a> {
        <a id='785' tid='786' class='m'>InstructionDecode</a>(<a id='787' tid='788' class='m'>instr</a>);
      }
      <a id='789' tid='790' class='m'>program_counter</a> <a id='791' tid='792' class='m'>=</a> <a id='793' tid='794' class='m'>get_pc</a>();
    }
  }
}


<a id='577' tid='578' class='m'>int32_t</a> <a id='579' tid='580' class='m'>Simulator</a><a id='581' tid='582' class='m'>::</a><a id='583' tid='584' class='m'>Call</a>(<a id='585' tid='586' class='m'>byte</a><a id='587' tid='588' class='m'>*</a> <a id='589' tid='590' class='m'>entry</a>, <a id='591' tid='592' class='m'>int</a> <a id='593' tid='594' class='m'>argument_count</a>, <a id='595' tid='596' class='m'>...</a>) {
  <a id='597' tid='598' class='m'>va_list</a> <a id='599' tid='600' class='m'>parameters</a>;
  <a id='571' tid='572' class='m'>va_start</a>(<a id='573' tid='574' class='m'>parameters</a>, <a id='575' tid='576' class='m'>argument_count</a>);
  // Setup arguments.

  // First four arguments passed in registers.
  <a id='465' tid='466' class='m'>ASSERT</a>(<a id='467' tid='468' class='m'>argument_count</a> <a id='469' tid='470' class='m'>&gt;=</a> <a id='471' tid='472' class='m'>4</a>);
  <a id='363' tid='364' class='m'>set_register</a>(<span class='d'>a0</span>, <a id='365' tid='366' class='m'>va_arg</a>(<a id='367' tid='368' class='m'>parameters</a>, <a id='369' tid='370' class='m'>int32_t</a>));
  <a id='339' tid='340' class='m'>set_register</a>(<span class='d'>a1</span>, <a id='341' tid='342' class='m'>va_arg</a>(<a id='343' tid='344' class='m'>parameters</a>, <a id='345' tid='346' class='m'>int32_t</a>));
  <a id='305' tid='306' class='m'>set_register</a>(<span class='d'>a2</span>, <a id='307' tid='308' class='m'>va_arg</a>(<a id='309' tid='310' class='m'>parameters</a>, <a id='311' tid='312' class='m'>int32_t</a>));
  <a id='207' tid='208' class='m'>set_register</a>(<span class='d'>a3</span>, <a id='209' tid='210' class='m'>va_arg</a>(<a id='211' tid='212' class='m'>parameters</a>, <a id='213' tid='214' class='m'>int32_t</a>));

  // Remaining arguments passed on stack.
  <a id='175' tid='176' class='m'>int</a> <a id='177' tid='178' class='m'>original_stack</a> = <a id='179' tid='180' class='m'>get_register</a>(<a id='181' tid='182' class='m'>sp</a>);
  // Compute position of stack on entry to generated code.
  <a id='131' tid='132' class='m'>int</a> <a id='133' tid='134' class='m'>entry_stack</a> = (<a id='135' tid='136' class='m'>original_stack</a> <a id='137' tid='138' class='m'>-</a> (<a id='139' tid='140' class='m'>argument_count</a> <a id='141' tid='142' class='m'>-</a> <a id='143' tid='144' class='m'>4</a>) <span class='d'>*</span> <span class='d'>sizeof(int32_t)
                                    - kCArgsSlotsSize</span>);
  <a id='93' tid='94' class='m'>if</a> (<a id='95' tid='96' class='m'>OS</a><a id='97' tid='98' class='m'>::</a><a id='99' tid='100' class='m'>ActivationFrameAlignment</a>() <a id='101' tid='102' class='m'>!=</a> <a id='103' tid='104' class='m'>0</a>) {
    <a id='105' tid='106' class='m'>entry_stack</a> <a id='107' tid='108' class='m'>&=</a> <a id='109' tid='110' class='m'>-</a><a id='111' tid='112' class='m'>OS</a><a id='113' tid='114' class='m'>::</a><a id='115' tid='116' class='m'>ActivationFrameAlignment</a>();
  }
  // Store remaining arguments on stack, from low to high memory.
  <a id='79' tid='80' class='m'>intptr_t</a><a id='81' tid='82' class='m'>*</a> <a id='83' tid='84' class='m'>stack_argument</a> = <a id='85' tid='86' class='m'>reinterpret_cast</a>&lt;<a id='87' tid='88' class='m'>intptr_t</a><a id='89' tid='90' class='m'>*</a>&gt;(<a id='91' tid='92' class='m'>entry_stack</a>);
  <a id='45' tid='46' class='m'>for</a> (<a id='47' tid='48' class='m'>int</a> <a id='49' tid='50' class='m'>i</a> = <a id='51' tid='52' class='m'>4</a>; <a id='53' tid='54' class='m'>i</a> <a id='55' tid='56' class='m'>&lt;</a> <a id='57' tid='58' class='m'>argument_count</a>; <a id='59' tid='60' class='m'>i</a><a id='61' tid='62' class='m'>++</a>) {
    <a id='63' tid='64' class='m'>stack_argument</a>[<a id='65' tid='66' class='m'>i</a> <a id='67' tid='68' class='m'>-</a> <a id='69' tid='70' class='m'>4</a> <span class='d'>+</span> <span class='d'>kArgsSlotsNum</span>] <a id='71' tid='72' class='m'>=</a> <a id='73' tid='74' class='m'>va_arg</a>(<a id='75' tid='76' class='m'>parameters</a>, <a id='77' tid='78' class='m'>int32_t</a>);
  }
  <a id='41' tid='42' class='m'>va_end</a>(<a id='43' tid='44' class='m'>parameters</a>);
  <a id='35' tid='36' class='m'>set_register</a>(<a id='37' tid='38' class='m'>sp</a>, <a id='39' tid='40' class='m'>entry_stack</a>);

  // Prepare to execute the code at entry.
  <a id='25' tid='26' class='m'>set_register</a>(<a id='27' tid='28' class='m'>pc</a>, <a id='29' tid='30' class='m'>reinterpret_cast</a>&lt;<a id='31' tid='32' class='m'>int32_t</a>&gt;(<a id='33' tid='34' class='m'>entry</a>));
  // Put down marker for end of simulation. The simulator will stop simulation
  // when the PC reaches this value. By saving the &quot;end simulation&quot; value into
  // the LR the simulation stops when returning to this call point.
  <span class='d'>set_register(ra, end_sim_pc);</span>

  // Remember the values of callee-saved registers.
  // The code below assumes that r9 is not used as sb (static base) in
  // simulator code and therefore is regarded as a callee-saved register.
  <span class='d'>int32_t s0_val = get_register(s0);</span>
  <span class='d'>int32_t s1_val = get_register(s1);</span>
  <span class='d'>int32_t s2_val = get_register(s2);</span>
  <span class='d'>int32_t s3_val = get_register(s3);</span>
  <span class='d'>int32_t s4_val = get_register(s4);</span>
  <span class='d'>int32_t s5_val = get_register(s5);</span>
  <span class='d'>int32_t s6_val = get_register(s6);</span>
  <span class='d'>int32_t s7_val = get_register(s7);</span>
  <span class='d'>int32_t gp_val = get_register(gp);</span>
  <span class='d'>int32_t sp_val = get_register(sp);</span>
  <span class='d'>int32_t fp_val = get_register(fp);</span>

  // Setup the callee-saved registers with a known value. To be able to check
  // that they are preserved properly across JS execution.
  <a id='19' tid='20' class='m'>int32_t</a> <a id='21' tid='22' class='m'>callee_saved_value</a> = <a id='23' tid='24' class='m'>icount_</a>;
  <span class='d'>set_register(s0, callee_saved_value);</span>
  <span class='d'>set_register(s1, callee_saved_value);</span>
  <span class='d'>set_register(s2, callee_saved_value);</span>
  <span class='d'>set_register(s3, callee_saved_value);</span>
  <span class='d'>set_register(s4, callee_saved_value);</span>
  <span class='d'>set_register(s5, callee_saved_value);</span>
  <span class='d'>set_register(s6, callee_saved_value);</span>
  <span class='d'>set_register(s7, callee_saved_value);</span>
  <span class='d'>set_register(gp, callee_saved_value);</span>
  <span class='d'>set_register(fp, callee_saved_value);</span>

  // Start the simulation.
  <span class='d'>Execute();</span>

  // Check that the callee-saved registers have been preserved.
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s0));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s1));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s2));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s3));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s4));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s5));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s6));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(s7));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(gp));</span>
  <span class='d'>CHECK_EQ(callee_saved_value, get_register(fp));</span>

  // Restore callee-saved registers with the original value.
  <span class='d'>set_register(s0, s0_val);</span>
  <span class='d'>set_register(s1, s1_val);</span>
  <span class='d'>set_register(s2, s2_val);</span>
  <span class='d'>set_register(s3, s3_val);</span>
  <span class='d'>set_register(s4, s4_val);</span>
  <span class='d'>set_register(s5, s5_val);</span>
  <span class='d'>set_register(s6, s6_val);</span>
  <span class='d'>set_register(s7, s7_val);</span>
  <span class='d'>set_register(gp, gp_val);</span>
  <span class='d'>set_register(sp, sp_val);</span>
  <span class='d'>set_register(fp, fp_val);</span>

  // Pop stack passed arguments.
  <a id='11' tid='12' class='m'>CHECK_EQ</a>(<a id='13' tid='14' class='m'>entry_stack</a>, <a id='15' tid='16' class='m'>get_register</a>(<a id='17' tid='18' class='m'>sp</a>));
  <a id='5' tid='6' class='m'>set_register</a>(<a id='7' tid='8' class='m'>sp</a>, <a id='9' tid='10' class='m'>original_stack</a>);

  <span class='d'>int32_t result = get_register(v0);</span>
  <a id='1' tid='2' class='m'>return</a> <a id='3' tid='4' class='m'>result</a>;
}


<a id='473' tid='474' class='m'>uintptr_t</a> <a id='475' tid='476' class='m'>Simulator</a><a id='477' tid='478' class='m'>::</a><a id='479' tid='480' class='m'>PushAddress</a>(<a id='481' tid='482' class='m'>uintptr_t</a> <a id='483' tid='484' class='m'>address</a>) {
  <a id='485' tid='486' class='m'>int</a> <a id='487' tid='488' class='m'>new_sp</a> = <a id='489' tid='490' class='m'>get_register</a>(<a id='491' tid='492' class='m'>sp</a>) <a id='493' tid='494' class='m'>-</a> <a id='495' tid='496' class='m'>sizeof</a>(<a id='497' tid='498' class='m'>uintptr_t</a>);
  <a id='499' tid='500' class='m'>uintptr_t</a><a id='501' tid='502' class='m'>*</a> <a id='503' tid='504' class='m'>stack_slot</a> = <a id='505' tid='506' class='m'>reinterpret_cast</a>&lt;<a id='507' tid='508' class='m'>uintptr_t</a><a id='509' tid='510' class='m'>*</a>&gt;(<a id='511' tid='512' class='m'>new_sp</a>);
  <a id='513' tid='514' class='m'>*</a><a id='515' tid='516' class='m'>stack_slot</a> <a id='517' tid='518' class='m'>=</a> <a id='519' tid='520' class='m'>address</a>;
  <a id='521' tid='522' class='m'>set_register</a>(<a id='523' tid='524' class='m'>sp</a>, <a id='525' tid='526' class='m'>new_sp</a>);
  <a id='527' tid='528' class='m'>return</a> <a id='529' tid='530' class='m'>new_sp</a>;
}


<a id='371' tid='372' class='m'>uintptr_t</a> <a id='373' tid='374' class='m'>Simulator</a><a id='375' tid='376' class='m'>::</a><a id='377' tid='378' class='m'>PopAddress</a>() {
  <a id='379' tid='380' class='m'>int</a> <a id='381' tid='382' class='m'>current_sp</a> = <a id='383' tid='384' class='m'>get_register</a>(<a id='385' tid='386' class='m'>sp</a>);
  <a id='387' tid='388' class='m'>uintptr_t</a><a id='389' tid='390' class='m'>*</a> <a id='391' tid='392' class='m'>stack_slot</a> = <a id='393' tid='394' class='m'>reinterpret_cast</a>&lt;<a id='395' tid='396' class='m'>uintptr_t</a><a id='397' tid='398' class='m'>*</a>&gt;(<a id='399' tid='400' class='m'>current_sp</a>);
  <a id='401' tid='402' class='m'>uintptr_t</a> <a id='403' tid='404' class='m'>address</a> = <a id='405' tid='406' class='m'>*</a><a id='407' tid='408' class='m'>stack_slot</a>;
  <a id='409' tid='410' class='m'>set_register</a>(<a id='411' tid='412' class='m'>sp</a>, <a id='413' tid='414' class='m'>current_sp</a> <a id='415' tid='416' class='m'>+</a> <a id='417' tid='418' class='m'>sizeof</a>(<a id='419' tid='420' class='m'>uintptr_t</a>));
  <a id='421' tid='422' class='m'>return</a> <a id='423' tid='424' class='m'>address</a>;
}


<span class='d'>#undef UNSUPPORTED</span>

} }  // namespace v8::internal

<span class='d'>#endif</span>  // USE_SIMULATOR

<span class='d'>#endif</span>  // V8_TARGET_ARCH_MIPS


</pre>
</div>
<div id="right" class="src">
<pre>
<a id='rightstart' tid='leftstart'></a>
// Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#<a id='6048' tid='6047' class='m'>include</a> <a id='6050' tid='6049' class='m'>&lt;</a><a id='6052' tid='6051' class='m'>stdlib</a><a id='6054' tid='6053' class='m'>.</a><a id='6056' tid='6055' class='m'>h</a><a id='6058' tid='6057' class='m'>&gt;</a>
#<a id='6036' tid='6035' class='m'>include</a> <a id='6038' tid='6037' class='m'>&lt;</a><a id='6040' tid='6039' class='m'>math</a><a id='6042' tid='6041' class='m'>.</a><a id='6044' tid='6043' class='m'>h</a><a id='6046' tid='6045' class='m'>&gt;</a>
#<a id='6028' tid='6027' class='m'>include</a> <a id='6030' tid='6029' class='m'>&lt;</a><a id='6032' tid='6031' class='m'>cstdarg</a><a id='6034' tid='6033' class='m'>&gt;</a>
#<a id='6024' tid='6023' class='m'>include</a> <a id='6026' tid='6025' class='m'>&quot;v8.h&quot;</a>

<span class='i'>#if defined(V8_TARGET_ARCH_ARM)</span>

#<a id='6020' tid='6019' class='m'>include</a> <a id='6022' tid='6021' class='m'>&quot;disasm.h&quot;</a>
#<a id='6016' tid='6015' class='m'>include</a> <a id='6018' tid='6017' class='m'>&quot;assembler.h&quot;</a>
<span class='i'>#include &quot;arm/constants-arm.h&quot;</span>
<span class='i'>#include &quot;arm/simulator-arm.h&quot;</span>

#<a id='6006' tid='6005' class='m'>if</a> <a id='6008' tid='6007' class='m'>defined</a><a id='6010' tid='6009' class='m'>(</a><a id='6012' tid='6011' class='m'>USE_SIMULATOR</a><a id='6014' tid='6013' class='m'>)</a>

// Only build the simulator if not compiling for real ARM hardware.
<span class='i'>namespace</span> <span class='i'>v8</span> {
<span class='i'>namespace</span> <span class='i'>internal</span> {

// This macro provides a platform independent use of sscanf. The reason for
// SScanF not being implemented in a platform independent way through
// ::v8::internal::OS in the same way as SNPrintF is that the
// Windows C Run-Time Library does not provide vsscanf.
#<a id='6000' tid='5999' class='m'>define</a> <a id='6002' tid='6001' class='m'>SScanF</a> <a id='6004' tid='6003' class='m'>sscanf</a>  // NOLINT

// The ArmDebugger class is used by the simulator while debugging simulated ARM
// code.
<span class='i'>class</span> <span class='i'>ArmDebugger</span> {
 <span class='i'>public:</span>
  <span class='i'>explicit ArmDebugger(Simulator* sim)</span>;
  <span class='i'>~ArmDebugger();</span>

  <a id='5972' tid='5971' class='m'>void</a> <a id='5974' tid='5973' class='m'>Stop</a>(<a id='5976' tid='5975' class='m'>Instruction</a><a id='5978' tid='5977' class='m'>*</a> <a id='5980' tid='5979' class='m'>instr</a>);
  <span class='i'>void Debug()</span>;

 <span class='i'>private:</span>
  <span class='i'>static const Instr kBreakpointInstr =
      (al | (7*B25) | (1*B24) | kBreakpoint);</span>
  <span class='i'>static const Instr kNopInstr = (al | (13*B21));</span>

  <span class='i'>Simulator* sim_;</span>

  <span class='i'>int32_t GetRegisterValue(int regnum)</span>;
  <span class='i'>double GetRegisterPairDoubleValue(int regnum)</span>;
  <span class='i'>double GetVFPDoubleRegisterValue(int regnum)</span>;
  <a id='5982' tid='5981' class='m'>bool</a> <a id='5984' tid='5983' class='m'>GetValue</a>(<a id='5986' tid='5985' class='m'>const</a> <a id='5988' tid='5987' class='m'>char</a><a id='5990' tid='5989' class='m'>*</a> <a id='5992' tid='5991' class='m'>desc</a>, <a id='5994' tid='5993' class='m'>int32_t</a><a id='5996' tid='5995' class='m'>*</a> <a id='5998' tid='5997' class='m'>value</a>);
  <span class='i'>bool GetVFPSingleValue(const char* desc, float* value)</span>;
  <span class='i'>bool GetVFPDoubleValue(const char* desc, double* value)</span>;

  // Set or delete a breakpoint. Returns true if successful.
  <a id='5958' tid='5957' class='m'>bool</a> <a id='5960' tid='5959' class='m'>SetBreakpoint</a>(<a id='5962' tid='5961' class='m'>Instruction</a><a id='5964' tid='5963' class='m'>*</a> <a id='5966' tid='5965' class='m'>breakpc</a>);
  <a id='5938' tid='5937' class='m'>bool</a> <a id='5940' tid='5939' class='m'>DeleteBreakpoint</a>(<a id='5942' tid='5941' class='m'>Instruction</a><a id='5944' tid='5943' class='m'>*</a> <a id='5946' tid='5945' class='m'>breakpc</a>);

  // Undo and redo all breakpoints. This is needed to bracket disassembly and
  // execution to skip past breakpoints when run from the debugger.
  <span class='i'>void UndoBreakpoints()</span>;
  <span class='i'>void RedoBreakpoints()</span>;
};


<span class='i'>ArmDebugger::ArmDebugger(Simulator* sim) {
  sim_ = sim;
}</span>


<span class='i'>ArmDebugger::~ArmDebugger() {
}</span>



#<a id='5968' tid='5967' class='m'>ifdef</a> <a id='5970' tid='5969' class='m'>GENERATED_CODE_COVERAGE</a>
<a id='5948' tid='5947' class='m'>static</a> <a id='5950' tid='5949' class='m'>FILE</a><a id='5952' tid='5951' class='m'>*</a> <a id='5954' tid='5953' class='m'>coverage_log</a> = <a id='5956' tid='5955' class='m'>NULL</a>;


<a id='5904' tid='5903' class='m'>static</a> <a id='5906' tid='5905' class='m'>void</a> <a id='5908' tid='5907' class='m'>InitializeCoverage</a>() {
  <a id='5910' tid='5909' class='m'>char</a><a id='5912' tid='5911' class='m'>*</a> <a id='5914' tid='5913' class='m'>file_name</a> = <a id='5916' tid='5915' class='m'>getenv</a>(<a id='5918' tid='5917' class='m'>&quot;V8_GENERATED_CODE_COVERAGE_LOG&quot;</a>);
  <a id='5920' tid='5919' class='m'>if</a> (<a id='5922' tid='5921' class='m'>file_name</a> <a id='5924' tid='5923' class='m'>!=</a> <a id='5926' tid='5925' class='m'>NULL</a>) {
    <a id='5928' tid='5927' class='m'>coverage_log</a> <a id='5930' tid='5929' class='m'>=</a> <a id='5932' tid='5931' class='m'>fopen</a>(<a id='5934' tid='5933' class='m'>file_name</a>, <a id='5936' tid='5935' class='m'>&quot;aw+&quot;</a>);
  }
}


<span class='i'>void</span> <span class='i'>ArmDebugger::Stop</span>(<a id='5898' tid='5897' class='m'>Instruction</a><a id='5900' tid='5899' class='m'>*</a> <a id='5902' tid='5901' class='m'>instr</a>) {
  // Get the stop code.
  <span class='i'>uint32_t code = instr-&gt;SvcValue() & kStopCodeMask;</span>
  // Retrieve the encoded address, which comes just after this stop.
  <a id='5872' tid='5871' class='m'>char</a><a id='5874' tid='5873' class='m'>*</a><a id='5876' tid='5875' class='m'>*</a> <a id='5878' tid='5877' class='m'>msg_address</a> =
    <a id='5880' tid='5879' class='m'>reinterpret_cast</a>&lt;<a id='5882' tid='5881' class='m'>char</a><a id='5884' tid='5883' class='m'>*</a><a id='5886' tid='5885' class='m'>*</a>&gt;(<a id='5888' tid='5887' class='m'>sim_</a>-&gt;<a id='5890' tid='5889' class='m'>get_pc</a>() <span class='i'>+</span> <span class='i'>Instruction::kInstrSize</span>);
  <a id='5862' tid='5861' class='m'>char</a><a id='5864' tid='5863' class='m'>*</a> <a id='5866' tid='5865' class='m'>msg</a> = <a id='5868' tid='5867' class='m'>*</a><a id='5870' tid='5869' class='m'>msg_address</a>;
  <a id='5798' tid='5797' class='m'>ASSERT</a>(<a id='5800' tid='5799' class='m'>msg</a> <a id='5802' tid='5801' class='m'>!=</a> <a id='5804' tid='5803' class='m'>NULL</a>);

  // Update this stop description.
  <a id='5728' tid='5727' class='m'>if</a> (<span class='i'>isWatchedStop(code)</span> <span class='i'>&&</span> <a id='5730' tid='5729' class='m'>!</a><a id='5732' tid='5731' class='m'>watched_stops</a>[<a id='5734' tid='5733' class='m'>code</a>].<a id='5736' tid='5735' class='m'>desc</a>) {
    <a id='5738' tid='5737' class='m'>watched_stops</a>[<a id='5740' tid='5739' class='m'>code</a>].<a id='5742' tid='5741' class='m'>desc</a> <a id='5744' tid='5743' class='m'>=</a> <a id='5746' tid='5745' class='m'>msg</a>;
  }

  <a id='5674' tid='5673' class='m'>if</a> (<a id='5676' tid='5675' class='m'>strlen</a>(<a id='5678' tid='5677' class='m'>msg</a>) <a id='5680' tid='5679' class='m'>&gt;</a> <a id='5682' tid='5681' class='m'>0</a>) {
    <a id='5684' tid='5683' class='m'>if</a> (<a id='5686' tid='5685' class='m'>coverage_log</a> <a id='5688' tid='5687' class='m'>!=</a> <a id='5690' tid='5689' class='m'>NULL</a>) {
      <span class='i'>fprintf(coverage_log, &quot;%s\n&quot;, msg);</span>
      <a id='5692' tid='5691' class='m'>fflush</a>(<a id='5694' tid='5693' class='m'>coverage_log</a>);
    }
    // Overwrite the instruction and address with nops.
    <a id='5612' tid='5611' class='m'>instr</a>-&gt;<a id='5614' tid='5613' class='m'>SetInstructionBits</a>(<a id='5616' tid='5615' class='m'>kNopInstr</a>);
    <span class='i'>reinterpret_cast&lt;Instruction*&gt;(msg_address)-&gt;SetInstructionBits(kNopInstr);</span>
  }
  <a id='5604' tid='5603' class='m'>sim_</a>-&gt;<a id='5606' tid='5605' class='m'>set_pc</a>(<a id='5608' tid='5607' class='m'>sim_</a>-&gt;<a id='5610' tid='5609' class='m'>get_pc</a>() <span class='i'>+</span> <span class='i'>2 * Instruction::kInstrSize</span>);
}

<span class='i'>#else</span>  // ndef GENERATED_CODE_COVERAGE

<span class='i'>static void InitializeCoverage() {
}</span>


<span class='i'>void</span> <span class='i'>ArmDebugger::Stop</span>(<a id='5892' tid='5891' class='m'>Instruction</a><a id='5894' tid='5893' class='m'>*</a> <a id='5896' tid='5895' class='m'>instr</a>) {
  // Get the stop code.
  <span class='i'>uint32_t code = instr-&gt;SvcValue() & kStopCodeMask;</span>
  // Retrieve the encoded address, which comes just after this stop.
  <a id='5830' tid='5829' class='m'>char</a><a id='5832' tid='5831' class='m'>*</a> <a id='5834' tid='5833' class='m'>msg</a> = <a id='5836' tid='5835' class='m'>*</a><a id='5838' tid='5837' class='m'>reinterpret_cast</a>&lt;<a id='5840' tid='5839' class='m'>char</a><a id='5842' tid='5841' class='m'>*</a><a id='5844' tid='5843' class='m'>*</a>&gt;(<a id='5846' tid='5845' class='m'>sim_</a>-&gt;<a id='5848' tid='5847' class='m'>get_pc</a>()
                                        <a id='5850' tid='5849' class='m'>+</a> <a id='5852' tid='5851' class='m'>Instruction</a><a id='5854' tid='5853' class='m'>::</a><a id='5856' tid='5855' class='m'>kInstrSize</a>);
  // Update this stop description.
  <a id='5806' tid='5805' class='m'>if</a> (<span class='i'>sim_-&gt;isWatchedStop(code)</span> <span class='i'>&&</span> <a id='5808' tid='5807' class='m'>!</a><a id='5810' tid='5809' class='m'>sim_</a>-&gt;<a id='5812' tid='5811' class='m'>watched_stops</a>[<a id='5814' tid='5813' class='m'>code</a>].<a id='5816' tid='5815' class='m'>desc</a>) {
    <a id='5818' tid='5817' class='m'>sim_</a>-&gt;<a id='5820' tid='5819' class='m'>watched_stops</a>[<a id='5822' tid='5821' class='m'>code</a>].<a id='5824' tid='5823' class='m'>desc</a> <a id='5826' tid='5825' class='m'>=</a> <a id='5828' tid='5827' class='m'>msg</a>;
  }
  // Print the stop message and code if it is not the default code.
  <span class='i'>if (code != kMaxStopCode) {
    PrintF(&quot;Simulator hit stop %u: %s\n&quot;, code, msg);
  } else {
    PrintF(&quot;Simulator hit %s\n&quot;, msg);
  }</span>
  <a id='5748' tid='5747' class='m'>sim_</a>-&gt;<a id='5750' tid='5749' class='m'>set_pc</a>(<a id='5752' tid='5751' class='m'>sim_</a>-&gt;<a id='5754' tid='5753' class='m'>get_pc</a>() <a id='5756' tid='5755' class='m'>+</a> <a id='5758' tid='5757' class='m'>2</a> <a id='5760' tid='5759' class='m'>*</a> <a id='5762' tid='5761' class='m'>Instruction</a><a id='5764' tid='5763' class='m'>::</a><a id='5766' tid='5765' class='m'>kInstrSize</a>);
  <span class='i'>Debug();</span>
}
<span class='i'>#endif</span>


<span class='i'>int32_t</span> <span class='i'>ArmDebugger::GetRegisterValue</span>(<a id='5858' tid='5857' class='m'>int</a> <a id='5860' tid='5859' class='m'>regnum</a>) {
  <span class='i'>if</span> <span class='i'>(regnum == kPCRegister)</span> {
    <a id='5778' tid='5777' class='m'>return</a> <a id='5780' tid='5779' class='m'>sim_</a>-&gt;<a id='5782' tid='5781' class='m'>get_pc</a>();
  } <a id='5768' tid='5767' class='m'>else</a> {
    <a id='5770' tid='5769' class='m'>return</a> <a id='5772' tid='5771' class='m'>sim_</a>-&gt;<a id='5774' tid='5773' class='m'>get_register</a>(<a id='5776' tid='5775' class='m'>regnum</a>);
  }
}


<span class='i'>double ArmDebugger::GetRegisterPairDoubleValue(int regnum) {
  return sim_-&gt;get_double_from_register_pair(regnum);
}</span>


<span class='i'>double ArmDebugger::GetVFPDoubleRegisterValue(int regnum) {
  return sim_-&gt;get_double_from_d_register(regnum);
}</span>


<span class='i'>bool</span> <span class='i'>ArmDebugger::GetValue</span>(<a id='5784' tid='5783' class='m'>const</a> <a id='5786' tid='5785' class='m'>char</a><a id='5788' tid='5787' class='m'>*</a> <a id='5790' tid='5789' class='m'>desc</a>, <a id='5792' tid='5791' class='m'>int32_t</a><a id='5794' tid='5793' class='m'>*</a> <a id='5796' tid='5795' class='m'>value</a>) {
  <a id='5710' tid='5709' class='m'>int</a> <a id='5712' tid='5711' class='m'>regnum</a> = <a id='5714' tid='5713' class='m'>Registers</a><a id='5716' tid='5715' class='m'>::</a><a id='5718' tid='5717' class='m'>Number</a>(<a id='5720' tid='5719' class='m'>desc</a>);
  <span class='i'>if</span> <span class='i'>(regnum != kNoRegister)</span> {
    <a id='5696' tid='5695' class='m'>*</a><a id='5698' tid='5697' class='m'>value</a> <a id='5700' tid='5699' class='m'>=</a> <a id='5702' tid='5701' class='m'>GetRegisterValue</a>(<a id='5704' tid='5703' class='m'>regnum</a>);
    <a id='5706' tid='5705' class='m'>return</a> <a id='5708' tid='5707' class='m'>true</a>;
  } <a id='5618' tid='5617' class='m'>else</a> {
    <span class='i'>if</span> (<a id='5620' tid='5619' class='m'>strncmp</a>(<a id='5622' tid='5621' class='m'>desc</a>, <a id='5624' tid='5623' class='m'>&quot;0x&quot;</a>, <a id='5626' tid='5625' class='m'>2</a>) <a id='5628' tid='5627' class='m'>==</a> <a id='5630' tid='5629' class='m'>0</a>) {
      <a id='5528' tid='5527' class='m'>return</a> <a id='5530' tid='5529' class='m'>SScanF</a>(<span class='i'>desc + 2</span>, <span class='i'>&quot;%x&quot;</span>, <a id='5532' tid='5531' class='m'>reinterpret_cast</a>&lt;<a id='5534' tid='5533' class='m'>uint32_t</a><a id='5536' tid='5535' class='m'>*</a>&gt;(<a id='5538' tid='5537' class='m'>value</a>)) <a id='5540' tid='5539' class='m'>==</a> <a id='5542' tid='5541' class='m'>1</a>;
    } <span class='i'>else {
      return SScanF(desc, &quot;%u&quot;, reinterpret_cast&lt;uint32_t*&gt;(value)) == 1;
    }</span>
  }
  <span class='i'>return false;</span>
}


<span class='i'>bool ArmDebugger::GetVFPSingleValue(const char* desc, float* value) {
  bool is_double;
  int regnum = VFPRegisters::Number(desc, &is_double);
  if (regnum != kNoRegister && !is_double) {
    *value = sim_-&gt;get_float_from_s_register(regnum);
    return true;
  }
  return false;
}</span>


<span class='i'>bool ArmDebugger::GetVFPDoubleValue(const char* desc, double* value) {
  bool is_double;
  int regnum = VFPRegisters::Number(desc, &is_double);
  if (regnum != kNoRegister && is_double) {
    *value = sim_-&gt;get_double_from_d_register(regnum);
    return true;
  }
  return false;
}</span>


<span class='i'>bool</span> <span class='i'>ArmDebugger::SetBreakpoint</span>(<a id='5722' tid='5721' class='m'>Instruction</a><a id='5724' tid='5723' class='m'>*</a> <a id='5726' tid='5725' class='m'>breakpc</a>) {
  // Check if a breakpoint can be set. If not return without any side-effects.
  <a id='5632' tid='5631' class='m'>if</a> (<a id='5634' tid='5633' class='m'>sim_</a>-&gt;<a id='5636' tid='5635' class='m'>break_pc_</a> <a id='5638' tid='5637' class='m'>!=</a> <a id='5640' tid='5639' class='m'>NULL</a>) {
    <a id='5642' tid='5641' class='m'>return</a> <a id='5644' tid='5643' class='m'>false</a>;
  }

  // Set the breakpoint.
  <a id='5646' tid='5645' class='m'>sim_</a>-&gt;<a id='5648' tid='5647' class='m'>break_pc_</a> <a id='5650' tid='5649' class='m'>=</a> <a id='5652' tid='5651' class='m'>breakpc</a>;
  <a id='5654' tid='5653' class='m'>sim_</a>-&gt;<a id='5656' tid='5655' class='m'>break_instr_</a> <a id='5658' tid='5657' class='m'>=</a> <a id='5660' tid='5659' class='m'>breakpc</a>-&gt;<a id='5662' tid='5661' class='m'>InstructionBits</a>();
  // Not setting the breakpoint instruction in the code itself. It will be set
  // when the debugger shell continues.
  <a id='5664' tid='5663' class='m'>return</a> <a id='5666' tid='5665' class='m'>true</a>;
}


<span class='i'>bool</span> <span class='i'>ArmDebugger::DeleteBreakpoint</span>(<a id='5668' tid='5667' class='m'>Instruction</a><a id='5670' tid='5669' class='m'>*</a> <a id='5672' tid='5671' class='m'>breakpc</a>) {
  <a id='5544' tid='5543' class='m'>if</a> (<a id='5546' tid='5545' class='m'>sim_</a>-&gt;<a id='5548' tid='5547' class='m'>break_pc_</a> <a id='5550' tid='5549' class='m'>!=</a> <a id='5552' tid='5551' class='m'>NULL</a>) {
    <a id='5554' tid='5553' class='m'>sim_</a>-&gt;<a id='5556' tid='5555' class='m'>break_pc_</a>-&gt;<a id='5558' tid='5557' class='m'>SetInstructionBits</a>(<a id='5560' tid='5559' class='m'>sim_</a>-&gt;<a id='5562' tid='5561' class='m'>break_instr_</a>);
  }

  <a id='5564' tid='5563' class='m'>sim_</a>-&gt;<a id='5566' tid='5565' class='m'>break_pc_</a> <a id='5568' tid='5567' class='m'>=</a> <a id='5570' tid='5569' class='m'>NULL</a>;
  <a id='5572' tid='5571' class='m'>sim_</a>-&gt;<a id='5574' tid='5573' class='m'>break_instr_</a> <a id='5576' tid='5575' class='m'>=</a> <a id='5578' tid='5577' class='m'>0</a>;
  <a id='5580' tid='5579' class='m'>return</a> <a id='5582' tid='5581' class='m'>true</a>;
}


<span class='i'>void</span> <span class='i'>ArmDebugger::UndoBreakpoints</span><span class='i'>()</span> {
  <a id='5584' tid='5583' class='m'>if</a> (<a id='5586' tid='5585' class='m'>sim_</a>-&gt;<a id='5588' tid='5587' class='m'>break_pc_</a> <a id='5590' tid='5589' class='m'>!=</a> <a id='5592' tid='5591' class='m'>NULL</a>) {
    <a id='5594' tid='5593' class='m'>sim_</a>-&gt;<a id='5596' tid='5595' class='m'>break_pc_</a>-&gt;<a id='5598' tid='5597' class='m'>SetInstructionBits</a>(<a id='5600' tid='5599' class='m'>sim_</a>-&gt;<a id='5602' tid='5601' class='m'>break_instr_</a>);
  }
}


<span class='i'>void</span> <span class='i'>ArmDebugger::RedoBreakpoints</span><span class='i'>()</span> {
  <a id='5510' tid='5509' class='m'>if</a> (<a id='5512' tid='5511' class='m'>sim_</a>-&gt;<a id='5514' tid='5513' class='m'>break_pc_</a> <a id='5516' tid='5515' class='m'>!=</a> <a id='5518' tid='5517' class='m'>NULL</a>) {
    <a id='5520' tid='5519' class='m'>sim_</a>-&gt;<a id='5522' tid='5521' class='m'>break_pc_</a>-&gt;<a id='5524' tid='5523' class='m'>SetInstructionBits</a>(<a id='5526' tid='5525' class='m'>kBreakpointInstr</a>);
  }
}


<span class='i'>void</span> <span class='i'>ArmDebugger::Debug</span><span class='i'>()</span> {
  <a id='5502' tid='5501' class='m'>intptr_t</a> <a id='5504' tid='5503' class='m'>last_pc</a> = <a id='5506' tid='5505' class='m'>-</a><a id='5508' tid='5507' class='m'>1</a>;
  <a id='4518' tid='4517' class='m'>bool</a> <a id='4520' tid='4519' class='m'>done</a> = <a id='4522' tid='4521' class='m'>false</a>;

#<a id='4524' tid='4523' class='m'>define</a> <a id='4526' tid='4525' class='m'>COMMAND_SIZE</a> <a id='4528' tid='4527' class='m'>63</a>
#<a id='4530' tid='4529' class='m'>define</a> <a id='4532' tid='4531' class='m'>ARG_SIZE</a> <a id='4534' tid='4533' class='m'>255</a>

#<a id='4536' tid='4535' class='m'>define</a> <a id='4538' tid='4537' class='m'>STR</a><a id='4540' tid='4539' class='m'>(</a><a id='4542' tid='4541' class='m'>a</a><a id='4544' tid='4543' class='m'>)</a> <a id='4546' tid='4545' class='m'>#</a><a id='4548' tid='4547' class='m'>a</a>
#<a id='4550' tid='4549' class='m'>define</a> <a id='4552' tid='4551' class='m'>XSTR</a><a id='4554' tid='4553' class='m'>(</a><a id='4556' tid='4555' class='m'>a</a><a id='4558' tid='4557' class='m'>)</a> <a id='4560' tid='4559' class='m'>STR</a><a id='4562' tid='4561' class='m'>(</a><a id='4564' tid='4563' class='m'>a</a><a id='4566' tid='4565' class='m'>)</a>

  <a id='4568' tid='4567' class='m'>char</a> <a id='4570' tid='4569' class='m'>cmd</a>[<a id='4572' tid='4571' class='m'>COMMAND_SIZE</a> <a id='4574' tid='4573' class='m'>+</a> <a id='4576' tid='4575' class='m'>1</a>];
  <a id='4578' tid='4577' class='m'>char</a> <a id='4580' tid='4579' class='m'>arg1</a>[<a id='4582' tid='4581' class='m'>ARG_SIZE</a> <a id='4584' tid='4583' class='m'>+</a> <a id='4586' tid='4585' class='m'>1</a>];
  <a id='4588' tid='4587' class='m'>char</a> <a id='4590' tid='4589' class='m'>arg2</a>[<a id='4592' tid='4591' class='m'>ARG_SIZE</a> <a id='4594' tid='4593' class='m'>+</a> <a id='4596' tid='4595' class='m'>1</a>];
  <a id='4598' tid='4597' class='m'>char</a><a id='4600' tid='4599' class='m'>*</a> <a id='4602' tid='4601' class='m'>argv</a>[<a id='4604' tid='4603' class='m'>3</a>] = { <a id='4606' tid='4605' class='m'>cmd</a>, <a id='4608' tid='4607' class='m'>arg1</a>, <a id='4610' tid='4609' class='m'>arg2</a> };

  // make sure to have a proper terminating character if reaching the limit
  <a id='4612' tid='4611' class='m'>cmd</a>[<a id='4614' tid='4613' class='m'>COMMAND_SIZE</a>] <a id='4616' tid='4615' class='m'>=</a> <a id='4618' tid='4617' class='m'>0</a>;
  <a id='4620' tid='4619' class='m'>arg1</a>[<a id='4622' tid='4621' class='m'>ARG_SIZE</a>] <a id='4624' tid='4623' class='m'>=</a> <a id='4626' tid='4625' class='m'>0</a>;
  <a id='4628' tid='4627' class='m'>arg2</a>[<a id='4630' tid='4629' class='m'>ARG_SIZE</a>] <a id='4632' tid='4631' class='m'>=</a> <a id='4634' tid='4633' class='m'>0</a>;

  // Undo all set breakpoints while running in the debugger shell. This will
  // make them invisible to all commands.
  <a id='4636' tid='4635' class='m'>UndoBreakpoints</a>();

  <a id='4638' tid='4637' class='m'>while</a> (<a id='4640' tid='4639' class='m'>!</a><a id='4642' tid='4641' class='m'>done</a>) {
    <a id='4644' tid='4643' class='m'>if</a> (<a id='4646' tid='4645' class='m'>last_pc</a> <a id='4648' tid='4647' class='m'>!=</a> <a id='4650' tid='4649' class='m'>sim_</a>-&gt;<a id='4652' tid='4651' class='m'>get_pc</a>()) {
      <a id='4664' tid='4663' class='m'>disasm</a><a id='4666' tid='4665' class='m'>::</a><a id='4668' tid='4667' class='m'>NameConverter</a> <a id='4670' tid='4669' class='m'>converter</a>;
      <a id='4654' tid='4653' class='m'>disasm</a><a id='4656' tid='4655' class='m'>::</a><a id='4658' tid='4657' class='m'>Disassembler</a> <a id='4660' tid='4659' class='m'>dasm</a>(<a id='4662' tid='4661' class='m'>converter</a>);
      // use a reasonably large buffer
      <a id='4672' tid='4671' class='m'>v8</a><a id='4674' tid='4673' class='m'>::</a><a id='4676' tid='4675' class='m'>internal</a><a id='4678' tid='4677' class='m'>::</a><a id='4680' tid='4679' class='m'>EmbeddedVector</a>&lt;<a id='4682' tid='4681' class='m'>char</a>, <a id='4684' tid='4683' class='m'>256</a>&gt; <a id='4686' tid='4685' class='m'>buffer</a>;
      <a id='4688' tid='4687' class='m'>dasm</a>.<a id='4690' tid='4689' class='m'>InstructionDecode</a>(<a id='4692' tid='4691' class='m'>buffer</a>,
                             <a id='4694' tid='4693' class='m'>reinterpret_cast</a>&lt;<a id='4696' tid='4695' class='m'>byte</a><a id='4698' tid='4697' class='m'>*</a>&gt;(<a id='4700' tid='4699' class='m'>sim_</a>-&gt;<a id='4702' tid='4701' class='m'>get_pc</a>()));
      <a id='4704' tid='4703' class='m'>PrintF</a>(<a id='4706' tid='4705' class='m'>&quot;  0x%08x  %s\n&quot;</a>, <a id='4708' tid='4707' class='m'>sim_</a>-&gt;<a id='4710' tid='4709' class='m'>get_pc</a>(), <a id='4712' tid='4711' class='m'>buffer</a>.<a id='4714' tid='4713' class='m'>start</a>());
      <a id='4716' tid='4715' class='m'>last_pc</a> <a id='4718' tid='4717' class='m'>=</a> <a id='4720' tid='4719' class='m'>sim_</a>-&gt;<a id='4722' tid='4721' class='m'>get_pc</a>();
    }
    <a id='4724' tid='4723' class='m'>char</a><a id='4726' tid='4725' class='m'>*</a> <a id='4728' tid='4727' class='m'>line</a> = <a id='4730' tid='4729' class='m'>ReadLine</a>(<a id='4732' tid='4731' class='m'>&quot;sim&gt; &quot;</a>);
    <a id='4734' tid='4733' class='m'>if</a> (<a id='4736' tid='4735' class='m'>line</a> <a id='4738' tid='4737' class='m'>==</a> <a id='4740' tid='4739' class='m'>NULL</a>) {
      <a id='4742' tid='4741' class='m'>break</a>;
    } <a id='4744' tid='4743' class='m'>else</a> {
      // Use sscanf to parse the individual parts of the command line. At the
      // moment no command expects more than two parameters.
      <a id='4746' tid='4745' class='m'>int</a> <a id='4748' tid='4747' class='m'>argc</a> = <a id='4750' tid='4749' class='m'>SScanF</a>(<a id='4752' tid='4751' class='m'>line</a>,
                        <a id='4754' tid='4753' class='m'>&quot;%&quot;</a> <a id='4756' tid='4755' class='m'>XSTR</a>(<a id='4758' tid='4757' class='m'>COMMAND_SIZE</a>) <a id='4760' tid='4759' class='m'>&quot;s &quot;</a>
                        <a id='4762' tid='4761' class='m'>&quot;%&quot;</a> <a id='4764' tid='4763' class='m'>XSTR</a>(<a id='4766' tid='4765' class='m'>ARG_SIZE</a>) <a id='4768' tid='4767' class='m'>&quot;s &quot;</a>
                        <a id='4770' tid='4769' class='m'>&quot;%&quot;</a> <a id='4772' tid='4771' class='m'>XSTR</a>(<a id='4774' tid='4773' class='m'>ARG_SIZE</a>) <a id='4776' tid='4775' class='m'>&quot;s&quot;</a>,
                        <a id='4778' tid='4777' class='m'>cmd</a>, <a id='4780' tid='4779' class='m'>arg1</a>, <a id='4782' tid='4781' class='m'>arg2</a>);
      <a id='4784' tid='4783' class='m'>if</a> ((<a id='4786' tid='4785' class='m'>strcmp</a>(<a id='4788' tid='4787' class='m'>cmd</a>, <a id='4790' tid='4789' class='m'>&quot;si&quot;</a>) <a id='4792' tid='4791' class='m'>==</a> <a id='4794' tid='4793' class='m'>0</a>) <a id='4796' tid='4795' class='m'>||</a> (<a id='4798' tid='4797' class='m'>strcmp</a>(<a id='4800' tid='4799' class='m'>cmd</a>, <a id='4802' tid='4801' class='m'>&quot;stepi&quot;</a>) <a id='4804' tid='4803' class='m'>==</a> <a id='4806' tid='4805' class='m'>0</a>)) {
        <span class='i'>sim_-&gt;InstructionDecode</span>(<span class='i'>reinterpret_cast</span>&lt;<a id='4808' tid='4807' class='m'>Instruction</a><a id='4810' tid='4809' class='m'>*</a>&gt;<span class='i'>(sim_-&gt;get_pc())</span>);
      } <a id='4812' tid='4811' class='m'>else</a> <a id='4814' tid='4813' class='m'>if</a> ((<a id='4816' tid='4815' class='m'>strcmp</a>(<a id='4818' tid='4817' class='m'>cmd</a>, <a id='4820' tid='4819' class='m'>&quot;c&quot;</a>) <a id='4822' tid='4821' class='m'>==</a> <a id='4824' tid='4823' class='m'>0</a>) <a id='4826' tid='4825' class='m'>||</a> (<a id='4828' tid='4827' class='m'>strcmp</a>(<a id='4830' tid='4829' class='m'>cmd</a>, <a id='4832' tid='4831' class='m'>&quot;cont&quot;</a>) <a id='4834' tid='4833' class='m'>==</a> <a id='4836' tid='4835' class='m'>0</a>)) {
        // Execute the one instruction we broke at with breakpoints disabled.
        <a id='4838' tid='4837' class='m'>sim_</a>-&gt;<a id='4840' tid='4839' class='m'>InstructionDecode</a>(<a id='4842' tid='4841' class='m'>reinterpret_cast</a>&lt;<a id='4844' tid='4843' class='m'>Instruction</a><a id='4846' tid='4845' class='m'>*</a>&gt;(<a id='4848' tid='4847' class='m'>sim_</a>-&gt;<a id='4850' tid='4849' class='m'>get_pc</a>()));
        // Leave the debugger shell.
        <a id='4852' tid='4851' class='m'>done</a> <a id='4854' tid='4853' class='m'>=</a> <a id='4856' tid='4855' class='m'>true</a>;
      } <a id='4858' tid='4857' class='m'>else</a> <a id='4860' tid='4859' class='m'>if</a> ((<a id='4862' tid='4861' class='m'>strcmp</a>(<a id='4864' tid='4863' class='m'>cmd</a>, <a id='4866' tid='4865' class='m'>&quot;p&quot;</a>) <a id='4868' tid='4867' class='m'>==</a> <a id='4870' tid='4869' class='m'>0</a>) <a id='4872' tid='4871' class='m'>||</a> (<a id='4874' tid='4873' class='m'>strcmp</a>(<a id='4876' tid='4875' class='m'>cmd</a>, <a id='4878' tid='4877' class='m'>&quot;print&quot;</a>) <a id='4880' tid='4879' class='m'>==</a> <a id='4882' tid='4881' class='m'>0</a>)) {
        <span class='i'>if</span> (<a id='4884' tid='4883' class='m'>argc</a> <a id='4886' tid='4885' class='m'>==</a> <a id='4888' tid='4887' class='m'>2</a> <span class='i'>||</span> (<span class='i'>argc == 3 && strcmp(arg2, &quot;fp&quot;) == 0</span>)) {
          <a id='4428' tid='4427' class='m'>int32_t</a> <a id='4430' tid='4429' class='m'>value</a>;
          <span class='i'>float svalue;</span>
          <span class='i'>double dvalue;</span>
          <a id='3736' tid='3735' class='m'>if</a> (<a id='4036' tid='4035' class='m'>strcmp</a>(<a id='4038' tid='4037' class='m'>arg1</a>, <a id='4040' tid='4039' class='m'>&quot;all&quot;</a>) <a id='4042' tid='4041' class='m'>==</a> <a id='4044' tid='4043' class='m'>0</a>) {
            <span class='i'>for</span> <span class='i'>(int i = 0; i &lt; kNumRegisters; i++)</span> {
              <span class='i'>value = GetRegisterValue(i);</span>
              <span class='i'>PrintF(&quot;%3s: 0x%08x %10d&quot;, Registers::Name(i), value, value);</span>
              <span class='i'>if</span> ((<a id='3738' tid='3737' class='m'>argc</a> <a id='3740' tid='3739' class='m'>==</a> <a id='3742' tid='3741' class='m'>3</a> <span class='i'>&&</span> <span class='i'>strcmp(arg2, &quot;fp&quot;) == 0</span>) <span class='i'>&&</span>
                  <span class='i'>i &lt; 8</span> <span class='i'>&&</span>
                  (<span class='i'>i % 2) == 0</span>) <span class='i'>{
                dvalue = GetRegisterPairDoubleValue(i);
                PrintF(&quot; (%f)\n&quot;, dvalue);
              }</span> <span class='i'>else</span> {
                <a id='2984' tid='2983' class='m'>PrintF</a>(<a id='2986' tid='2985' class='m'>&quot;\n&quot;</a>);
              }
            }
            <span class='i'>for (int i = 0; i &lt; kNumVFPDoubleRegisters; i++) {
              dvalue = GetVFPDoubleRegisterValue(i);
              uint64_t as_words = BitCast&lt;uint64_t&gt;(dvalue);
              PrintF(&quot;%3s: %f 0x%08x %08x\n&quot;,
                     VFPRegisters::Name(i, true),
                     dvalue,
                     static_cast&lt;uint32_t&gt;(as_words &gt;&gt; 32),
                     static_cast&lt;uint32_t&gt;(as_words & 0xffffffff));
            }</span>
          } <a id='3960' tid='3959' class='m'>else</a> {
            <span class='i'>if</span> (<a id='3962' tid='3961' class='m'>GetValue</a>(<a id='3964' tid='3963' class='m'>arg1</a>, <a id='3966' tid='3965' class='m'>&</a><a id='3968' tid='3967' class='m'>value</a>)) {
              <a id='3744' tid='3743' class='m'>PrintF</a>(<a id='3746' tid='3745' class='m'>&quot;%s: 0x%08x %d \n&quot;</a>, <a id='3748' tid='3747' class='m'>arg1</a>, <a id='3750' tid='3749' class='m'>value</a>, <a id='3752' tid='3751' class='m'>value</a>);
            } <a id='3620' tid='3619' class='m'>else</a> <span class='i'>if</span> <span class='i'>(GetVFPSingleValue(arg1, &svalue))</span> <span class='i'>{
              uint32_t as_word = BitCast&lt;uint32_t&gt;(svalue);
              PrintF(&quot;%s: %f 0x%08x\n&quot;, arg1, svalue, as_word);
            }</span> <span class='i'>else</span> <span class='i'>if</span> <span class='i'>(GetVFPDoubleValue(arg1, &dvalue))</span> <span class='i'>{
              uint64_t as_words = BitCast&lt;uint64_t&gt;(dvalue);
              PrintF(&quot;%s: %f 0x%08x %08x\n&quot;,
                     arg1,
                     dvalue,
                     static_cast&lt;uint32_t&gt;(as_words &gt;&gt; 32),
                     static_cast&lt;uint32_t&gt;(as_words & 0xffffffff));
            }</span> <span class='i'>else</span> {
              <a id='3622' tid='3621' class='m'>PrintF</a>(<a id='3624' tid='3623' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='3626' tid='3625' class='m'>arg1</a>);
            }
          }
        } <span class='i'>else {
          PrintF(&quot;print &lt;register&gt;\n&quot;);
        }</span>
      } <a id='4890' tid='4889' class='m'>else</a> <a id='4892' tid='4891' class='m'>if</a> ((<a id='4894' tid='4893' class='m'>strcmp</a>(<a id='4896' tid='4895' class='m'>cmd</a>, <a id='4898' tid='4897' class='m'>&quot;po&quot;</a>) <a id='4900' tid='4899' class='m'>==</a> <a id='4902' tid='4901' class='m'>0</a>)
                 <a id='4904' tid='4903' class='m'>||</a> (<a id='4906' tid='4905' class='m'>strcmp</a>(<a id='4908' tid='4907' class='m'>cmd</a>, <a id='4910' tid='4909' class='m'>&quot;printobject&quot;</a>) <a id='4912' tid='4911' class='m'>==</a> <a id='4914' tid='4913' class='m'>0</a>)) {
        <a id='4916' tid='4915' class='m'>if</a> (<a id='4918' tid='4917' class='m'>argc</a> <a id='4920' tid='4919' class='m'>==</a> <a id='4922' tid='4921' class='m'>2</a>) {
          <a id='4924' tid='4923' class='m'>int32_t</a> <a id='4926' tid='4925' class='m'>value</a>;
          <a id='4928' tid='4927' class='m'>if</a> (<a id='4930' tid='4929' class='m'>GetValue</a>(<a id='4932' tid='4931' class='m'>arg1</a>, <a id='4934' tid='4933' class='m'>&</a><a id='4936' tid='4935' class='m'>value</a>)) {
            <a id='4938' tid='4937' class='m'>Object</a><a id='4940' tid='4939' class='m'>*</a> <a id='4942' tid='4941' class='m'>obj</a> = <a id='4944' tid='4943' class='m'>reinterpret_cast</a>&lt;<a id='4946' tid='4945' class='m'>Object</a><a id='4948' tid='4947' class='m'>*</a>&gt;(<a id='4950' tid='4949' class='m'>value</a>);
            <a id='4952' tid='4951' class='m'>PrintF</a>(<a id='4954' tid='4953' class='m'>&quot;%s: \n&quot;</a>, <a id='4956' tid='4955' class='m'>arg1</a>);
#<a id='4958' tid='4957' class='m'>ifdef</a> <a id='4960' tid='4959' class='m'>DEBUG</a>
            <a id='4962' tid='4961' class='m'>obj</a>-&gt;<a id='4964' tid='4963' class='m'>PrintLn</a>();
#<a id='4966' tid='4965' class='m'>else</a>
            <a id='4968' tid='4967' class='m'>obj</a>-&gt;<a id='4970' tid='4969' class='m'>ShortPrint</a>();
            <a id='4972' tid='4971' class='m'>PrintF</a>(<a id='4974' tid='4973' class='m'>&quot;\n&quot;</a>);
#<a id='4976' tid='4975' class='m'>endif</a>
          } <a id='4978' tid='4977' class='m'>else</a> {
            <a id='4980' tid='4979' class='m'>PrintF</a>(<a id='4982' tid='4981' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='4984' tid='4983' class='m'>arg1</a>);
          }
        } <a id='4986' tid='4985' class='m'>else</a> {
          <a id='4988' tid='4987' class='m'>PrintF</a>(<a id='4990' tid='4989' class='m'>&quot;printobject &lt;value&gt;\n&quot;</a>);
        }
      } <a id='4992' tid='4991' class='m'>else</a> <a id='4994' tid='4993' class='m'>if</a> (<a id='4996' tid='4995' class='m'>strcmp</a>(<a id='4998' tid='4997' class='m'>cmd</a>, <a id='5000' tid='4999' class='m'>&quot;stack&quot;</a>) <a id='5002' tid='5001' class='m'>==</a> <a id='5004' tid='5003' class='m'>0</a> <a id='5006' tid='5005' class='m'>||</a> <a id='5008' tid='5007' class='m'>strcmp</a>(<a id='5010' tid='5009' class='m'>cmd</a>, <a id='5012' tid='5011' class='m'>&quot;mem&quot;</a>) <a id='5014' tid='5013' class='m'>==</a> <a id='5016' tid='5015' class='m'>0</a>) {
        <a id='5018' tid='5017' class='m'>int32_t</a><a id='5020' tid='5019' class='m'>*</a> <a id='5022' tid='5021' class='m'>cur</a> = <a id='5024' tid='5023' class='m'>NULL</a>;
        <a id='5026' tid='5025' class='m'>int32_t</a><a id='5028' tid='5027' class='m'>*</a> <a id='5030' tid='5029' class='m'>end</a> = <a id='5032' tid='5031' class='m'>NULL</a>;
        <a id='5034' tid='5033' class='m'>int</a> <a id='5036' tid='5035' class='m'>next_arg</a> = <a id='5038' tid='5037' class='m'>1</a>;

        <a id='5040' tid='5039' class='m'>if</a> (<a id='5042' tid='5041' class='m'>strcmp</a>(<a id='5044' tid='5043' class='m'>cmd</a>, <a id='5046' tid='5045' class='m'>&quot;stack&quot;</a>) <a id='5048' tid='5047' class='m'>==</a> <a id='5050' tid='5049' class='m'>0</a>) {
          <a id='5052' tid='5051' class='m'>cur</a> <a id='5054' tid='5053' class='m'>=</a> <a id='5056' tid='5055' class='m'>reinterpret_cast</a>&lt;<a id='5058' tid='5057' class='m'>int32_t</a><a id='5060' tid='5059' class='m'>*</a>&gt;(<a id='5062' tid='5061' class='m'>sim_</a>-&gt;<a id='5064' tid='5063' class='m'>get_register</a>(<a id='5066' tid='5065' class='m'>Simulator</a><a id='5068' tid='5067' class='m'>::</a><a id='5070' tid='5069' class='m'>sp</a>));
        } <a id='5072' tid='5071' class='m'>else</a> {  // &quot;mem&quot;
          <a id='5074' tid='5073' class='m'>int32_t</a> <a id='5076' tid='5075' class='m'>value</a>;
          <a id='5078' tid='5077' class='m'>if</a> (<a id='5080' tid='5079' class='m'>!</a><a id='5082' tid='5081' class='m'>GetValue</a>(<a id='5084' tid='5083' class='m'>arg1</a>, <a id='5086' tid='5085' class='m'>&</a><a id='5088' tid='5087' class='m'>value</a>)) {
            <a id='5090' tid='5089' class='m'>PrintF</a>(<a id='5092' tid='5091' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='5094' tid='5093' class='m'>arg1</a>);
            <a id='5096' tid='5095' class='m'>continue</a>;
          }
          <a id='5098' tid='5097' class='m'>cur</a> <a id='5100' tid='5099' class='m'>=</a> <a id='5102' tid='5101' class='m'>reinterpret_cast</a>&lt;<a id='5104' tid='5103' class='m'>int32_t</a><a id='5106' tid='5105' class='m'>*</a>&gt;(<a id='5108' tid='5107' class='m'>value</a>);
          <a id='5110' tid='5109' class='m'>next_arg</a><a id='5112' tid='5111' class='m'>++</a>;
        }

        <a id='5114' tid='5113' class='m'>int32_t</a> <a id='5116' tid='5115' class='m'>words</a>;
        <a id='5118' tid='5117' class='m'>if</a> (<a id='5120' tid='5119' class='m'>argc</a> <a id='5122' tid='5121' class='m'>==</a> <a id='5124' tid='5123' class='m'>next_arg</a>) {
          <a id='5126' tid='5125' class='m'>words</a> <a id='5128' tid='5127' class='m'>=</a> <a id='5130' tid='5129' class='m'>10</a>;
        } <a id='5132' tid='5131' class='m'>else</a> <a id='5134' tid='5133' class='m'>if</a> (<a id='5136' tid='5135' class='m'>argc</a> <a id='5138' tid='5137' class='m'>==</a> <a id='5140' tid='5139' class='m'>next_arg</a> <a id='5142' tid='5141' class='m'>+</a> <a id='5144' tid='5143' class='m'>1</a>) {
          <a id='5146' tid='5145' class='m'>if</a> (<a id='5148' tid='5147' class='m'>!</a><a id='5150' tid='5149' class='m'>GetValue</a>(<a id='5152' tid='5151' class='m'>argv</a>[<a id='5154' tid='5153' class='m'>next_arg</a>], <a id='5156' tid='5155' class='m'>&</a><a id='5158' tid='5157' class='m'>words</a>)) {
            <a id='5160' tid='5159' class='m'>words</a> <a id='5162' tid='5161' class='m'>=</a> <a id='5164' tid='5163' class='m'>10</a>;
          }
        }
        <a id='5166' tid='5165' class='m'>end</a> <a id='5168' tid='5167' class='m'>=</a> <a id='5170' tid='5169' class='m'>cur</a> <a id='5172' tid='5171' class='m'>+</a> <a id='5174' tid='5173' class='m'>words</a>;

        <a id='5176' tid='5175' class='m'>while</a> (<a id='5178' tid='5177' class='m'>cur</a> <a id='5180' tid='5179' class='m'>&lt;</a> <a id='5182' tid='5181' class='m'>end</a>) {
          <a id='5184' tid='5183' class='m'>PrintF</a>(<a id='5186' tid='5185' class='m'>&quot;  0x%08x:  0x%08x %10d&quot;</a>,
                 <a id='5188' tid='5187' class='m'>reinterpret_cast</a>&lt;<a id='5190' tid='5189' class='m'>intptr_t</a>&gt;(<a id='5192' tid='5191' class='m'>cur</a>), <a id='5194' tid='5193' class='m'>*</a><a id='5196' tid='5195' class='m'>cur</a>, <a id='5198' tid='5197' class='m'>*</a><a id='5200' tid='5199' class='m'>cur</a>);
          <a id='5202' tid='5201' class='m'>HeapObject</a><a id='5204' tid='5203' class='m'>*</a> <a id='5206' tid='5205' class='m'>obj</a> = <a id='5208' tid='5207' class='m'>reinterpret_cast</a>&lt;<a id='5210' tid='5209' class='m'>HeapObject</a><a id='5212' tid='5211' class='m'>*</a>&gt;(<a id='5214' tid='5213' class='m'>*</a><a id='5216' tid='5215' class='m'>cur</a>);
          <a id='5218' tid='5217' class='m'>int</a> <a id='5220' tid='5219' class='m'>value</a> = <a id='5222' tid='5221' class='m'>*</a><a id='5224' tid='5223' class='m'>cur</a>;
          <a id='5226' tid='5225' class='m'>Heap</a><a id='5228' tid='5227' class='m'>*</a> <a id='5230' tid='5229' class='m'>current_heap</a> = <a id='5232' tid='5231' class='m'>v8</a><a id='5234' tid='5233' class='m'>::</a><a id='5236' tid='5235' class='m'>internal</a><a id='5238' tid='5237' class='m'>::</a><a id='5240' tid='5239' class='m'>Isolate</a><a id='5242' tid='5241' class='m'>::</a><a id='5244' tid='5243' class='m'>Current</a>()-&gt;<a id='5246' tid='5245' class='m'>heap</a>();
          <a id='5248' tid='5247' class='m'>if</a> (<a id='5250' tid='5249' class='m'>current_heap</a>-&gt;<a id='5252' tid='5251' class='m'>Contains</a>(<a id='5254' tid='5253' class='m'>obj</a>) <a id='5256' tid='5255' class='m'>||</a> ((<a id='5258' tid='5257' class='m'>value</a> <a id='5260' tid='5259' class='m'>&</a> <a id='5262' tid='5261' class='m'>1</a>) <a id='5264' tid='5263' class='m'>==</a> <a id='5266' tid='5265' class='m'>0</a>)) {
            <a id='5268' tid='5267' class='m'>PrintF</a>(<a id='5270' tid='5269' class='m'>&quot; (&quot;</a>);
            <a id='5272' tid='5271' class='m'>if</a> ((<a id='5274' tid='5273' class='m'>value</a> <a id='5276' tid='5275' class='m'>&</a> <a id='5278' tid='5277' class='m'>1</a>) <a id='5280' tid='5279' class='m'>==</a> <a id='5282' tid='5281' class='m'>0</a>) {
              <a id='5284' tid='5283' class='m'>PrintF</a>(<a id='5286' tid='5285' class='m'>&quot;smi %d&quot;</a>, <a id='5288' tid='5287' class='m'>value</a> <a id='5290' tid='5289' class='m'>/</a> <a id='5292' tid='5291' class='m'>2</a>);
            } <a id='5294' tid='5293' class='m'>else</a> {
              <a id='5296' tid='5295' class='m'>obj</a>-&gt;<a id='5298' tid='5297' class='m'>ShortPrint</a>();
            }
            <a id='5300' tid='5299' class='m'>PrintF</a>(<a id='5302' tid='5301' class='m'>&quot;)&quot;</a>);
          }
          <a id='5304' tid='5303' class='m'>PrintF</a>(<a id='5306' tid='5305' class='m'>&quot;\n&quot;</a>);
          <a id='5308' tid='5307' class='m'>cur</a><a id='5310' tid='5309' class='m'>++</a>;
        }
      } <a id='5312' tid='5311' class='m'>else</a> <a id='5314' tid='5313' class='m'>if</a> (<a id='5316' tid='5315' class='m'>strcmp</a>(<a id='5318' tid='5317' class='m'>cmd</a>, <a id='5320' tid='5319' class='m'>&quot;disasm&quot;</a>) <span class='i'>==</span> <span class='i'>0</span> <a id='5322' tid='5321' class='m'>||</a> <a id='5324' tid='5323' class='m'>strcmp</a>(<a id='5326' tid='5325' class='m'>cmd</a>, <a id='5328' tid='5327' class='m'>&quot;di&quot;</a>) <span class='i'>==</span> <span class='i'>0</span>) {
        <a id='5330' tid='5329' class='m'>disasm</a><a id='5332' tid='5331' class='m'>::</a><a id='5334' tid='5333' class='m'>NameConverter</a> <a id='5336' tid='5335' class='m'>converter</a>;
        <a id='4432' tid='4431' class='m'>disasm</a><a id='4434' tid='4433' class='m'>::</a><a id='4436' tid='4435' class='m'>Disassembler</a> <a id='4438' tid='4437' class='m'>dasm</a>(<a id='4440' tid='4439' class='m'>converter</a>);
        // use a reasonably large buffer
        <a id='4046' tid='4045' class='m'>v8</a><a id='4048' tid='4047' class='m'>::</a><a id='4050' tid='4049' class='m'>internal</a><a id='4052' tid='4051' class='m'>::</a><a id='4054' tid='4053' class='m'>EmbeddedVector</a>&lt;<a id='4056' tid='4055' class='m'>char</a>, <a id='4058' tid='4057' class='m'>256</a>&gt; <a id='4060' tid='4059' class='m'>buffer</a>;

        <a id='3970' tid='3969' class='m'>byte</a><a id='3972' tid='3971' class='m'>*</a> <span class='i'>prev = NULL</span>;
        <a id='3754' tid='3753' class='m'>byte</a><a id='3756' tid='3755' class='m'>*</a> <a id='3758' tid='3757' class='m'>cur</a> = <a id='3760' tid='3759' class='m'>NULL</a>;
        <a id='3064' tid='3063' class='m'>byte</a><a id='3066' tid='3065' class='m'>*</a> <a id='3068' tid='3067' class='m'>end</a> = <a id='3070' tid='3069' class='m'>NULL</a>;

        <span class='i'>if</span> <span class='i'>(argc == 1)</span> {
          <a id='3384' tid='3383' class='m'>cur</a> <a id='3386' tid='3385' class='m'>=</a> <a id='3388' tid='3387' class='m'>reinterpret_cast</a>&lt;<a id='3390' tid='3389' class='m'>byte</a><a id='3392' tid='3391' class='m'>*</a>&gt;<span class='i'>(sim_-&gt;get_pc())</span>;
          <a id='3394' tid='3393' class='m'>end</a> <a id='3396' tid='3395' class='m'>=</a> <a id='3398' tid='3397' class='m'>cur</a> <a id='3400' tid='3399' class='m'>+</a> (<span class='i'>10</span> <span class='i'>*</span> <a id='3402' tid='3401' class='m'>Instruction</a><a id='3404' tid='3403' class='m'>::</a><a id='3406' tid='3405' class='m'>kInstrSize</a>);
        } <span class='i'>else</span> <span class='i'>if</span> <span class='i'>(argc == 2)</span> {
          <a id='3088' tid='3087' class='m'>int</a> <a id='3090' tid='3089' class='m'>regnum</a> = <a id='3092' tid='3091' class='m'>Registers</a><a id='3094' tid='3093' class='m'>::</a><a id='3096' tid='3095' class='m'>Number</a>(<a id='3098' tid='3097' class='m'>arg1</a>);
          <a id='3100' tid='3099' class='m'>if</a> (<span class='i'>regnum != kNoRegister</span> <span class='i'>||</span> <a id='3102' tid='3101' class='m'>strncmp</a>(<a id='3104' tid='3103' class='m'>arg1</a>, <a id='3106' tid='3105' class='m'>&quot;0x&quot;</a>, <a id='3108' tid='3107' class='m'>2</a>) <a id='3110' tid='3109' class='m'>==</a> <a id='3112' tid='3111' class='m'>0</a>) {
            // The argument is an address or a register name.
            <a id='3628' tid='3627' class='m'>int32_t</a> <a id='3630' tid='3629' class='m'>value</a>;
            <span class='i'>if</span> (<a id='2988' tid='2987' class='m'>GetValue</a>(<a id='2990' tid='2989' class='m'>arg1</a>, <a id='2992' tid='2991' class='m'>&</a><a id='2994' tid='2993' class='m'>value</a>)) {
              <span class='i'>cur</span> <span class='i'>=</span> <span class='i'>reinterpret_cast</span>&lt;<a id='3444' tid='3443' class='m'>byte</a><a id='3446' tid='3445' class='m'>*</a>&gt;<span class='i'>(value)</span>;
              // Disassemble 10 instructions at &lt;arg1&gt;.
              <a id='3114' tid='3113' class='m'>end</a> <a id='3116' tid='3115' class='m'>=</a> <a id='3118' tid='3117' class='m'>cur</a> <a id='3120' tid='3119' class='m'>+</a> (<a id='3122' tid='3121' class='m'>10</a> <a id='3124' tid='3123' class='m'>*</a> <a id='3126' tid='3125' class='m'>Instruction</a><a id='3128' tid='3127' class='m'>::</a><a id='3130' tid='3129' class='m'>kInstrSize</a>);
            }
          } <span class='i'>else</span> {
            // The argument is the number of instructions.
            <span class='i'>int32_t value;</span>
            <a id='3132' tid='3131' class='m'>if</a> (<a id='3134' tid='3133' class='m'>GetValue</a>(<a id='3136' tid='3135' class='m'>arg1</a>, <a id='3138' tid='3137' class='m'>&</a><a id='3140' tid='3139' class='m'>value</a>)) {
              <a id='3434' tid='3433' class='m'>cur</a> <a id='3436' tid='3435' class='m'>=</a> <a id='3438' tid='3437' class='m'>reinterpret_cast</a>&lt;<a id='3440' tid='3439' class='m'>byte</a><a id='3442' tid='3441' class='m'>*</a>&gt;<span class='i'>(sim_-&gt;get_pc())</span>;
              // Disassemble &lt;arg1&gt; instructions.
              <a id='2996' tid='2995' class='m'>end</a> <a id='2998' tid='2997' class='m'>=</a> <a id='3000' tid='2999' class='m'>cur</a> <a id='3002' tid='3001' class='m'>+</a> (<span class='i'>value</span> <span class='i'>*</span> <a id='3004' tid='3003' class='m'>Instruction</a><a id='3006' tid='3005' class='m'>::</a><a id='3008' tid='3007' class='m'>kInstrSize</a>);
            }
          }
        } <a id='3408' tid='3407' class='m'>else</a> {
          <span class='i'>int32_t value1;</span>
          <span class='i'>int32_t value2;</span>
          <span class='i'>if</span> (<a id='3142' tid='3141' class='m'>GetValue</a>(<a id='3144' tid='3143' class='m'>arg1</a>, <a id='3146' tid='3145' class='m'>&</a><a id='3148' tid='3147' class='m'>value1</a>) <a id='3150' tid='3149' class='m'>&&</a> <a id='3152' tid='3151' class='m'>GetValue</a>(<a id='3154' tid='3153' class='m'>arg2</a>, <a id='3156' tid='3155' class='m'>&</a><a id='3158' tid='3157' class='m'>value2</a>)) {
            <a id='3410' tid='3409' class='m'>cur</a> <a id='3412' tid='3411' class='m'>=</a> <a id='3414' tid='3413' class='m'>reinterpret_cast</a>&lt;<a id='3416' tid='3415' class='m'>byte</a><a id='3418' tid='3417' class='m'>*</a>&gt;<span class='i'>(value1)</span>;
            <a id='3420' tid='3419' class='m'>end</a> <a id='3422' tid='3421' class='m'>=</a> <a id='3424' tid='3423' class='m'>cur</a> <a id='3426' tid='3425' class='m'>+</a> (<span class='i'>value2</span> <span class='i'>*</span> <a id='3428' tid='3427' class='m'>Instruction</a><a id='3430' tid='3429' class='m'>::</a><a id='3432' tid='3431' class='m'>kInstrSize</a>);
          }
        }

        <a id='3072' tid='3071' class='m'>while</a> (<a id='3074' tid='3073' class='m'>cur</a> <a id='3076' tid='3075' class='m'>&lt;</a> <a id='3078' tid='3077' class='m'>end</a>) {
          <span class='i'>prev = cur;</span>
          <span class='i'>cur</span> <span class='i'>+=</span> <a id='3080' tid='3079' class='m'>dasm</a>.<a id='3082' tid='3081' class='m'>InstructionDecode</a>(<a id='3084' tid='3083' class='m'>buffer</a>, <a id='3086' tid='3085' class='m'>cur</a>);
          <a id='2910' tid='2909' class='m'>PrintF</a>(<a id='2912' tid='2911' class='m'>&quot;  0x%08x  %s\n&quot;</a>,
                 <a id='2914' tid='2913' class='m'>reinterpret_cast</a>&lt;<a id='2916' tid='2915' class='m'>intptr_t</a>&gt;<span class='i'>(prev)</span>, <a id='2918' tid='2917' class='m'>buffer</a>.<a id='2920' tid='2919' class='m'>start</a>());
        }
      } <a id='5338' tid='5337' class='m'>else</a> <a id='5340' tid='5339' class='m'>if</a> (<a id='5342' tid='5341' class='m'>strcmp</a>(<a id='5344' tid='5343' class='m'>cmd</a>, <a id='5346' tid='5345' class='m'>&quot;gdb&quot;</a>) <a id='5348' tid='5347' class='m'>==</a> <a id='5350' tid='5349' class='m'>0</a>) {
        <a id='5352' tid='5351' class='m'>PrintF</a>(<a id='5354' tid='5353' class='m'>&quot;relinquishing control to gdb\n&quot;</a>);
        <a id='5356' tid='5355' class='m'>v8</a><a id='5358' tid='5357' class='m'>::</a><a id='5360' tid='5359' class='m'>internal</a><a id='5362' tid='5361' class='m'>::</a><a id='5364' tid='5363' class='m'>OS</a><a id='5366' tid='5365' class='m'>::</a><a id='5368' tid='5367' class='m'>DebugBreak</a>();
        <a id='5370' tid='5369' class='m'>PrintF</a>(<a id='5372' tid='5371' class='m'>&quot;regaining control from gdb\n&quot;</a>);
      } <a id='5374' tid='5373' class='m'>else</a> <a id='5376' tid='5375' class='m'>if</a> (<a id='5378' tid='5377' class='m'>strcmp</a>(<a id='5380' tid='5379' class='m'>cmd</a>, <a id='5382' tid='5381' class='m'>&quot;break&quot;</a>) <a id='5384' tid='5383' class='m'>==</a> <a id='5386' tid='5385' class='m'>0</a>) {
        <a id='5388' tid='5387' class='m'>if</a> (<a id='5390' tid='5389' class='m'>argc</a> <a id='5392' tid='5391' class='m'>==</a> <a id='5394' tid='5393' class='m'>2</a>) {
          <a id='5396' tid='5395' class='m'>int32_t</a> <a id='5398' tid='5397' class='m'>value</a>;
          <a id='5400' tid='5399' class='m'>if</a> (<a id='5402' tid='5401' class='m'>GetValue</a>(<a id='5404' tid='5403' class='m'>arg1</a>, <a id='5406' tid='5405' class='m'>&</a><a id='5408' tid='5407' class='m'>value</a>)) {
            <a id='5410' tid='5409' class='m'>if</a> (<a id='5412' tid='5411' class='m'>!</a><a id='5414' tid='5413' class='m'>SetBreakpoint</a>(<a id='5416' tid='5415' class='m'>reinterpret_cast</a>&lt;<a id='5418' tid='5417' class='m'>Instruction</a><a id='5420' tid='5419' class='m'>*</a>&gt;(<a id='5422' tid='5421' class='m'>value</a>))) {
              <a id='5424' tid='5423' class='m'>PrintF</a>(<a id='5426' tid='5425' class='m'>&quot;setting breakpoint failed\n&quot;</a>);
            }
          } <a id='5428' tid='5427' class='m'>else</a> {
            <a id='5430' tid='5429' class='m'>PrintF</a>(<a id='5432' tid='5431' class='m'>&quot;%s unrecognized\n&quot;</a>, <a id='5434' tid='5433' class='m'>arg1</a>);
          }
        } <a id='5436' tid='5435' class='m'>else</a> {
          <a id='5438' tid='5437' class='m'>PrintF</a>(<a id='5440' tid='5439' class='m'>&quot;break &lt;address&gt;\n&quot;</a>);
        }
      } <a id='5442' tid='5441' class='m'>else</a> <a id='5444' tid='5443' class='m'>if</a> (<a id='5446' tid='5445' class='m'>strcmp</a>(<a id='5448' tid='5447' class='m'>cmd</a>, <a id='5450' tid='5449' class='m'>&quot;del&quot;</a>) <a id='5452' tid='5451' class='m'>==</a> <a id='5454' tid='5453' class='m'>0</a>) {
        <a id='5456' tid='5455' class='m'>if</a> (<a id='5458' tid='5457' class='m'>!</a><a id='5460' tid='5459' class='m'>DeleteBreakpoint</a>(<a id='5462' tid='5461' class='m'>NULL</a>)) {
          <a id='5464' tid='5463' class='m'>PrintF</a>(<a id='5466' tid='5465' class='m'>&quot;deleting breakpoint failed\n&quot;</a>);
        }
      } <a id='5468' tid='5467' class='m'>else</a> <span class='i'>if</span> (<a id='5470' tid='5469' class='m'>strcmp</a>(<a id='5472' tid='5471' class='m'>cmd</a>, <a id='5474' tid='5473' class='m'>&quot;flags&quot;</a>) <a id='5476' tid='5475' class='m'>==</a> <a id='5478' tid='5477' class='m'>0</a>) <span class='i'>{
        PrintF(&quot;N flag: %d; &quot;, sim_-&gt;n_flag_);
        PrintF(&quot;Z flag: %d; &quot;, sim_-&gt;z_flag_);
        PrintF(&quot;C flag: %d; &quot;, sim_-&gt;c_flag_);
        PrintF(&quot;V flag: %d\n&quot;, sim_-&gt;v_flag_);
        PrintF(&quot;INVALID OP flag: %d; &quot;, sim_-&gt;inv_op_vfp_flag_);
        PrintF(&quot;DIV BY ZERO flag: %d; &quot;, sim_-&gt;div_zero_vfp_flag_);
        PrintF(&quot;OVERFLOW flag: %d; &quot;, sim_-&gt;overflow_vfp_flag_);
        PrintF(&quot;UNDERFLOW flag: %d; &quot;, sim_-&gt;underflow_vfp_flag_);
        PrintF(&quot;INEXACT flag: %d;\n&quot;, sim_-&gt;inexact_vfp_flag_);
      }</span> <span class='i'>else</span> <a id='4062' tid='4061' class='m'>if</a> (<a id='4442' tid='4441' class='m'>strcmp</a>(<a id='4444' tid='4443' class='m'>cmd</a>, <a id='4446' tid='4445' class='m'>&quot;stop&quot;</a>) <a id='4448' tid='4447' class='m'>==</a> <a id='4450' tid='4449' class='m'>0</a>) {
        <a id='4064' tid='4063' class='m'>int32_t</a> <a id='4066' tid='4065' class='m'>value</a>;
        <a id='4068' tid='4067' class='m'>intptr_t</a> <a id='4070' tid='4069' class='m'>stop_pc</a> = <a id='4072' tid='4071' class='m'>sim_</a>-&gt;<a id='4074' tid='4073' class='m'>get_pc</a>() <a id='4076' tid='4075' class='m'>-</a> <a id='4078' tid='4077' class='m'>2</a> <a id='4080' tid='4079' class='m'>*</a> <a id='4082' tid='4081' class='m'>Instruction</a><a id='4084' tid='4083' class='m'>::</a><a id='4086' tid='4085' class='m'>kInstrSize</a>;
        <a id='4088' tid='4087' class='m'>Instruction</a><a id='4090' tid='4089' class='m'>*</a> <a id='4092' tid='4091' class='m'>stop_instr</a> = <a id='4094' tid='4093' class='m'>reinterpret_cast</a>&lt;<a id='4096' tid='4095' class='m'>Instruction</a><a id='4098' tid='4097' class='m'>*</a>&gt;(<a id='4100' tid='4099' class='m'>stop_pc</a>);
        <a id='4102' tid='4101' class='m'>Instruction</a><a id='4104' tid='4103' class='m'>*</a> <a id='4106' tid='4105' class='m'>msg_address</a> =
          <a id='4108' tid='4107' class='m'>reinterpret_cast</a>&lt;<a id='4110' tid='4109' class='m'>Instruction</a><a id='4112' tid='4111' class='m'>*</a>&gt;(<a id='4114' tid='4113' class='m'>stop_pc</a> <a id='4116' tid='4115' class='m'>+</a> <a id='4118' tid='4117' class='m'>Instruction</a><a id='4120' tid='4119' class='m'>::</a><a id='4122' tid='4121' class='m'>kInstrSize</a>);
        <a id='4124' tid='4123' class='m'>if</a> ((<a id='4126' tid='4125' class='m'>argc</a> <a id='4128' tid='4127' class='m'>==</a> <a id='4130' tid='4129' class='m'>2</a>) <a id='4132' tid='4131' class='m'>&&</a> (<a id='4134' tid='4133' class='m'>strcmp</a>(<a id='4136' tid='4135' class='m'>arg1</a>, <a id='4138' tid='4137' class='m'>&quot;unstop&quot;</a>) <a id='4140' tid='4139' class='m'>==</a> <a id='4142' tid='4141' class='m'>0</a>)) {
          // Remove the current stop.
          <span class='i'>if</span> <span class='i'>(sim_-&gt;isStopInstruction(stop_instr))</span> {
            <a id='4144' tid='4143' class='m'>stop_instr</a>-&gt;<a id='4146' tid='4145' class='m'>SetInstructionBits</a>(<a id='4148' tid='4147' class='m'>kNopInstr</a>);
            <a id='4150' tid='4149' class='m'>msg_address</a>-&gt;<a id='4152' tid='4151' class='m'>SetInstructionBits</a>(<a id='4154' tid='4153' class='m'>kNopInstr</a>);
          } <a id='3762' tid='3761' class='m'>else</a> {
            <a id='3764' tid='3763' class='m'>PrintF</a>(<a id='3766' tid='3765' class='m'>&quot;Not at debugger stop.\n&quot;</a>);
          }
        } <a id='4156' tid='4155' class='m'>else</a> <a id='4158' tid='4157' class='m'>if</a> (<a id='4160' tid='4159' class='m'>argc</a> <a id='4162' tid='4161' class='m'>==</a> <a id='4164' tid='4163' class='m'>3</a>) {
          // Print information about all/the specified breakpoint(s).
          <a id='4166' tid='4165' class='m'>if</a> (<a id='4168' tid='4167' class='m'>strcmp</a>(<a id='4170' tid='4169' class='m'>arg1</a>, <a id='4172' tid='4171' class='m'>&quot;info&quot;</a>) <a id='4174' tid='4173' class='m'>==</a> <a id='4176' tid='4175' class='m'>0</a>) {
            <a id='4178' tid='4177' class='m'>if</a> (<a id='4180' tid='4179' class='m'>strcmp</a>(<a id='4182' tid='4181' class='m'>arg2</a>, <a id='4184' tid='4183' class='m'>&quot;all&quot;</a>) <a id='4186' tid='4185' class='m'>==</a> <a id='4188' tid='4187' class='m'>0</a>) {
              <a id='4190' tid='4189' class='m'>PrintF</a>(<a id='4192' tid='4191' class='m'>&quot;Stop information:\n&quot;</a>);
              <a id='4194' tid='4193' class='m'>for</a> (<span class='i'>uint32_t i = 0</span>; <span class='i'>i &lt; sim_-&gt;kNumOfWatchedStops</span>; <a id='4196' tid='4195' class='m'>i</a><a id='4198' tid='4197' class='m'>++</a>) {
                <a id='4200' tid='4199' class='m'>sim_</a>-&gt;<a id='4202' tid='4201' class='m'>PrintStopInfo</a>(<a id='4204' tid='4203' class='m'>i</a>);
              }
            } <a id='4206' tid='4205' class='m'>else</a> <a id='4208' tid='4207' class='m'>if</a> (<a id='4210' tid='4209' class='m'>GetValue</a>(<a id='4212' tid='4211' class='m'>arg2</a>, <a id='4214' tid='4213' class='m'>&</a><a id='4216' tid='4215' class='m'>value</a>)) {
              <a id='4218' tid='4217' class='m'>sim_</a>-&gt;<a id='4220' tid='4219' class='m'>PrintStopInfo</a>(<a id='4222' tid='4221' class='m'>value</a>);
            } <a id='4224' tid='4223' class='m'>else</a> {
              <a id='4226' tid='4225' class='m'>PrintF</a>(<a id='4228' tid='4227' class='m'>&quot;Unrecognized argument.\n&quot;</a>);
            }
          } <a id='4230' tid='4229' class='m'>else</a> <a id='4232' tid='4231' class='m'>if</a> (<a id='4234' tid='4233' class='m'>strcmp</a>(<a id='4236' tid='4235' class='m'>arg1</a>, <a id='4238' tid='4237' class='m'>&quot;enable&quot;</a>) <a id='4240' tid='4239' class='m'>==</a> <a id='4242' tid='4241' class='m'>0</a>) {
            // Enable all/the specified breakpoint(s).
            <a id='4244' tid='4243' class='m'>if</a> (<a id='4246' tid='4245' class='m'>strcmp</a>(<a id='4248' tid='4247' class='m'>arg2</a>, <a id='4250' tid='4249' class='m'>&quot;all&quot;</a>) <a id='4252' tid='4251' class='m'>==</a> <a id='4254' tid='4253' class='m'>0</a>) {
              <a id='4256' tid='4255' class='m'>for</a> (<span class='i'>uint32_t i = 0</span>; <span class='i'>i &lt; sim_-&gt;kNumOfWatchedStops</span>; <a id='4258' tid='4257' class='m'>i</a><a id='4260' tid='4259' class='m'>++</a>) {
                <a id='4262' tid='4261' class='m'>sim_</a>-&gt;<a id='4264' tid='4263' class='m'>EnableStop</a>(<a id='4266' tid='4265' class='m'>i</a>);
              }
            } <a id='4268' tid='4267' class='m'>else</a> <a id='4270' tid='4269' class='m'>if</a> (<a id='4272' tid='4271' class='m'>GetValue</a>(<a id='4274' tid='4273' class='m'>arg2</a>, <a id='4276' tid='4275' class='m'>&</a><a id='4278' tid='4277' class='m'>value</a>)) {
              <a id='4280' tid='4279' class='m'>sim_</a>-&gt;<a id='4282' tid='4281' class='m'>EnableStop</a>(<a id='4284' tid='4283' class='m'>value</a>);
            } <a id='4286' tid='4285' class='m'>else</a> {
              <a id='4288' tid='4287' class='m'>PrintF</a>(<a id='4290' tid='4289' class='m'>&quot;Unrecognized argument.\n&quot;</a>);
            }
          } <a id='4292' tid='4291' class='m'>else</a> <a id='4294' tid='4293' class='m'>if</a> (<a id='4296' tid='4295' class='m'>strcmp</a>(<a id='4298' tid='4297' class='m'>arg1</a>, <a id='4300' tid='4299' class='m'>&quot;disable&quot;</a>) <a id='4302' tid='4301' class='m'>==</a> <a id='4304' tid='4303' class='m'>0</a>) {
            // Disable all/the specified breakpoint(s).
            <a id='4306' tid='4305' class='m'>if</a> (<a id='4308' tid='4307' class='m'>strcmp</a>(<a id='4310' tid='4309' class='m'>arg2</a>, <a id='4312' tid='4311' class='m'>&quot;all&quot;</a>) <a id='4314' tid='4313' class='m'>==</a> <a id='4316' tid='4315' class='m'>0</a>) {
              <a id='4318' tid='4317' class='m'>for</a> (<span class='i'>uint32_t i = 0</span>; <span class='i'>i &lt; sim_-&gt;kNumOfWatchedStops</span>; <a id='4320' tid='4319' class='m'>i</a><a id='4322' tid='4321' class='m'>++</a>) {
                <a id='4324' tid='4323' class='m'>sim_</a>-&gt;<a id='4326' tid='4325' class='m'>DisableStop</a>(<a id='4328' tid='4327' class='m'>i</a>);
              }
            } <a id='4330' tid='4329' class='m'>else</a> <a id='4332' tid='4331' class='m'>if</a> (<a id='4334' tid='4333' class='m'>GetValue</a>(<a id='4336' tid='4335' class='m'>arg2</a>, <a id='4338' tid='4337' class='m'>&</a><a id='4340' tid='4339' class='m'>value</a>)) {
              <a id='4342' tid='4341' class='m'>sim_</a>-&gt;<a id='4344' tid='4343' class='m'>DisableStop</a>(<a id='4346' tid='4345' class='m'>value</a>);
            } <a id='4348' tid='4347' class='m'>else</a> {
              <a id='4350' tid='4349' class='m'>PrintF</a>(<a id='4352' tid='4351' class='m'>&quot;Unrecognized argument.\n&quot;</a>);
            }
          }
        } <a id='4354' tid='4353' class='m'>else</a> {
          <a id='4356' tid='4355' class='m'>PrintF</a>(<a id='4358' tid='4357' class='m'>&quot;Wrong usage. Use help command for more information.\n&quot;</a>);
        }
      } <a id='4360' tid='4359' class='m'>else</a> <span class='i'>if</span> <span class='i'>((strcmp(cmd, &quot;t&quot;) == 0) || strcmp(cmd, &quot;trace&quot;) == 0)</span> <span class='i'>{
        ::v8::internal::FLAG_trace_sim = !::v8::internal::FLAG_trace_sim;
        PrintF(&quot;Trace of executed instructions is %s\n&quot;,
               ::v8::internal::FLAG_trace_sim ? &quot;on&quot; : &quot;off&quot;);
      }</span> <a id='4362' tid='4361' class='m'>else</a> <a id='4364' tid='4363' class='m'>if</a> ((<a id='4366' tid='4365' class='m'>strcmp</a>(<a id='4368' tid='4367' class='m'>cmd</a>, <a id='4370' tid='4369' class='m'>&quot;h&quot;</a>) <a id='4372' tid='4371' class='m'>==</a> <a id='4374' tid='4373' class='m'>0</a>) <a id='4376' tid='4375' class='m'>||</a> (<a id='4378' tid='4377' class='m'>strcmp</a>(<a id='4380' tid='4379' class='m'>cmd</a>, <a id='4382' tid='4381' class='m'>&quot;help&quot;</a>) <a id='4384' tid='4383' class='m'>==</a> <a id='4386' tid='4385' class='m'>0</a>)) {
        <a id='4388' tid='4387' class='m'>PrintF</a>(<a id='4390' tid='4389' class='m'>&quot;cont\n&quot;</a>);
        <a id='3974' tid='3973' class='m'>PrintF</a>(<a id='3976' tid='3975' class='m'>&quot;  continue execution (alias &#39;c&#39;)\n&quot;</a>);
        <a id='3768' tid='3767' class='m'>PrintF</a>(<a id='3770' tid='3769' class='m'>&quot;stepi\n&quot;</a>);
        <a id='3632' tid='3631' class='m'>PrintF</a>(<a id='3634' tid='3633' class='m'>&quot;  step one instruction (alias &#39;si&#39;)\n&quot;</a>);
        <a id='3448' tid='3447' class='m'>PrintF</a>(<a id='3450' tid='3449' class='m'>&quot;print &lt;register&gt;\n&quot;</a>);
        <a id='3160' tid='3159' class='m'>PrintF</a>(<a id='3162' tid='3161' class='m'>&quot;  print register content (alias &#39;p&#39;)\n&quot;</a>);
        <a id='3010' tid='3009' class='m'>PrintF</a>(<a id='3012' tid='3011' class='m'>&quot;  use register name &#39;all&#39; to print all registers\n&quot;</a>);
        <span class='i'>PrintF(&quot;  add argument &#39;fp&#39; to print register pair double values\n&quot;);</span>
        <a id='2922' tid='2921' class='m'>PrintF</a>(<a id='2924' tid='2923' class='m'>&quot;printobject &lt;register&gt;\n&quot;</a>);
        <a id='2612' tid='2611' class='m'>PrintF</a>(<a id='2614' tid='2613' class='m'>&quot;  print an object from a register (alias &#39;po&#39;)\n&quot;</a>);
        <a id='2552' tid='2551' class='m'>PrintF</a>(<a id='2554' tid='2553' class='m'>&quot;flags\n&quot;</a>);
        <a id='2496' tid='2495' class='m'>PrintF</a>(<a id='2498' tid='2497' class='m'>&quot;  print flags\n&quot;</a>);
        <a id='2434' tid='2433' class='m'>PrintF</a>(<a id='2436' tid='2435' class='m'>&quot;stack [&lt;words&gt;]\n&quot;</a>);
        <a id='2386' tid='2385' class='m'>PrintF</a>(<a id='2388' tid='2387' class='m'>&quot;  dump stack content, default dump 10 words)\n&quot;</a>);
        <a id='2364' tid='2363' class='m'>PrintF</a>(<a id='2366' tid='2365' class='m'>&quot;mem &lt;address&gt; [&lt;words&gt;]\n&quot;</a>);
        <a id='2296' tid='2295' class='m'>PrintF</a>(<a id='2298' tid='2297' class='m'>&quot;  dump memory content, default dump 10 words)\n&quot;</a>);
        <a id='2272' tid='2271' class='m'>PrintF</a>(<a id='2274' tid='2273' class='m'>&quot;disasm [&lt;instructions&gt;]\n&quot;</a>);
        <a id='2232' tid='2231' class='m'>PrintF</a>(<a id='2234' tid='2233' class='m'>&quot;disasm [&lt;address/register&gt;]\n&quot;</a>);
        <a id='2214' tid='2213' class='m'>PrintF</a>(<a id='2216' tid='2215' class='m'>&quot;disasm [[&lt;address/register&gt;] &lt;instructions&gt;]\n&quot;</a>);
        <a id='2204' tid='2203' class='m'>PrintF</a>(<a id='2206' tid='2205' class='m'>&quot;  disassemble code, default is 10 instructions\n&quot;</a>);
        <a id='2162' tid='2161' class='m'>PrintF</a>(<a id='2164' tid='2163' class='m'>&quot;  from pc (alias &#39;di&#39;)\n&quot;</a>);
        <a id='2136' tid='2135' class='m'>PrintF</a>(<a id='2138' tid='2137' class='m'>&quot;gdb\n&quot;</a>);
        <a id='2094' tid='2093' class='m'>PrintF</a>(<a id='2096' tid='2095' class='m'>&quot;  enter gdb\n&quot;</a>);
        <a id='2040' tid='2039' class='m'>PrintF</a>(<a id='2042' tid='2041' class='m'>&quot;break &lt;address&gt;\n&quot;</a>);
        <a id='1988' tid='1987' class='m'>PrintF</a>(<a id='1990' tid='1989' class='m'>&quot;  set a break point on the address\n&quot;</a>);
        <a id='1928' tid='1927' class='m'>PrintF</a>(<a id='1930' tid='1929' class='m'>&quot;del\n&quot;</a>);
        <a id='1868' tid='1867' class='m'>PrintF</a>(<a id='1870' tid='1869' class='m'>&quot;  delete the breakpoint\n&quot;</a>);
        <span class='i'>PrintF(&quot;trace (alias &#39;t&#39;)\n&quot;);</span>
        <span class='i'>PrintF(&quot;  toogle the tracing of all executed statements\n&quot;);</span>
        <a id='1818' tid='1817' class='m'>PrintF</a>(<a id='1820' tid='1819' class='m'>&quot;stop feature:\n&quot;</a>);
        <a id='1748' tid='1747' class='m'>PrintF</a>(<a id='1750' tid='1749' class='m'>&quot;  Description:\n&quot;</a>);
        <a id='1684' tid='1683' class='m'>PrintF</a>(<a id='1686' tid='1685' class='m'>&quot;    Stops are debug instructions inserted by\n&quot;</a>);
        <a id='1650' tid='1649' class='m'>PrintF</a>(<a id='1652' tid='1651' class='m'>&quot;    the Assembler::stop() function.\n&quot;</a>);
        <a id='1614' tid='1613' class='m'>PrintF</a>(<a id='1616' tid='1615' class='m'>&quot;    When hitting a stop, the Simulator will\n&quot;</a>);
        <span class='i'>PrintF(&quot;    stop and and give control to the ArmDebugger.\n&quot;);</span>
        <span class='i'>PrintF(&quot;    The first %d stop codes are watched:\n&quot;,
               Simulator::kNumOfWatchedStops);</span>
        <a id='1552' tid='1551' class='m'>PrintF</a>(<a id='1554' tid='1553' class='m'>&quot;    - They can be enabled / disabled: the Simulator\n&quot;</a>);
        <span class='i'>PrintF(&quot;      will / won&#39;t stop when hitting them.\n&quot;);</span>
        <a id='1510' tid='1509' class='m'>PrintF</a>(<a id='1512' tid='1511' class='m'>&quot;    - The Simulator keeps track of how many times they \n&quot;</a>);
        <a id='1496' tid='1495' class='m'>PrintF</a>(<a id='1498' tid='1497' class='m'>&quot;      are met. (See the info command.) Going over a\n&quot;</a>);
        <a id='1480' tid='1479' class='m'>PrintF</a>(<a id='1482' tid='1481' class='m'>&quot;      disabled stop still increases its counter. \n&quot;</a>);
        <a id='1442' tid='1441' class='m'>PrintF</a>(<a id='1444' tid='1443' class='m'>&quot;  Commands:\n&quot;</a>);
        <a id='1406' tid='1405' class='m'>PrintF</a>(<a id='1408' tid='1407' class='m'>&quot;    stop info all/&lt;code&gt; : print infos about number &lt;code&gt;\n&quot;</a>);
        <a id='1378' tid='1377' class='m'>PrintF</a>(<a id='1380' tid='1379' class='m'>&quot;      or all stop(s).\n&quot;</a>);
        <a id='1352' tid='1351' class='m'>PrintF</a>(<a id='1354' tid='1353' class='m'>&quot;    stop enable/disable all/&lt;code&gt; : enables / disables\n&quot;</a>);
        <a id='1322' tid='1321' class='m'>PrintF</a>(<a id='1324' tid='1323' class='m'>&quot;      all or number &lt;code&gt; stop(s)\n&quot;</a>);
        <a id='1270' tid='1269' class='m'>PrintF</a>(<a id='1272' tid='1271' class='m'>&quot;    stop unstop\n&quot;</a>);
        <a id='1190' tid='1189' class='m'>PrintF</a>(<a id='1192' tid='1191' class='m'>&quot;      ignore the stop instruction at the current location\n&quot;</a>);
        <a id='1150' tid='1149' class='m'>PrintF</a>(<a id='1152' tid='1151' class='m'>&quot;      from now on\n&quot;</a>);
      } <a id='4392' tid='4391' class='m'>else</a> {
        <a id='4394' tid='4393' class='m'>PrintF</a>(<a id='4396' tid='4395' class='m'>&quot;Unknown command: %s\n&quot;</a>, <a id='4398' tid='4397' class='m'>cmd</a>);
      }
    }
    <a id='5480' tid='5479' class='m'>DeleteArray</a>(<a id='5482' tid='5481' class='m'>line</a>);
  }

  // Add all the breakpoints back to stop execution and enter the debugger
  // shell when hit.
  <a id='5484' tid='5483' class='m'>RedoBreakpoints</a>();

#<a id='5486' tid='5485' class='m'>undef</a> <a id='5488' tid='5487' class='m'>COMMAND_SIZE</a>
#<a id='5490' tid='5489' class='m'>undef</a> <a id='5492' tid='5491' class='m'>ARG_SIZE</a>

#<a id='5494' tid='5493' class='m'>undef</a> <a id='5496' tid='5495' class='m'>STR</a>
#<a id='5498' tid='5497' class='m'>undef</a> <a id='5500' tid='5499' class='m'>XSTR</a>
}


<a id='4452' tid='4451' class='m'>static</a> <a id='4454' tid='4453' class='m'>bool</a> <a id='4456' tid='4455' class='m'>ICacheMatch</a>(<a id='4458' tid='4457' class='m'>void</a><a id='4460' tid='4459' class='m'>*</a> <a id='4462' tid='4461' class='m'>one</a>, <a id='4464' tid='4463' class='m'>void</a><a id='4466' tid='4465' class='m'>*</a> <a id='4468' tid='4467' class='m'>two</a>) {
  <a id='4470' tid='4469' class='m'>ASSERT</a>((<a id='4472' tid='4471' class='m'>reinterpret_cast</a>&lt;<a id='4474' tid='4473' class='m'>intptr_t</a>&gt;(<a id='4476' tid='4475' class='m'>one</a>) <a id='4478' tid='4477' class='m'>&</a> <a id='4480' tid='4479' class='m'>CachePage</a><a id='4482' tid='4481' class='m'>::</a><a id='4484' tid='4483' class='m'>kPageMask</a>) <a id='4486' tid='4485' class='m'>==</a> <a id='4488' tid='4487' class='m'>0</a>);
  <a id='4490' tid='4489' class='m'>ASSERT</a>((<a id='4492' tid='4491' class='m'>reinterpret_cast</a>&lt;<a id='4494' tid='4493' class='m'>intptr_t</a>&gt;(<a id='4496' tid='4495' class='m'>two</a>) <a id='4498' tid='4497' class='m'>&</a> <a id='4500' tid='4499' class='m'>CachePage</a><a id='4502' tid='4501' class='m'>::</a><a id='4504' tid='4503' class='m'>kPageMask</a>) <a id='4506' tid='4505' class='m'>==</a> <a id='4508' tid='4507' class='m'>0</a>);
  <a id='4510' tid='4509' class='m'>return</a> <a id='4512' tid='4511' class='m'>one</a> <a id='4514' tid='4513' class='m'>==</a> <a id='4516' tid='4515' class='m'>two</a>;
}


<a id='4400' tid='4399' class='m'>static</a> <a id='4402' tid='4401' class='m'>uint32_t</a> <a id='4404' tid='4403' class='m'>ICacheHash</a>(<a id='4406' tid='4405' class='m'>void</a><a id='4408' tid='4407' class='m'>*</a> <a id='4410' tid='4409' class='m'>key</a>) {
  <a id='4412' tid='4411' class='m'>return</a> <a id='4414' tid='4413' class='m'>static_cast</a>&lt;<a id='4416' tid='4415' class='m'>uint32_t</a>&gt;(<a id='4418' tid='4417' class='m'>reinterpret_cast</a>&lt;<a id='4420' tid='4419' class='m'>uintptr_t</a>&gt;(<a id='4422' tid='4421' class='m'>key</a>)) <a id='4424' tid='4423' class='m'>&gt;&gt;</a> <a id='4426' tid='4425' class='m'>2</a>;
}


<a id='3978' tid='3977' class='m'>static</a> <a id='3980' tid='3979' class='m'>bool</a> <a id='3982' tid='3981' class='m'>AllOnOnePage</a>(<a id='3984' tid='3983' class='m'>uintptr_t</a> <a id='3986' tid='3985' class='m'>start</a>, <a id='3988' tid='3987' class='m'>int</a> <a id='3990' tid='3989' class='m'>size</a>) {
  <a id='3992' tid='3991' class='m'>intptr_t</a> <a id='3994' tid='3993' class='m'>start_page</a> = (<a id='3996' tid='3995' class='m'>start</a> <a id='3998' tid='3997' class='m'>&</a> <a id='4000' tid='3999' class='m'>~</a><a id='4002' tid='4001' class='m'>CachePage</a><a id='4004' tid='4003' class='m'>::</a><a id='4006' tid='4005' class='m'>kPageMask</a>);
  <a id='4008' tid='4007' class='m'>intptr_t</a> <a id='4010' tid='4009' class='m'>end_page</a> = ((<a id='4012' tid='4011' class='m'>start</a> <a id='4014' tid='4013' class='m'>+</a> <a id='4016' tid='4015' class='m'>size</a>) <a id='4018' tid='4017' class='m'>&</a> <a id='4020' tid='4019' class='m'>~</a><a id='4022' tid='4021' class='m'>CachePage</a><a id='4024' tid='4023' class='m'>::</a><a id='4026' tid='4025' class='m'>kPageMask</a>);
  <a id='4028' tid='4027' class='m'>return</a> <a id='4030' tid='4029' class='m'>start_page</a> <a id='4032' tid='4031' class='m'>==</a> <a id='4034' tid='4033' class='m'>end_page</a>;
}


<a id='3772' tid='3771' class='m'>void</a> <a id='3774' tid='3773' class='m'>Simulator</a><a id='3776' tid='3775' class='m'>::</a><a id='3778' tid='3777' class='m'>FlushICache</a>(<a id='3780' tid='3779' class='m'>v8</a><a id='3782' tid='3781' class='m'>::</a><a id='3784' tid='3783' class='m'>internal</a><a id='3786' tid='3785' class='m'>::</a><a id='3788' tid='3787' class='m'>HashMap</a><a id='3790' tid='3789' class='m'>*</a> <a id='3792' tid='3791' class='m'>i_cache</a>,
                            <a id='3794' tid='3793' class='m'>void</a><a id='3796' tid='3795' class='m'>*</a> <a id='3798' tid='3797' class='m'>start_addr</a>,
                            <a id='3800' tid='3799' class='m'>size_t</a> <a id='3802' tid='3801' class='m'>size</a>) {
  <a id='3804' tid='3803' class='m'>intptr_t</a> <a id='3806' tid='3805' class='m'>start</a> = <a id='3808' tid='3807' class='m'>reinterpret_cast</a>&lt;<a id='3810' tid='3809' class='m'>intptr_t</a>&gt;(<a id='3812' tid='3811' class='m'>start_addr</a>);
  <a id='3814' tid='3813' class='m'>int</a> <a id='3816' tid='3815' class='m'>intra_line</a> = (<a id='3818' tid='3817' class='m'>start</a> <a id='3820' tid='3819' class='m'>&</a> <a id='3822' tid='3821' class='m'>CachePage</a><a id='3824' tid='3823' class='m'>::</a><a id='3826' tid='3825' class='m'>kLineMask</a>);
  <a id='3828' tid='3827' class='m'>start</a> <a id='3830' tid='3829' class='m'>-=</a> <a id='3832' tid='3831' class='m'>intra_line</a>;
  <a id='3834' tid='3833' class='m'>size</a> <a id='3836' tid='3835' class='m'>+=</a> <a id='3838' tid='3837' class='m'>intra_line</a>;
  <a id='3840' tid='3839' class='m'>size</a> <a id='3842' tid='3841' class='m'>=</a> ((<a id='3844' tid='3843' class='m'>size</a> <a id='3846' tid='3845' class='m'>-</a> <a id='3848' tid='3847' class='m'>1</a>) <a id='3850' tid='3849' class='m'>|</a> <a id='3852' tid='3851' class='m'>CachePage</a><a id='3854' tid='3853' class='m'>::</a><a id='3856' tid='3855' class='m'>kLineMask</a>) <a id='3858' tid='3857' class='m'>+</a> <a id='3860' tid='3859' class='m'>1</a>;
  <a id='3862' tid='3861' class='m'>int</a> <a id='3864' tid='3863' class='m'>offset</a> = (<a id='3866' tid='3865' class='m'>start</a> <a id='3868' tid='3867' class='m'>&</a> <a id='3870' tid='3869' class='m'>CachePage</a><a id='3872' tid='3871' class='m'>::</a><a id='3874' tid='3873' class='m'>kPageMask</a>);
  <a id='3876' tid='3875' class='m'>while</a> (<a id='3878' tid='3877' class='m'>!</a><a id='3880' tid='3879' class='m'>AllOnOnePage</a>(<a id='3882' tid='3881' class='m'>start</a>, <a id='3884' tid='3883' class='m'>size</a> <a id='3886' tid='3885' class='m'>-</a> <a id='3888' tid='3887' class='m'>1</a>)) {
    <a id='3890' tid='3889' class='m'>int</a> <a id='3892' tid='3891' class='m'>bytes_to_flush</a> = <a id='3894' tid='3893' class='m'>CachePage</a><a id='3896' tid='3895' class='m'>::</a><a id='3898' tid='3897' class='m'>kPageSize</a> <a id='3900' tid='3899' class='m'>-</a> <a id='3902' tid='3901' class='m'>offset</a>;
    <a id='3904' tid='3903' class='m'>FlushOnePage</a>(<a id='3906' tid='3905' class='m'>i_cache</a>, <a id='3908' tid='3907' class='m'>start</a>, <a id='3910' tid='3909' class='m'>bytes_to_flush</a>);
    <a id='3912' tid='3911' class='m'>start</a> <a id='3914' tid='3913' class='m'>+=</a> <a id='3916' tid='3915' class='m'>bytes_to_flush</a>;
    <a id='3918' tid='3917' class='m'>size</a> <a id='3920' tid='3919' class='m'>-=</a> <a id='3922' tid='3921' class='m'>bytes_to_flush</a>;
    <a id='3924' tid='3923' class='m'>ASSERT_EQ</a>(<a id='3926' tid='3925' class='m'>0</a>, <a id='3928' tid='3927' class='m'>start</a> <a id='3930' tid='3929' class='m'>&</a> <a id='3932' tid='3931' class='m'>CachePage</a><a id='3934' tid='3933' class='m'>::</a><a id='3936' tid='3935' class='m'>kPageMask</a>);
    <a id='3938' tid='3937' class='m'>offset</a> <a id='3940' tid='3939' class='m'>=</a> <a id='3942' tid='3941' class='m'>0</a>;
  }
  <a id='3944' tid='3943' class='m'>if</a> (<a id='3946' tid='3945' class='m'>size</a> <a id='3948' tid='3947' class='m'>!=</a> <a id='3950' tid='3949' class='m'>0</a>) {
    <a id='3952' tid='3951' class='m'>FlushOnePage</a>(<a id='3954' tid='3953' class='m'>i_cache</a>, <a id='3956' tid='3955' class='m'>start</a>, <a id='3958' tid='3957' class='m'>size</a>);
  }
}


<a id='3636' tid='3635' class='m'>CachePage</a><a id='3638' tid='3637' class='m'>*</a> <a id='3640' tid='3639' class='m'>Simulator</a><a id='3642' tid='3641' class='m'>::</a><a id='3644' tid='3643' class='m'>GetCachePage</a>(<a id='3646' tid='3645' class='m'>v8</a><a id='3648' tid='3647' class='m'>::</a><a id='3650' tid='3649' class='m'>internal</a><a id='3652' tid='3651' class='m'>::</a><a id='3654' tid='3653' class='m'>HashMap</a><a id='3656' tid='3655' class='m'>*</a> <a id='3658' tid='3657' class='m'>i_cache</a>, <a id='3660' tid='3659' class='m'>void</a><a id='3662' tid='3661' class='m'>*</a> <a id='3664' tid='3663' class='m'>page</a>) {
  <a id='3666' tid='3665' class='m'>v8</a><a id='3668' tid='3667' class='m'>::</a><a id='3670' tid='3669' class='m'>internal</a><a id='3672' tid='3671' class='m'>::</a><a id='3674' tid='3673' class='m'>HashMap</a><a id='3676' tid='3675' class='m'>::</a><a id='3678' tid='3677' class='m'>Entry</a><a id='3680' tid='3679' class='m'>*</a> <a id='3682' tid='3681' class='m'>entry</a> = <a id='3684' tid='3683' class='m'>i_cache</a>-&gt;<a id='3686' tid='3685' class='m'>Lookup</a>(<a id='3688' tid='3687' class='m'>page</a>,
                                                        <a id='3690' tid='3689' class='m'>ICacheHash</a>(<a id='3692' tid='3691' class='m'>page</a>),
                                                        <a id='3694' tid='3693' class='m'>true</a>);
  <a id='3696' tid='3695' class='m'>if</a> (<a id='3698' tid='3697' class='m'>entry</a>-&gt;<a id='3700' tid='3699' class='m'>value</a> <a id='3702' tid='3701' class='m'>==</a> <a id='3704' tid='3703' class='m'>NULL</a>) {
    <a id='3706' tid='3705' class='m'>CachePage</a><a id='3708' tid='3707' class='m'>*</a> <a id='3710' tid='3709' class='m'>new_page</a> = <a id='3712' tid='3711' class='m'>new</a> <a id='3714' tid='3713' class='m'>CachePage</a>();
    <a id='3716' tid='3715' class='m'>entry</a>-&gt;<a id='3718' tid='3717' class='m'>value</a> <a id='3720' tid='3719' class='m'>=</a> <a id='3722' tid='3721' class='m'>new_page</a>;
  }
  <a id='3724' tid='3723' class='m'>return</a> <a id='3726' tid='3725' class='m'>reinterpret_cast</a>&lt;<a id='3728' tid='3727' class='m'>CachePage</a><a id='3730' tid='3729' class='m'>*</a>&gt;(<a id='3732' tid='3731' class='m'>entry</a>-&gt;<a id='3734' tid='3733' class='m'>value</a>);
}


// Flush from start up to and not including start + size.
<a id='3452' tid='3451' class='m'>void</a> <a id='3454' tid='3453' class='m'>Simulator</a><a id='3456' tid='3455' class='m'>::</a><a id='3458' tid='3457' class='m'>FlushOnePage</a>(<a id='3460' tid='3459' class='m'>v8</a><a id='3462' tid='3461' class='m'>::</a><a id='3464' tid='3463' class='m'>internal</a><a id='3466' tid='3465' class='m'>::</a><a id='3468' tid='3467' class='m'>HashMap</a><a id='3470' tid='3469' class='m'>*</a> <a id='3472' tid='3471' class='m'>i_cache</a>,
                             <a id='3474' tid='3473' class='m'>intptr_t</a> <a id='3476' tid='3475' class='m'>start</a>,
                             <a id='3478' tid='3477' class='m'>int</a> <a id='3480' tid='3479' class='m'>size</a>) {
  <a id='3482' tid='3481' class='m'>ASSERT</a>(<a id='3484' tid='3483' class='m'>size</a> <a id='3486' tid='3485' class='m'>&lt;=</a> <a id='3488' tid='3487' class='m'>CachePage</a><a id='3490' tid='3489' class='m'>::</a><a id='3492' tid='3491' class='m'>kPageSize</a>);
  <a id='3494' tid='3493' class='m'>ASSERT</a>(<a id='3496' tid='3495' class='m'>AllOnOnePage</a>(<a id='3498' tid='3497' class='m'>start</a>, <a id='3500' tid='3499' class='m'>size</a> <a id='3502' tid='3501' class='m'>-</a> <a id='3504' tid='3503' class='m'>1</a>));
  <a id='3506' tid='3505' class='m'>ASSERT</a>((<a id='3508' tid='3507' class='m'>start</a> <a id='3510' tid='3509' class='m'>&</a> <a id='3512' tid='3511' class='m'>CachePage</a><a id='3514' tid='3513' class='m'>::</a><a id='3516' tid='3515' class='m'>kLineMask</a>) <a id='3518' tid='3517' class='m'>==</a> <a id='3520' tid='3519' class='m'>0</a>);
  <a id='3522' tid='3521' class='m'>ASSERT</a>((<a id='3524' tid='3523' class='m'>size</a> <a id='3526' tid='3525' class='m'>&</a> <a id='3528' tid='3527' class='m'>CachePage</a><a id='3530' tid='3529' class='m'>::</a><a id='3532' tid='3531' class='m'>kLineMask</a>) <a id='3534' tid='3533' class='m'>==</a> <a id='3536' tid='3535' class='m'>0</a>);
  <a id='3538' tid='3537' class='m'>void</a><a id='3540' tid='3539' class='m'>*</a> <a id='3542' tid='3541' class='m'>page</a> = <a id='3544' tid='3543' class='m'>reinterpret_cast</a>&lt;<a id='3546' tid='3545' class='m'>void</a><a id='3548' tid='3547' class='m'>*</a>&gt;(<a id='3550' tid='3549' class='m'>start</a> <a id='3552' tid='3551' class='m'>&</a> (<a id='3554' tid='3553' class='m'>~</a><a id='3556' tid='3555' class='m'>CachePage</a><a id='3558' tid='3557' class='m'>::</a><a id='3560' tid='3559' class='m'>kPageMask</a>));
  <a id='3562' tid='3561' class='m'>int</a> <a id='3564' tid='3563' class='m'>offset</a> = (<a id='3566' tid='3565' class='m'>start</a> <a id='3568' tid='3567' class='m'>&</a> <a id='3570' tid='3569' class='m'>CachePage</a><a id='3572' tid='3571' class='m'>::</a><a id='3574' tid='3573' class='m'>kPageMask</a>);
  <a id='3576' tid='3575' class='m'>CachePage</a><a id='3578' tid='3577' class='m'>*</a> <a id='3580' tid='3579' class='m'>cache_page</a> = <a id='3582' tid='3581' class='m'>GetCachePage</a>(<a id='3584' tid='3583' class='m'>i_cache</a>, <a id='3586' tid='3585' class='m'>page</a>);
  <a id='3588' tid='3587' class='m'>char</a><a id='3590' tid='3589' class='m'>*</a> <a id='3592' tid='3591' class='m'>valid_bytemap</a> = <a id='3594' tid='3593' class='m'>cache_page</a>-&gt;<a id='3596' tid='3595' class='m'>ValidityByte</a>(<a id='3598' tid='3597' class='m'>offset</a>);
  <a id='3600' tid='3599' class='m'>memset</a>(<a id='3602' tid='3601' class='m'>valid_bytemap</a>, <a id='3604' tid='3603' class='m'>CachePage</a><a id='3606' tid='3605' class='m'>::</a><a id='3608' tid='3607' class='m'>LINE_INVALID</a>, <a id='3610' tid='3609' class='m'>size</a> <a id='3612' tid='3611' class='m'>&gt;&gt;</a> <a id='3614' tid='3613' class='m'>CachePage</a><a id='3616' tid='3615' class='m'>::</a><a id='3618' tid='3617' class='m'>kLineShift</a>);
}


<a id='3164' tid='3163' class='m'>void</a> <a id='3166' tid='3165' class='m'>Simulator</a><a id='3168' tid='3167' class='m'>::</a><a id='3170' tid='3169' class='m'>CheckICache</a>(<a id='3172' tid='3171' class='m'>v8</a><a id='3174' tid='3173' class='m'>::</a><a id='3176' tid='3175' class='m'>internal</a><a id='3178' tid='3177' class='m'>::</a><a id='3180' tid='3179' class='m'>HashMap</a><a id='3182' tid='3181' class='m'>*</a> <a id='3184' tid='3183' class='m'>i_cache</a>,
                            <a id='3186' tid='3185' class='m'>Instruction</a><a id='3188' tid='3187' class='m'>*</a> <a id='3190' tid='3189' class='m'>instr</a>) {
  <a id='3192' tid='3191' class='m'>intptr_t</a> <a id='3194' tid='3193' class='m'>address</a> = <a id='3196' tid='3195' class='m'>reinterpret_cast</a>&lt;<a id='3198' tid='3197' class='m'>intptr_t</a>&gt;(<a id='3200' tid='3199' class='m'>instr</a>);
  <a id='3202' tid='3201' class='m'>void</a><a id='3204' tid='3203' class='m'>*</a> <a id='3206' tid='3205' class='m'>page</a> = <a id='3208' tid='3207' class='m'>reinterpret_cast</a>&lt;<a id='3210' tid='3209' class='m'>void</a><a id='3212' tid='3211' class='m'>*</a>&gt;(<a id='3214' tid='3213' class='m'>address</a> <a id='3216' tid='3215' class='m'>&</a> (<a id='3218' tid='3217' class='m'>~</a><a id='3220' tid='3219' class='m'>CachePage</a><a id='3222' tid='3221' class='m'>::</a><a id='3224' tid='3223' class='m'>kPageMask</a>));
  <a id='3226' tid='3225' class='m'>void</a><a id='3228' tid='3227' class='m'>*</a> <a id='3230' tid='3229' class='m'>line</a> = <a id='3232' tid='3231' class='m'>reinterpret_cast</a>&lt;<a id='3234' tid='3233' class='m'>void</a><a id='3236' tid='3235' class='m'>*</a>&gt;(<a id='3238' tid='3237' class='m'>address</a> <a id='3240' tid='3239' class='m'>&</a> (<a id='3242' tid='3241' class='m'>~</a><a id='3244' tid='3243' class='m'>CachePage</a><a id='3246' tid='3245' class='m'>::</a><a id='3248' tid='3247' class='m'>kLineMask</a>));
  <a id='3250' tid='3249' class='m'>int</a> <a id='3252' tid='3251' class='m'>offset</a> = (<a id='3254' tid='3253' class='m'>address</a> <a id='3256' tid='3255' class='m'>&</a> <a id='3258' tid='3257' class='m'>CachePage</a><a id='3260' tid='3259' class='m'>::</a><a id='3262' tid='3261' class='m'>kPageMask</a>);
  <a id='3264' tid='3263' class='m'>CachePage</a><a id='3266' tid='3265' class='m'>*</a> <a id='3268' tid='3267' class='m'>cache_page</a> = <a id='3270' tid='3269' class='m'>GetCachePage</a>(<a id='3272' tid='3271' class='m'>i_cache</a>, <a id='3274' tid='3273' class='m'>page</a>);
  <a id='3276' tid='3275' class='m'>char</a><a id='3278' tid='3277' class='m'>*</a> <a id='3280' tid='3279' class='m'>cache_valid_byte</a> = <a id='3282' tid='3281' class='m'>cache_page</a>-&gt;<a id='3284' tid='3283' class='m'>ValidityByte</a>(<a id='3286' tid='3285' class='m'>offset</a>);
  <a id='3288' tid='3287' class='m'>bool</a> <a id='3290' tid='3289' class='m'>cache_hit</a> = (<a id='3292' tid='3291' class='m'>*</a><a id='3294' tid='3293' class='m'>cache_valid_byte</a> <a id='3296' tid='3295' class='m'>==</a> <a id='3298' tid='3297' class='m'>CachePage</a><a id='3300' tid='3299' class='m'>::</a><a id='3302' tid='3301' class='m'>LINE_VALID</a>);
  <a id='3304' tid='3303' class='m'>char</a><a id='3306' tid='3305' class='m'>*</a> <a id='3308' tid='3307' class='m'>cached_line</a> = <a id='3310' tid='3309' class='m'>cache_page</a>-&gt;<a id='3312' tid='3311' class='m'>CachedData</a>(<a id='3314' tid='3313' class='m'>offset</a> <a id='3316' tid='3315' class='m'>&</a> <a id='3318' tid='3317' class='m'>~</a><a id='3320' tid='3319' class='m'>CachePage</a><a id='3322' tid='3321' class='m'>::</a><a id='3324' tid='3323' class='m'>kLineMask</a>);
  <a id='3326' tid='3325' class='m'>if</a> (<a id='3328' tid='3327' class='m'>cache_hit</a>) {
    // Check that the data in memory matches the contents of the I-cache.
    <a id='3330' tid='3329' class='m'>CHECK</a>(<a id='3332' tid='3331' class='m'>memcmp</a>(<a id='3334' tid='3333' class='m'>reinterpret_cast</a>&lt;<a id='3336' tid='3335' class='m'>void</a><a id='3338' tid='3337' class='m'>*</a>&gt;(<a id='3340' tid='3339' class='m'>instr</a>),
                 <a id='3342' tid='3341' class='m'>cache_page</a>-&gt;<a id='3344' tid='3343' class='m'>CachedData</a>(<a id='3346' tid='3345' class='m'>offset</a>),
                 <a id='3348' tid='3347' class='m'>Instruction</a><a id='3350' tid='3349' class='m'>::</a><a id='3352' tid='3351' class='m'>kInstrSize</a>) <a id='3354' tid='3353' class='m'>==</a> <a id='3356' tid='3355' class='m'>0</a>);
  } <a id='3358' tid='3357' class='m'>else</a> {
    // Cache miss.  Load memory into the cache.
    <a id='3360' tid='3359' class='m'>memcpy</a>(<a id='3362' tid='3361' class='m'>cached_line</a>, <a id='3364' tid='3363' class='m'>line</a>, <a id='3366' tid='3365' class='m'>CachePage</a><a id='3368' tid='3367' class='m'>::</a><a id='3370' tid='3369' class='m'>kLineLength</a>);
    <a id='3372' tid='3371' class='m'>*</a><a id='3374' tid='3373' class='m'>cache_valid_byte</a> <a id='3376' tid='3375' class='m'>=</a> <a id='3378' tid='3377' class='m'>CachePage</a><a id='3380' tid='3379' class='m'>::</a><a id='3382' tid='3381' class='m'>LINE_VALID</a>;
  }
}


<a id='3014' tid='3013' class='m'>void</a> <a id='3016' tid='3015' class='m'>Simulator</a><a id='3018' tid='3017' class='m'>::</a><a id='3020' tid='3019' class='m'>Initialize</a>(<a id='3022' tid='3021' class='m'>Isolate</a><a id='3024' tid='3023' class='m'>*</a> <a id='3026' tid='3025' class='m'>isolate</a>) {
  <a id='3028' tid='3027' class='m'>if</a> (<a id='3030' tid='3029' class='m'>isolate</a>-&gt;<a id='3032' tid='3031' class='m'>simulator_initialized</a>()) <a id='3034' tid='3033' class='m'>return</a>;
  <a id='3036' tid='3035' class='m'>isolate</a>-&gt;<a id='3038' tid='3037' class='m'>set_simulator_initialized</a>(<a id='3040' tid='3039' class='m'>true</a>);
  <a id='3042' tid='3041' class='m'>::</a><a id='3044' tid='3043' class='m'>v8</a><a id='3046' tid='3045' class='m'>::</a><a id='3048' tid='3047' class='m'>internal</a><a id='3050' tid='3049' class='m'>::</a><a id='3052' tid='3051' class='m'>ExternalReference</a><a id='3054' tid='3053' class='m'>::</a><a id='3056' tid='3055' class='m'>set_redirector</a>(<a id='3058' tid='3057' class='m'>isolate</a>,
                                                    <a id='3060' tid='3059' class='m'>&</a><a id='3062' tid='3061' class='m'>RedirectExternalReference</a>);
}


<a id='2960' tid='2959' class='m'>Simulator</a><a id='2962' tid='2961' class='m'>::</a><a id='2964' tid='2963' class='m'>Simulator</a>(<a id='2966' tid='2965' class='m'>Isolate</a><a id='2968' tid='2967' class='m'>*</a> <a id='2970' tid='2969' class='m'>isolate</a>) : <a id='2972' tid='2971' class='m'>isolate_</a>(<a id='2974' tid='2973' class='m'>isolate</a>) {
  <a id='2976' tid='2975' class='m'>i_cache_</a> <a id='2978' tid='2977' class='m'>=</a> <a id='2980' tid='2979' class='m'>isolate_</a>-&gt;<a id='2982' tid='2981' class='m'>simulator_i_cache</a>();
  <a id='2926' tid='2925' class='m'>if</a> (<a id='2928' tid='2927' class='m'>i_cache_</a> <a id='2930' tid='2929' class='m'>==</a> <a id='2932' tid='2931' class='m'>NULL</a>) {
    <a id='2934' tid='2933' class='m'>i_cache_</a> <a id='2936' tid='2935' class='m'>=</a> <a id='2938' tid='2937' class='m'>new</a> <a id='2940' tid='2939' class='m'>v8</a><a id='2942' tid='2941' class='m'>::</a><a id='2944' tid='2943' class='m'>internal</a><a id='2946' tid='2945' class='m'>::</a><a id='2948' tid='2947' class='m'>HashMap</a>(<a id='2950' tid='2949' class='m'>&</a><a id='2952' tid='2951' class='m'>ICacheMatch</a>);
    <a id='2954' tid='2953' class='m'>isolate_</a>-&gt;<a id='2956' tid='2955' class='m'>set_simulator_i_cache</a>(<a id='2958' tid='2957' class='m'>i_cache_</a>);
  }
  <a id='2616' tid='2615' class='m'>Initialize</a>(<a id='2618' tid='2617' class='m'>isolate</a>);
  // Setup simulator support first. Some of this information is needed to
  // setup the architecture state.
  <span class='i'>size_t stack_size = 1 * 1024*1024;</span>  // allocate 1MB for stack
  <a id='2556' tid='2555' class='m'>stack_</a> <a id='2558' tid='2557' class='m'>=</a> <a id='2560' tid='2559' class='m'>reinterpret_cast</a>&lt;<a id='2562' tid='2561' class='m'>char</a><a id='2564' tid='2563' class='m'>*</a>&gt;<span class='i'>(malloc(stack_size))</span>;
  <a id='2500' tid='2499' class='m'>pc_modified_</a> <a id='2502' tid='2501' class='m'>=</a> <a id='2504' tid='2503' class='m'>false</a>;
  <a id='2438' tid='2437' class='m'>icount_</a> <a id='2440' tid='2439' class='m'>=</a> <a id='2442' tid='2441' class='m'>0</a>;
  <a id='2390' tid='2389' class='m'>break_pc_</a> <a id='2392' tid='2391' class='m'>=</a> <a id='2394' tid='2393' class='m'>NULL</a>;
  <a id='2368' tid='2367' class='m'>break_instr_</a> <a id='2370' tid='2369' class='m'>=</a> <a id='2372' tid='2371' class='m'>0</a>;

  // Setup architecture state.
  // All registers are initialized to zero to start with.
  <a id='2300' tid='2299' class='m'>for</a> (<a id='2302' tid='2301' class='m'>int</a> <a id='2304' tid='2303' class='m'>i</a> = <a id='2306' tid='2305' class='m'>0</a>; <span class='i'>i &lt; num_registers</span>; <a id='2282' tid='2281' class='m'>i</a><a id='2284' tid='2283' class='m'>++</a>) {
    <a id='2308' tid='2307' class='m'>registers_</a>[<a id='2310' tid='2309' class='m'>i</a>] <a id='2312' tid='2311' class='m'>=</a> <a id='2314' tid='2313' class='m'>0</a>;
  }
  <span class='i'>n_flag_ = false;</span>
  <span class='i'>z_flag_ = false;</span>
  <span class='i'>c_flag_ = false;</span>
  <span class='i'>v_flag_ = false;</span>

  // Initializing VFP registers.
  // All registers are initialized to zero to start with
  // even though s_registers_ & d_registers_ share the same
  // physical registers in the target.
  <span class='i'>for</span> (<a id='2276' tid='2275' class='m'>int</a> <a id='2278' tid='2277' class='m'>i</a> = <a id='2280' tid='2279' class='m'>0</a>; <span class='i'>i &lt; num_s_registers</span>; <a id='2252' tid='2251' class='m'>i</a><a id='2254' tid='2253' class='m'>++</a>) <span class='i'>{
    vfp_register[i] = 0;
  }</span>
  <span class='i'>n_flag_FPSCR_ = false;</span>
  <span class='i'>z_flag_FPSCR_ = false;</span>
  <span class='i'>c_flag_FPSCR_ = false;</span>
  <span class='i'>v_flag_FPSCR_ = false;</span>
  <span class='i'>FPSCR_rounding_mode_ = RZ;</span>

  <span class='i'>inv_op_vfp_flag_ = false;</span>
  <span class='i'>div_zero_vfp_flag_ = false;</span>
  <span class='i'>overflow_vfp_flag_ = false;</span>
  <span class='i'>underflow_vfp_flag_ = false;</span>
  <span class='i'>inexact_vfp_flag_ = false;</span>

  // The sp is initialized to point to the bottom (high address) of the
  // allocated stack area. To be safe in potential stack underflows we leave
  // some buffer below.
  <a id='2236' tid='2235' class='m'>registers_</a>[<a id='2238' tid='2237' class='m'>sp</a>] <a id='2240' tid='2239' class='m'>=</a> <a id='2242' tid='2241' class='m'>reinterpret_cast</a>&lt;<a id='2244' tid='2243' class='m'>int32_t</a>&gt;(<a id='2246' tid='2245' class='m'>stack_</a>) <span class='i'>+</span> <span class='i'>stack_size</span> <a id='2248' tid='2247' class='m'>-</a> <a id='2250' tid='2249' class='m'>64</a>;
  // The lr and pc are initialized to a known bad value that will cause an
  // access violation if the simulator ever tries to execute it.
  <a id='2218' tid='2217' class='m'>registers_</a>[<a id='2220' tid='2219' class='m'>pc</a>] <span class='i'>=</span> <span class='i'>bad_lr</span>;
  <span class='i'>registers_[lr] = bad_lr;</span>
  <span class='i'>InitializeCoverage();</span>
}


// When the generated code calls an external reference we need to catch that in
// the simulator.  The external reference will be a function compiled for the
// host architecture.  We need to call that function instead of trying to
// execute it with the simulator.  We do that by redirecting the external
// reference to a svc (Supervisor Call) instruction that is handled by
// the simulator.  We write the original destination of the jump just at a known
// offset from the svc instruction so the simulator knows what to call.
<a id='2624' tid='2623' class='m'>class</a> <a id='2626' tid='2625' class='m'>Redirection</a> {
 <a id='2882' tid='2881' class='m'>public</a>:
  <a id='2766' tid='2765' class='m'>Redirection</a>(<a id='2768' tid='2767' class='m'>void</a><a id='2770' tid='2769' class='m'>*</a> <a id='2772' tid='2771' class='m'>external_function</a>, <a id='2774' tid='2773' class='m'>ExternalReference</a><a id='2776' tid='2775' class='m'>::</a><a id='2778' tid='2777' class='m'>Type</a> <a id='2780' tid='2779' class='m'>type</a>)
      : <a id='2782' tid='2781' class='m'>external_function_</a>(<a id='2784' tid='2783' class='m'>external_function</a>),
        <span class='i'>swi_instruction_(al | (0xf*B24) | kCallRtRedirected)</span>,
        <a id='2620' tid='2619' class='m'>type_</a>(<a id='2622' tid='2621' class='m'>type</a>),
        <span class='i'>next_(NULL)</span> {
    <a id='2786' tid='2785' class='m'>Isolate</a><a id='2788' tid='2787' class='m'>*</a> <a id='2790' tid='2789' class='m'>isolate</a> = <a id='2792' tid='2791' class='m'>Isolate</a><a id='2794' tid='2793' class='m'>::</a><a id='2796' tid='2795' class='m'>Current</a>();
    <a id='2798' tid='2797' class='m'>next_</a> <a id='2800' tid='2799' class='m'>=</a> <a id='2802' tid='2801' class='m'>isolate</a>-&gt;<a id='2804' tid='2803' class='m'>simulator_redirection</a>();
    <a id='2806' tid='2805' class='m'>Simulator</a><a id='2808' tid='2807' class='m'>::</a><a id='2810' tid='2809' class='m'>current</a>(<a id='2812' tid='2811' class='m'>isolate</a>)-&gt;
        <a id='2814' tid='2813' class='m'>FlushICache</a>(<a id='2816' tid='2815' class='m'>isolate</a>-&gt;<a id='2818' tid='2817' class='m'>simulator_i_cache</a>(),
                    <a id='2820' tid='2819' class='m'>reinterpret_cast</a>&lt;<a id='2822' tid='2821' class='m'>void</a><a id='2824' tid='2823' class='m'>*</a>&gt;(<a id='2826' tid='2825' class='m'>&</a><a id='2828' tid='2827' class='m'>swi_instruction_</a>),
                    <a id='2830' tid='2829' class='m'>Instruction</a><a id='2832' tid='2831' class='m'>::</a><a id='2834' tid='2833' class='m'>kInstrSize</a>);
    <a id='2836' tid='2835' class='m'>isolate</a>-&gt;<a id='2838' tid='2837' class='m'>set_simulator_redirection</a>(<a id='2840' tid='2839' class='m'>this</a>);
  }

  <a id='2842' tid='2841' class='m'>void</a><a id='2844' tid='2843' class='m'>*</a> <a id='2846' tid='2845' class='m'>address_of_swi_instruction</a>() {
    <a id='2848' tid='2847' class='m'>return</a> <a id='2850' tid='2849' class='m'>reinterpret_cast</a>&lt;<a id='2852' tid='2851' class='m'>void</a><a id='2854' tid='2853' class='m'>*</a>&gt;(<a id='2856' tid='2855' class='m'>&</a><a id='2858' tid='2857' class='m'>swi_instruction_</a>);
  }

  <a id='2860' tid='2859' class='m'>void</a><a id='2862' tid='2861' class='m'>*</a> <a id='2864' tid='2863' class='m'>external_function</a>() { <a id='2866' tid='2865' class='m'>return</a> <a id='2868' tid='2867' class='m'>external_function_</a>; }
  <a id='2870' tid='2869' class='m'>ExternalReference</a><a id='2872' tid='2871' class='m'>::</a><a id='2874' tid='2873' class='m'>Type</a> <a id='2876' tid='2875' class='m'>type</a>() { <a id='2878' tid='2877' class='m'>return</a> <a id='2880' tid='2879' class='m'>type_</a>; }

  <a id='2682' tid='2681' class='m'>static</a> <a id='2684' tid='2683' class='m'>Redirection</a><a id='2686' tid='2685' class='m'>*</a> <a id='2688' tid='2687' class='m'>Get</a>(<a id='2690' tid='2689' class='m'>void</a><a id='2692' tid='2691' class='m'>*</a> <a id='2694' tid='2693' class='m'>external_function</a>,
                          <a id='2696' tid='2695' class='m'>ExternalReference</a><a id='2698' tid='2697' class='m'>::</a><a id='2700' tid='2699' class='m'>Type</a> <a id='2702' tid='2701' class='m'>type</a>) {
    <a id='2704' tid='2703' class='m'>Isolate</a><a id='2706' tid='2705' class='m'>*</a> <a id='2708' tid='2707' class='m'>isolate</a> = <a id='2710' tid='2709' class='m'>Isolate</a><a id='2712' tid='2711' class='m'>::</a><a id='2714' tid='2713' class='m'>Current</a>();
    <a id='2716' tid='2715' class='m'>Redirection</a><a id='2718' tid='2717' class='m'>*</a> <a id='2720' tid='2719' class='m'>current</a> = <a id='2722' tid='2721' class='m'>isolate</a>-&gt;<a id='2724' tid='2723' class='m'>simulator_redirection</a>();
    <a id='2726' tid='2725' class='m'>for</a> (; <a id='2728' tid='2727' class='m'>current</a> <a id='2730' tid='2729' class='m'>!=</a> <a id='2732' tid='2731' class='m'>NULL</a>; <a id='2734' tid='2733' class='m'>current</a> <a id='2736' tid='2735' class='m'>=</a> <a id='2738' tid='2737' class='m'>current</a>-&gt;<a id='2740' tid='2739' class='m'>next_</a>) {
      <a id='2742' tid='2741' class='m'>if</a> (<a id='2744' tid='2743' class='m'>current</a>-&gt;<a id='2746' tid='2745' class='m'>external_function_</a> <a id='2748' tid='2747' class='m'>==</a> <a id='2750' tid='2749' class='m'>external_function</a>) <a id='2752' tid='2751' class='m'>return</a> <a id='2754' tid='2753' class='m'>current</a>;
    }
    <a id='2756' tid='2755' class='m'>return</a> <a id='2758' tid='2757' class='m'>new</a> <a id='2760' tid='2759' class='m'>Redirection</a>(<a id='2762' tid='2761' class='m'>external_function</a>, <a id='2764' tid='2763' class='m'>type</a>);
  }

  <a id='2628' tid='2627' class='m'>static</a> <a id='2630' tid='2629' class='m'>Redirection</a><a id='2632' tid='2631' class='m'>*</a> <a id='2634' tid='2633' class='m'>FromSwiInstruction</a>(<a id='2636' tid='2635' class='m'>Instruction</a><a id='2638' tid='2637' class='m'>*</a> <a id='2640' tid='2639' class='m'>swi_instruction</a>) {
    <a id='2642' tid='2641' class='m'>char</a><a id='2644' tid='2643' class='m'>*</a> <a id='2646' tid='2645' class='m'>addr_of_swi</a> = <a id='2648' tid='2647' class='m'>reinterpret_cast</a>&lt;<a id='2650' tid='2649' class='m'>char</a><a id='2652' tid='2651' class='m'>*</a>&gt;(<a id='2654' tid='2653' class='m'>swi_instruction</a>);
    <a id='2656' tid='2655' class='m'>char</a><a id='2658' tid='2657' class='m'>*</a> <a id='2660' tid='2659' class='m'>addr_of_redirection</a> =
        <a id='2662' tid='2661' class='m'>addr_of_swi</a> <a id='2664' tid='2663' class='m'>-</a> <a id='2666' tid='2665' class='m'>OFFSET_OF</a>(<a id='2668' tid='2667' class='m'>Redirection</a>, <a id='2670' tid='2669' class='m'>swi_instruction_</a>);
    <a id='2672' tid='2671' class='m'>return</a> <a id='2674' tid='2673' class='m'>reinterpret_cast</a>&lt;<a id='2676' tid='2675' class='m'>Redirection</a><a id='2678' tid='2677' class='m'>*</a>&gt;(<a id='2680' tid='2679' class='m'>addr_of_redirection</a>);
  }

 <a id='2884' tid='2883' class='m'>private</a>:
  <a id='2886' tid='2885' class='m'>void</a><a id='2888' tid='2887' class='m'>*</a> <a id='2890' tid='2889' class='m'>external_function_</a>;
  <a id='2892' tid='2891' class='m'>uint32_t</a> <a id='2894' tid='2893' class='m'>swi_instruction_</a>;
  <a id='2896' tid='2895' class='m'>ExternalReference</a><a id='2898' tid='2897' class='m'>::</a><a id='2900' tid='2899' class='m'>Type</a> <a id='2902' tid='2901' class='m'>type_</a>;
  <a id='2904' tid='2903' class='m'>Redirection</a><a id='2906' tid='2905' class='m'>*</a> <a id='2908' tid='2907' class='m'>next_</a>;
};


<a id='2566' tid='2565' class='m'>void</a><a id='2568' tid='2567' class='m'>*</a> <a id='2570' tid='2569' class='m'>Simulator</a><a id='2572' tid='2571' class='m'>::</a><a id='2574' tid='2573' class='m'>RedirectExternalReference</a>(<a id='2576' tid='2575' class='m'>void</a><a id='2578' tid='2577' class='m'>*</a> <a id='2580' tid='2579' class='m'>external_function</a>,
                                           <a id='2582' tid='2581' class='m'>ExternalReference</a><a id='2584' tid='2583' class='m'>::</a><a id='2586' tid='2585' class='m'>Type</a> <a id='2588' tid='2587' class='m'>type</a>) {
  <a id='2590' tid='2589' class='m'>Redirection</a><a id='2592' tid='2591' class='m'>*</a> <a id='2594' tid='2593' class='m'>redirection</a> = <a id='2596' tid='2595' class='m'>Redirection</a><a id='2598' tid='2597' class='m'>::</a><a id='2600' tid='2599' class='m'>Get</a>(<a id='2602' tid='2601' class='m'>external_function</a>, <a id='2604' tid='2603' class='m'>type</a>);
  <a id='2606' tid='2605' class='m'>return</a> <a id='2608' tid='2607' class='m'>redirection</a>-&gt;<a id='2610' tid='2609' class='m'>address_of_swi_instruction</a>();
}


// Get the active Simulator for the current thread.
<a id='2514' tid='2513' class='m'>Simulator</a><a id='2516' tid='2515' class='m'>*</a> <a id='2518' tid='2517' class='m'>Simulator</a><a id='2520' tid='2519' class='m'>::</a><a id='2522' tid='2521' class='m'>current</a>(<a id='2524' tid='2523' class='m'>Isolate</a><a id='2526' tid='2525' class='m'>*</a> <a id='2528' tid='2527' class='m'>isolate</a>) {
  <a id='2530' tid='2529' class='m'>v8</a><a id='2532' tid='2531' class='m'>::</a><a id='2534' tid='2533' class='m'>internal</a><a id='2536' tid='2535' class='m'>::</a><a id='2538' tid='2537' class='m'>Isolate</a><a id='2540' tid='2539' class='m'>::</a><a id='2542' tid='2541' class='m'>PerIsolateThreadData</a><a id='2544' tid='2543' class='m'>*</a> <a id='2546' tid='2545' class='m'>isolate_data</a> =
      <a id='2548' tid='2547' class='m'>isolate</a>-&gt;<a id='2550' tid='2549' class='m'>FindOrAllocatePerThreadDataForThisThread</a>();
  <a id='2506' tid='2505' class='m'>ASSERT</a>(<a id='2508' tid='2507' class='m'>isolate_data</a> <a id='2510' tid='2509' class='m'>!=</a> <a id='2512' tid='2511' class='m'>NULL</a>);

  <a id='2444' tid='2443' class='m'>Simulator</a><a id='2446' tid='2445' class='m'>*</a> <a id='2448' tid='2447' class='m'>sim</a> = <a id='2450' tid='2449' class='m'>isolate_data</a>-&gt;<a id='2452' tid='2451' class='m'>simulator</a>();
  <a id='2396' tid='2395' class='m'>if</a> (<a id='2398' tid='2397' class='m'>sim</a> <a id='2400' tid='2399' class='m'>==</a> <a id='2402' tid='2401' class='m'>NULL</a>) {
    // TODO(146): delete the simulator object when a thread/isolate goes away.
    <a id='2404' tid='2403' class='m'>sim</a> <a id='2406' tid='2405' class='m'>=</a> <a id='2408' tid='2407' class='m'>new</a> <a id='2410' tid='2409' class='m'>Simulator</a>(<a id='2412' tid='2411' class='m'>isolate</a>);
    <a id='2414' tid='2413' class='m'>isolate_data</a>-&gt;<a id='2416' tid='2415' class='m'>set_simulator</a>(<a id='2418' tid='2417' class='m'>sim</a>);
  }
  <span class='i'>return sim;</span>
}


// Sets the register in the architecture state. It will also deal with updating
// Simulator internal state for special registers such as PC.
<a id='2454' tid='2453' class='m'>void</a> <a id='2456' tid='2455' class='m'>Simulator</a><a id='2458' tid='2457' class='m'>::</a><a id='2460' tid='2459' class='m'>set_register</a>(<a id='2462' tid='2461' class='m'>int</a> <a id='2464' tid='2463' class='m'>reg</a>, <a id='2466' tid='2465' class='m'>int32_t</a> <a id='2468' tid='2467' class='m'>value</a>) {
  <a id='2470' tid='2469' class='m'>ASSERT</a>((<a id='2472' tid='2471' class='m'>reg</a> <a id='2474' tid='2473' class='m'>&gt;=</a> <a id='2476' tid='2475' class='m'>0</a>) <span class='i'>&&</span> (<span class='i'>reg &lt; num_registers</span>));
  <a id='2478' tid='2477' class='m'>if</a> (<a id='2480' tid='2479' class='m'>reg</a> <a id='2482' tid='2481' class='m'>==</a> <a id='2484' tid='2483' class='m'>pc</a>) {
    <a id='2486' tid='2485' class='m'>pc_modified_</a> <a id='2488' tid='2487' class='m'>=</a> <a id='2490' tid='2489' class='m'>true</a>;
  }
  <a id='2492' tid='2491' class='m'>registers_</a>[<a id='2494' tid='2493' class='m'>reg</a>] <span class='i'>=</span> <span class='i'>value</span>;
}


// Get the register from the architecture state. This function does handle
// the special case of accessing the PC register.
<a id='2420' tid='2419' class='m'>int32_t</a> <a id='2422' tid='2421' class='m'>Simulator</a><a id='2424' tid='2423' class='m'>::</a><a id='2426' tid='2425' class='m'>get_register</a>(<a id='2428' tid='2427' class='m'>int</a> <a id='2430' tid='2429' class='m'>reg</a>) <a id='2432' tid='2431' class='m'>const</a> {
  <a id='2378' tid='2377' class='m'>ASSERT</a>((<a id='2380' tid='2379' class='m'>reg</a> <a id='2382' tid='2381' class='m'>&gt;=</a> <a id='2384' tid='2383' class='m'>0</a>) <span class='i'>&&</span> (<span class='i'>reg &lt; num_registers</span>));
  // Stupid code added to avoid bug in GCC.
  // See: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=43949
  <span class='i'>if</span> <span class='i'>(reg &gt;= num_registers)</span> <a id='2374' tid='2373' class='m'>return</a> <a id='2376' tid='2375' class='m'>0</a>;
  // End stupid code.
  <a id='2316' tid='2315' class='m'>return</a> <a id='2318' tid='2317' class='m'>registers_</a>[<a id='2320' tid='2319' class='m'>reg</a>] <a id='2322' tid='2321' class='m'>+</a> ((<a id='2324' tid='2323' class='m'>reg</a> <a id='2326' tid='2325' class='m'>==</a> <a id='2328' tid='2327' class='m'>pc</a>) ? <a id='2330' tid='2329' class='m'>Instruction</a><a id='2332' tid='2331' class='m'>::</a><a id='2334' tid='2333' class='m'>kPCReadOffset</a> : <a id='2336' tid='2335' class='m'>0</a>);
}


<span class='i'>double Simulator::get_double_from_register_pair(int reg) {
  ASSERT((reg &gt;= 0) && (reg &lt; num_registers) && ((reg % 2) == 0));

  double dm_val = 0.0;
  // Read the bits from the unsigned integer register_[] array
  // into the double precision floating point value and return it.
  char buffer[2 * sizeof(vfp_register[0])];
  memcpy(buffer, &registers_[reg], 2 * sizeof(registers_[0]));
  memcpy(&dm_val, buffer, 2 * sizeof(registers_[0]));
  return(dm_val);
}</span>


<span class='i'>void Simulator::set_dw_register(int dreg, const int* dbl) {
  ASSERT((dreg &gt;= 0) && (dreg &lt; num_d_registers));
  registers_[dreg] = dbl[0];
  registers_[dreg + 1] = dbl[1];
}</span>


// Raw access to the PC register.
<a id='2338' tid='2337' class='m'>void</a> <a id='2340' tid='2339' class='m'>Simulator</a><a id='2342' tid='2341' class='m'>::</a><a id='2344' tid='2343' class='m'>set_pc</a>(<a id='2346' tid='2345' class='m'>int32_t</a> <a id='2348' tid='2347' class='m'>value</a>) {
  <a id='2350' tid='2349' class='m'>pc_modified_</a> <a id='2352' tid='2351' class='m'>=</a> <a id='2354' tid='2353' class='m'>true</a>;
  <a id='2356' tid='2355' class='m'>registers_</a>[<a id='2358' tid='2357' class='m'>pc</a>] <a id='2360' tid='2359' class='m'>=</a> <a id='2362' tid='2361' class='m'>value</a>;
}


<a id='2286' tid='2285' class='m'>bool</a> <a id='2288' tid='2287' class='m'>Simulator</a><a id='2290' tid='2289' class='m'>::</a><a id='2292' tid='2291' class='m'>has_bad_pc</a>() <a id='2294' tid='2293' class='m'>const</a> {
  <a id='2256' tid='2255' class='m'>return</a> ((<a id='2258' tid='2257' class='m'>registers_</a>[<a id='2260' tid='2259' class='m'>pc</a>] <span class='i'>==</span> <span class='i'>bad_lr</span>) <a id='2262' tid='2261' class='m'>||</a> (<a id='2264' tid='2263' class='m'>registers_</a>[<a id='2266' tid='2265' class='m'>pc</a>] <a id='2268' tid='2267' class='m'>==</a> <a id='2270' tid='2269' class='m'>end_sim_pc</a>));
}


// Raw access to the PC register without the special adjustment when reading.
<a id='2222' tid='2221' class='m'>int32_t</a> <a id='2224' tid='2223' class='m'>Simulator</a><a id='2226' tid='2225' class='m'>::</a><a id='2228' tid='2227' class='m'>get_pc</a>() <a id='2230' tid='2229' class='m'>const</a> {
  <a id='2208' tid='2207' class='m'>return</a> <a id='2210' tid='2209' class='m'>registers_</a>[<a id='2212' tid='2211' class='m'>pc</a>];
}


// Getting from and setting into VFP registers.
<span class='i'>void Simulator::set_s_register(int sreg, unsigned int value) {
  ASSERT((sreg &gt;= 0) && (sreg &lt; num_s_registers));
  vfp_register[sreg] = value;
}</span>


<span class='i'>unsigned int Simulator::get_s_register(int sreg) const</span> <span class='i'>{
  ASSERT((sreg &gt;= 0) && (sreg &lt; num_s_registers));
  return vfp_register[sreg];
}</span>


<span class='i'>void Simulator::set_s_register_from_float(int sreg, const float flt) {
  ASSERT((sreg &gt;= 0) && (sreg &lt; num_s_registers));
  // Read the bits from the single precision floating point value
  // into the unsigned integer element of vfp_register[] given by index=sreg.
  char buffer[sizeof(vfp_register[0])];
  memcpy(buffer, &flt, sizeof(vfp_register[0]));
  memcpy(&vfp_register[sreg], buffer, sizeof(vfp_register[0]));
}</span>


<span class='i'>void Simulator::set_s_register_from_sinteger(int sreg, const int sint) {
  ASSERT((sreg &gt;= 0) && (sreg &lt; num_s_registers));
  // Read the bits from the integer value into the unsigned integer element of
  // vfp_register[] given by index=sreg.
  char buffer[sizeof(vfp_register[0])];
  memcpy(buffer, &sint, sizeof(vfp_register[0]));
  memcpy(&vfp_register[sreg], buffer, sizeof(vfp_register[0]));
}</span>


<span class='i'>void Simulator::set_d_register_from_double(int dreg, const double& dbl) {
  ASSERT((dreg &gt;= 0) && (dreg &lt; num_d_registers));
  // Read the bits from the double precision floating point value into the two
  // consecutive unsigned integer elements of vfp_register[] given by index
  // 2*sreg and 2*sreg+1.
  char buffer[2 * sizeof(vfp_register[0])];
  memcpy(buffer, &dbl, 2 * sizeof(vfp_register[0]));
  memcpy(&vfp_register[dreg * 2], buffer, 2 * sizeof(vfp_register[0]));
}</span>


<span class='i'>float Simulator::get_float_from_s_register(int sreg) {
  ASSERT((sreg &gt;= 0) && (sreg &lt; num_s_registers));

  float sm_val = 0.0;
  // Read the bits from the unsigned integer vfp_register[] array
  // into the single precision floating point value and return it.
  char buffer[sizeof(vfp_register[0])];
  memcpy(buffer, &vfp_register[sreg], sizeof(vfp_register[0]));
  memcpy(&sm_val, buffer, sizeof(vfp_register[0]));
  return(sm_val);
}</span>


<span class='i'>int Simulator::get_sinteger_from_s_register(int sreg) {
  ASSERT((sreg &gt;= 0) && (sreg &lt; num_s_registers));

  int sm_val = 0;
  // Read the bits from the unsigned integer vfp_register[] array
  // into the single precision floating point value and return it.
  char buffer[sizeof(vfp_register[0])];
  memcpy(buffer, &vfp_register[sreg], sizeof(vfp_register[0]));
  memcpy(&sm_val, buffer, sizeof(vfp_register[0]));
  return(sm_val);
}</span>


<span class='i'>double Simulator::get_double_from_d_register(int dreg) {
  ASSERT((dreg &gt;= 0) && (dreg &lt; num_d_registers));

  double dm_val = 0.0;
  // Read the bits from the unsigned integer vfp_register[] array
  // into the double precision floating point value and return it.
  char buffer[2 * sizeof(vfp_register[0])];
  memcpy(buffer, &vfp_register[2 * dreg], 2 * sizeof(vfp_register[0]));
  memcpy(&dm_val, buffer, 2 * sizeof(vfp_register[0]));
  return(dm_val);
}</span>


// For use in calls that take two double values, constructed either
// from r0-r3 or d0 and d1.
<a id='2176' tid='2175' class='m'>void</a> <a id='2178' tid='2177' class='m'>Simulator</a><a id='2180' tid='2179' class='m'>::</a><a id='2182' tid='2181' class='m'>GetFpArgs</a>(<a id='2184' tid='2183' class='m'>double</a><a id='2186' tid='2185' class='m'>*</a> <a id='2188' tid='2187' class='m'>x</a>, <a id='2190' tid='2189' class='m'>double</a><a id='2192' tid='2191' class='m'>*</a> <a id='2194' tid='2193' class='m'>y</a>) {
  <span class='i'>if</span> <span class='i'>(use_eabi_hardfloat())</span> {
    <a id='2196' tid='2195' class='m'>*</a><a id='2198' tid='2197' class='m'>x</a> <span class='i'>=</span> <span class='i'>vfp_register[0]</span>;
    <a id='2200' tid='2199' class='m'>*</a><a id='2202' tid='2201' class='m'>y</a> <span class='i'>=</span> <span class='i'>vfp_register[1]</span>;
  } <span class='i'>else</span> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <a id='2166' tid='2165' class='m'>char</a> <a id='2168' tid='2167' class='m'>buffer</a>[<a id='2170' tid='2169' class='m'>sizeof</a>(<a id='2172' tid='2171' class='m'>*</a><a id='2174' tid='2173' class='m'>x</a>)];
    // Registers 0 and 1 -&gt; x.
    <span class='i'>memcpy</span>(<span class='i'>buffer</span>, <span class='i'>registers_</span>, <span class='i'>sizeof</span>(<a id='2140' tid='2139' class='m'>*</a><a id='2142' tid='2141' class='m'>x</a>));
    <span class='i'>memcpy(x, buffer, sizeof(*x));</span>
    // Registers 2 and 3 -&gt; y.
    <span class='i'>memcpy(buffer, registers_ + 2, sizeof(*y));</span>
    <span class='i'>memcpy(y, buffer, sizeof(*y));</span>
  }
}

// For use in calls that take one double value, constructed either
// from r0 and r1 or d0.
<a id='2144' tid='2143' class='m'>void</a> <a id='2146' tid='2145' class='m'>Simulator</a><a id='2148' tid='2147' class='m'>::</a><a id='2150' tid='2149' class='m'>GetFpArgs</a>(<a id='2152' tid='2151' class='m'>double</a><a id='2154' tid='2153' class='m'>*</a> <a id='2156' tid='2155' class='m'>x</a>) {
  <span class='i'>if</span> <span class='i'>(use_eabi_hardfloat())</span> {
    <a id='2158' tid='2157' class='m'>*</a><a id='2160' tid='2159' class='m'>x</a> <span class='i'>=</span> <span class='i'>vfp_register[0]</span>;
  } <span class='i'>else {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    char buffer[sizeof(*x)];
    // Registers 0 and 1 -&gt; x.
    memcpy(buffer, registers_, sizeof(*x));
    memcpy(x, buffer, sizeof(*x));
  }</span>
}


// For use in calls that take one double value constructed either
// from r0 and r1 or d0 and one integer value.
<a id='2108' tid='2107' class='m'>void</a> <a id='2110' tid='2109' class='m'>Simulator</a><a id='2112' tid='2111' class='m'>::</a><a id='2114' tid='2113' class='m'>GetFpArgs</a>(<a id='2116' tid='2115' class='m'>double</a><a id='2118' tid='2117' class='m'>*</a> <a id='2120' tid='2119' class='m'>x</a>, <a id='2122' tid='2121' class='m'>int32_t</a><a id='2124' tid='2123' class='m'>*</a> <a id='2126' tid='2125' class='m'>y</a>) {
  <span class='i'>if</span> <span class='i'>(use_eabi_hardfloat())</span> {
    <a id='2128' tid='2127' class='m'>*</a><a id='2130' tid='2129' class='m'>x</a> <span class='i'>=</span> <span class='i'>vfp_register[0]</span>;
    <a id='2132' tid='2131' class='m'>*</a><a id='2134' tid='2133' class='m'>y</a> <span class='i'>=</span> <span class='i'>registers_[1]</span>;
  } <span class='i'>else</span> {
    // We use a char buffer to get around the strict-aliasing rules which
    // otherwise allow the compiler to optimize away the copy.
    <a id='2098' tid='2097' class='m'>char</a> <a id='2100' tid='2099' class='m'>buffer</a>[<a id='2102' tid='2101' class='m'>sizeof</a>(<a id='2104' tid='2103' class='m'>*</a><a id='2106' tid='2105' class='m'>x</a>)];
    // Registers 0 and 1 -&gt; x.
    <span class='i'>memcpy(buffer, registers_, sizeof(*x));</span>
    <span class='i'>memcpy(x, buffer, sizeof(*x));</span>
    // Register 2 -&gt; y.
    <a id='2044' tid='2043' class='m'>memcpy</a>(<span class='i'>buffer</span>, <span class='i'>registers_ + 2</span>, <a id='2046' tid='2045' class='m'>sizeof</a>(<a id='2048' tid='2047' class='m'>*</a><a id='2050' tid='2049' class='m'>y</a>));
    <span class='i'>memcpy(y, buffer, sizeof(*y));</span>
  }
}


// The return value is either in r0/r1 or d0.
<a id='2066' tid='2065' class='m'>void</a> <a id='2068' tid='2067' class='m'>Simulator</a><a id='2070' tid='2069' class='m'>::</a><a id='2072' tid='2071' class='m'>SetFpResult</a>(<a id='2074' tid='2073' class='m'>const</a> <a id='2076' tid='2075' class='m'>double</a><a id='2078' tid='2077' class='m'>&</a> <a id='2080' tid='2079' class='m'>result</a>) {
  <span class='i'>if</span> <span class='i'>(use_eabi_hardfloat())</span> {
    <span class='i'>char buffer[2 * sizeof(vfp_register[0])];</span>
    <a id='2082' tid='2081' class='m'>memcpy</a>(<a id='2084' tid='2083' class='m'>buffer</a>, <a id='2086' tid='2085' class='m'>&</a><a id='2088' tid='2087' class='m'>result</a>, <a id='2090' tid='2089' class='m'>sizeof</a>(<a id='2092' tid='2091' class='m'>buffer</a>));
    // Copy result to d0.
    <span class='i'>memcpy(vfp_register, buffer, sizeof(buffer));</span>
  } <span class='i'>else</span> {
    <a id='2052' tid='2051' class='m'>char</a> <a id='2054' tid='2053' class='m'>buffer</a>[<a id='2056' tid='2055' class='m'>2</a> <a id='2058' tid='2057' class='m'>*</a> <a id='2060' tid='2059' class='m'>sizeof</a>(<a id='2062' tid='2061' class='m'>registers_</a>[<a id='2064' tid='2063' class='m'>0</a>])];
    <span class='i'>memcpy(buffer, &result, sizeof(buffer));</span>
    // Copy result to r0 and r1.
    <span class='i'>memcpy(registers_, buffer, sizeof(buffer));</span>
  }
}


<span class='i'>void Simulator::TrashCallerSaveRegisters() {
  // We don&#39;t trash the registers with the return value.
  registers_[2] = 0x50Bad4U;
  registers_[3] = 0x50Bad4U;
  registers_[12] = 0x50Bad4U;
}</span>

// Some Operating Systems allow unaligned access on ARMv7 targets. We
// assume that unaligned accesses are not allowed unless the v8 build system
// defines the CAN_USE_UNALIGNED_ACCESSES macro to be non-zero.
// The following statements below describes the behavior of the ARM CPUs
// that don&#39;t support unaligned access.
// Some ARM platforms raise an interrupt on detecting unaligned access.
// On others it does a funky rotation thing.  For now we
// simply disallow unaligned reads.  Note that simulator runs have the runtime
// system running directly on the host system and only generated code is
// executed in the simulator.  Since the host is typically IA32 we will not
// get the correct ARM-like behaviour on unaligned accesses for those ARM
// targets that don&#39;t support unaligned loads and stores.


<a id='2008' tid='2007' class='m'>int</a> <a id='2010' tid='2009' class='m'>Simulator</a><a id='2012' tid='2011' class='m'>::</a><a id='2014' tid='2013' class='m'>ReadW</a>(<a id='2016' tid='2015' class='m'>int32_t</a> <a id='2018' tid='2017' class='m'>addr</a>, <a id='2020' tid='2019' class='m'>Instruction</a><a id='2022' tid='2021' class='m'>*</a> <a id='2024' tid='2023' class='m'>instr</a>) {
<span class='i'>#if V8_TARGET_CAN_READ_UNALIGNED</span>
  <a id='2026' tid='2025' class='m'>intptr_t</a><a id='2028' tid='2027' class='m'>*</a> <a id='2030' tid='2029' class='m'>ptr</a> = <a id='2032' tid='2031' class='m'>reinterpret_cast</a>&lt;<a id='2034' tid='2033' class='m'>intptr_t</a><a id='2036' tid='2035' class='m'>*</a>&gt;(<a id='2038' tid='2037' class='m'>addr</a>);
  <span class='i'>return *ptr;</span>
<span class='i'>#else</span>
  <span class='i'>if ((addr & 3) == 0) {
    intptr_t* ptr = reinterpret_cast&lt;intptr_t*&gt;(addr);
    return *ptr;
  }</span>
  <a id='1992' tid='1991' class='m'>PrintF</a>(<a id='1994' tid='1993' class='m'>&quot;Unaligned read at 0x%08x, pc=0x%08&quot;</a> <a id='1996' tid='1995' class='m'>V8PRIxPTR</a> <a id='1998' tid='1997' class='m'>&quot;\n&quot;</a>,
         <a id='2000' tid='1999' class='m'>addr</a>,
         <a id='2002' tid='2001' class='m'>reinterpret_cast</a>&lt;<a id='2004' tid='2003' class='m'>intptr_t</a>&gt;(<a id='2006' tid='2005' class='m'>instr</a>));
  <span class='i'>UNIMPLEMENTED();</span>
  <a id='1932' tid='1931' class='m'>return</a> <a id='1934' tid='1933' class='m'>0</a>;
<span class='i'>#endif</span>
}


<a id='1952' tid='1951' class='m'>void</a> <a id='1954' tid='1953' class='m'>Simulator</a><a id='1956' tid='1955' class='m'>::</a><a id='1958' tid='1957' class='m'>WriteW</a>(<a id='1960' tid='1959' class='m'>int32_t</a> <a id='1962' tid='1961' class='m'>addr</a>, <a id='1964' tid='1963' class='m'>int</a> <a id='1966' tid='1965' class='m'>value</a>, <a id='1968' tid='1967' class='m'>Instruction</a><a id='1970' tid='1969' class='m'>*</a> <a id='1972' tid='1971' class='m'>instr</a>) {
<span class='i'>#if V8_TARGET_CAN_READ_UNALIGNED</span>
  <a id='1974' tid='1973' class='m'>intptr_t</a><a id='1976' tid='1975' class='m'>*</a> <a id='1978' tid='1977' class='m'>ptr</a> = <a id='1980' tid='1979' class='m'>reinterpret_cast</a>&lt;<a id='1982' tid='1981' class='m'>intptr_t</a><a id='1984' tid='1983' class='m'>*</a>&gt;(<a id='1986' tid='1985' class='m'>addr</a>);
  <a id='1872' tid='1871' class='m'>*</a><a id='1874' tid='1873' class='m'>ptr</a> <a id='1876' tid='1875' class='m'>=</a> <a id='1878' tid='1877' class='m'>value</a>;
  <span class='i'>return;</span>
<span class='i'>#else</span>
  <span class='i'>if ((addr & 3) == 0) {
    intptr_t* ptr = reinterpret_cast&lt;intptr_t*&gt;(addr);
    *ptr = value;
    return;
  }</span>
  <a id='1936' tid='1935' class='m'>PrintF</a>(<a id='1938' tid='1937' class='m'>&quot;Unaligned write at 0x%08x, pc=0x%08&quot;</a> <a id='1940' tid='1939' class='m'>V8PRIxPTR</a> <a id='1942' tid='1941' class='m'>&quot;\n&quot;</a>,
         <a id='1944' tid='1943' class='m'>addr</a>,
         <a id='1946' tid='1945' class='m'>reinterpret_cast</a>&lt;<a id='1948' tid='1947' class='m'>intptr_t</a>&gt;(<a id='1950' tid='1949' class='m'>instr</a>));
  <span class='i'>UNIMPLEMENTED();</span>
<span class='i'>#endif</span>
}


<a id='1896' tid='1895' class='m'>uint16_t</a> <a id='1898' tid='1897' class='m'>Simulator</a><a id='1900' tid='1899' class='m'>::</a><a id='1902' tid='1901' class='m'>ReadHU</a>(<a id='1904' tid='1903' class='m'>int32_t</a> <a id='1906' tid='1905' class='m'>addr</a>, <a id='1908' tid='1907' class='m'>Instruction</a><a id='1910' tid='1909' class='m'>*</a> <a id='1912' tid='1911' class='m'>instr</a>) {
<span class='i'>#if V8_TARGET_CAN_READ_UNALIGNED</span>
  <a id='1914' tid='1913' class='m'>uint16_t</a><a id='1916' tid='1915' class='m'>*</a> <a id='1918' tid='1917' class='m'>ptr</a> = <a id='1920' tid='1919' class='m'>reinterpret_cast</a>&lt;<a id='1922' tid='1921' class='m'>uint16_t</a><a id='1924' tid='1923' class='m'>*</a>&gt;(<a id='1926' tid='1925' class='m'>addr</a>);
  <span class='i'>return *ptr;</span>
<span class='i'>#else</span>
  <span class='i'>if</span> ((<a id='1822' tid='1821' class='m'>addr</a> <a id='1824' tid='1823' class='m'>&</a> <a id='1826' tid='1825' class='m'>1</a>) <a id='1828' tid='1827' class='m'>==</a> <a id='1830' tid='1829' class='m'>0</a>) <span class='i'>{
    uint16_t* ptr = reinterpret_cast&lt;uint16_t*&gt;(addr);
    return *ptr;
  }</span>
  <a id='1880' tid='1879' class='m'>PrintF</a>(<a id='1882' tid='1881' class='m'>&quot;Unaligned unsigned halfword read at 0x%08x, pc=0x%08&quot;</a> <a id='1884' tid='1883' class='m'>V8PRIxPTR</a> <a id='1886' tid='1885' class='m'>&quot;\n&quot;</a>,
         <a id='1888' tid='1887' class='m'>addr</a>,
         <a id='1890' tid='1889' class='m'>reinterpret_cast</a>&lt;<a id='1892' tid='1891' class='m'>intptr_t</a>&gt;(<a id='1894' tid='1893' class='m'>instr</a>));
  <span class='i'>UNIMPLEMENTED();</span>
  <a id='1752' tid='1751' class='m'>return</a> <a id='1754' tid='1753' class='m'>0</a>;
<span class='i'>#endif</span>
}


<a id='1836' tid='1835' class='m'>int16_t</a> <a id='1838' tid='1837' class='m'>Simulator</a><a id='1840' tid='1839' class='m'>::</a><a id='1842' tid='1841' class='m'>ReadH</a>(<a id='1844' tid='1843' class='m'>int32_t</a> <a id='1846' tid='1845' class='m'>addr</a>, <a id='1848' tid='1847' class='m'>Instruction</a><a id='1850' tid='1849' class='m'>*</a> <a id='1852' tid='1851' class='m'>instr</a>) {
<span class='i'>#if V8_TARGET_CAN_READ_UNALIGNED</span>
  <a id='1854' tid='1853' class='m'>int16_t</a><a id='1856' tid='1855' class='m'>*</a> <a id='1858' tid='1857' class='m'>ptr</a> = <a id='1860' tid='1859' class='m'>reinterpret_cast</a>&lt;<a id='1862' tid='1861' class='m'>int16_t</a><a id='1864' tid='1863' class='m'>*</a>&gt;(<a id='1866' tid='1865' class='m'>addr</a>);
  <span class='i'>return *ptr;</span>
<span class='i'>#else</span>
  <span class='i'>if</span> ((<a id='1756' tid='1755' class='m'>addr</a> <a id='1758' tid='1757' class='m'>&</a> <a id='1760' tid='1759' class='m'>1</a>) <a id='1762' tid='1761' class='m'>==</a> <a id='1764' tid='1763' class='m'>0</a>) <span class='i'>{
    int16_t* ptr = reinterpret_cast&lt;int16_t*&gt;(addr);
    return *ptr;
  }</span>
  <span class='i'>PrintF(&quot;Unaligned signed halfword read at 0x%08x\n&quot;, addr);</span>
  <span class='i'>UNIMPLEMENTED();</span>
  <a id='1832' tid='1831' class='m'>return</a> <a id='1834' tid='1833' class='m'>0</a>;
<span class='i'>#endif</span>
}


<a id='1782' tid='1781' class='m'>void</a> <a id='1784' tid='1783' class='m'>Simulator</a><a id='1786' tid='1785' class='m'>::</a><a id='1788' tid='1787' class='m'>WriteH</a>(<a id='1790' tid='1789' class='m'>int32_t</a> <a id='1792' tid='1791' class='m'>addr</a>, <a id='1794' tid='1793' class='m'>uint16_t</a> <a id='1796' tid='1795' class='m'>value</a>, <a id='1798' tid='1797' class='m'>Instruction</a><a id='1800' tid='1799' class='m'>*</a> <a id='1802' tid='1801' class='m'>instr</a>) {
<span class='i'>#if V8_TARGET_CAN_READ_UNALIGNED</span>
  <a id='1804' tid='1803' class='m'>uint16_t</a><a id='1806' tid='1805' class='m'>*</a> <a id='1808' tid='1807' class='m'>ptr</a> = <a id='1810' tid='1809' class='m'>reinterpret_cast</a>&lt;<a id='1812' tid='1811' class='m'>uint16_t</a><a id='1814' tid='1813' class='m'>*</a>&gt;(<a id='1816' tid='1815' class='m'>addr</a>);
  <a id='1688' tid='1687' class='m'>*</a><a id='1690' tid='1689' class='m'>ptr</a> <a id='1692' tid='1691' class='m'>=</a> <a id='1694' tid='1693' class='m'>value</a>;
  <span class='i'>return;</span>
<span class='i'>#else</span>
  <span class='i'>if</span> ((<a id='1654' tid='1653' class='m'>addr</a> <a id='1656' tid='1655' class='m'>&</a> <a id='1658' tid='1657' class='m'>1</a>) <a id='1660' tid='1659' class='m'>==</a> <a id='1662' tid='1661' class='m'>0</a>) {
    <span class='i'>uint16_t* ptr = reinterpret_cast&lt;uint16_t*&gt;(addr);</span>
    <a id='1618' tid='1617' class='m'>*</a><a id='1620' tid='1619' class='m'>ptr</a> <a id='1622' tid='1621' class='m'>=</a> <a id='1624' tid='1623' class='m'>value</a>;
    <span class='i'>return;</span>
  }
  <a id='1766' tid='1765' class='m'>PrintF</a>(<a id='1768' tid='1767' class='m'>&quot;Unaligned unsigned halfword write at 0x%08x, pc=0x%08&quot;</a> <a id='1770' tid='1769' class='m'>V8PRIxPTR</a> <a id='1772' tid='1771' class='m'>&quot;\n&quot;</a>,
         <a id='1774' tid='1773' class='m'>addr</a>,
         <a id='1776' tid='1775' class='m'>reinterpret_cast</a>&lt;<a id='1778' tid='1777' class='m'>intptr_t</a>&gt;(<a id='1780' tid='1779' class='m'>instr</a>));
  <span class='i'>UNIMPLEMENTED();</span>
<span class='i'>#endif</span>
}


<a id='1712' tid='1711' class='m'>void</a> <a id='1714' tid='1713' class='m'>Simulator</a><a id='1716' tid='1715' class='m'>::</a><a id='1718' tid='1717' class='m'>WriteH</a>(<a id='1720' tid='1719' class='m'>int32_t</a> <a id='1722' tid='1721' class='m'>addr</a>, <a id='1724' tid='1723' class='m'>int16_t</a> <a id='1726' tid='1725' class='m'>value</a>, <a id='1728' tid='1727' class='m'>Instruction</a><a id='1730' tid='1729' class='m'>*</a> <a id='1732' tid='1731' class='m'>instr</a>) {
<span class='i'>#if V8_TARGET_CAN_READ_UNALIGNED</span>
  <a id='1734' tid='1733' class='m'>int16_t</a><a id='1736' tid='1735' class='m'>*</a> <a id='1738' tid='1737' class='m'>ptr</a> = <a id='1740' tid='1739' class='m'>reinterpret_cast</a>&lt;<a id='1742' tid='1741' class='m'>int16_t</a><a id='1744' tid='1743' class='m'>*</a>&gt;(<a id='1746' tid='1745' class='m'>addr</a>);
  <span class='i'>*ptr = value;</span>
  <span class='i'>return;</span>
<span class='i'>#else</span>
  <span class='i'>if</span> ((<a id='1664' tid='1663' class='m'>addr</a> <a id='1666' tid='1665' class='m'>&</a> <a id='1668' tid='1667' class='m'>1</a>) <a id='1670' tid='1669' class='m'>==</a> <a id='1672' tid='1671' class='m'>0</a>) <span class='i'>{
    int16_t* ptr = reinterpret_cast&lt;int16_t*&gt;(addr);
    *ptr = value;
    return;
  }</span>
  <a id='1696' tid='1695' class='m'>PrintF</a>(<a id='1698' tid='1697' class='m'>&quot;Unaligned halfword write at 0x%08x, pc=0x%08&quot;</a> <a id='1700' tid='1699' class='m'>V8PRIxPTR</a> <a id='1702' tid='1701' class='m'>&quot;\n&quot;</a>,
         <a id='1704' tid='1703' class='m'>addr</a>,
         <a id='1706' tid='1705' class='m'>reinterpret_cast</a>&lt;<a id='1708' tid='1707' class='m'>intptr_t</a>&gt;(<a id='1710' tid='1709' class='m'>instr</a>));
  <span class='i'>UNIMPLEMENTED();</span>
<span class='i'>#endif</span>
}


<span class='i'>uint8_t</span> <a id='1678' tid='1677' class='m'>Simulator</a><a id='1680' tid='1679' class='m'>::</a><a id='1682' tid='1681' class='m'>ReadBU</a>(<a id='1674' tid='1673' class='m'>int32_t</a> <a id='1676' tid='1675' class='m'>addr</a>) {
  <a id='1626' tid='1625' class='m'>uint8_t</a><a id='1628' tid='1627' class='m'>*</a> <a id='1630' tid='1629' class='m'>ptr</a> = <a id='1632' tid='1631' class='m'>reinterpret_cast</a>&lt;<a id='1634' tid='1633' class='m'>uint8_t</a><a id='1636' tid='1635' class='m'>*</a>&gt;(<a id='1638' tid='1637' class='m'>addr</a>);
  <span class='i'>return *ptr;</span>
}


<span class='i'>int8_t</span> <a id='1644' tid='1643' class='m'>Simulator</a><a id='1646' tid='1645' class='m'>::</a><a id='1648' tid='1647' class='m'>ReadB</a>(<a id='1640' tid='1639' class='m'>int32_t</a> <a id='1642' tid='1641' class='m'>addr</a>) {
  <a id='1556' tid='1555' class='m'>int8_t</a><a id='1558' tid='1557' class='m'>*</a> <a id='1560' tid='1559' class='m'>ptr</a> = <a id='1562' tid='1561' class='m'>reinterpret_cast</a>&lt;<a id='1564' tid='1563' class='m'>int8_t</a><a id='1566' tid='1565' class='m'>*</a>&gt;(<a id='1568' tid='1567' class='m'>addr</a>);
  <a id='1570' tid='1569' class='m'>return</a> <a id='1572' tid='1571' class='m'>*</a><a id='1574' tid='1573' class='m'>ptr</a>;
}


<a id='1576' tid='1575' class='m'>void</a> <a id='1578' tid='1577' class='m'>Simulator</a><a id='1580' tid='1579' class='m'>::</a><a id='1582' tid='1581' class='m'>WriteB</a>(<a id='1584' tid='1583' class='m'>int32_t</a> <a id='1586' tid='1585' class='m'>addr</a>, <a id='1588' tid='1587' class='m'>uint8_t</a> <a id='1590' tid='1589' class='m'>value</a>) {
  <a id='1592' tid='1591' class='m'>uint8_t</a><a id='1594' tid='1593' class='m'>*</a> <a id='1596' tid='1595' class='m'>ptr</a> = <a id='1598' tid='1597' class='m'>reinterpret_cast</a>&lt;<a id='1600' tid='1599' class='m'>uint8_t</a><a id='1602' tid='1601' class='m'>*</a>&gt;(<a id='1604' tid='1603' class='m'>addr</a>);
  <a id='1606' tid='1605' class='m'>*</a><a id='1608' tid='1607' class='m'>ptr</a> <a id='1610' tid='1609' class='m'>=</a> <a id='1612' tid='1611' class='m'>value</a>;
}


<a id='1514' tid='1513' class='m'>void</a> <a id='1516' tid='1515' class='m'>Simulator</a><a id='1518' tid='1517' class='m'>::</a><a id='1520' tid='1519' class='m'>WriteB</a>(<a id='1522' tid='1521' class='m'>int32_t</a> <a id='1524' tid='1523' class='m'>addr</a>, <a id='1526' tid='1525' class='m'>int8_t</a> <a id='1528' tid='1527' class='m'>value</a>) {
  <a id='1530' tid='1529' class='m'>int8_t</a><a id='1532' tid='1531' class='m'>*</a> <a id='1534' tid='1533' class='m'>ptr</a> = <a id='1536' tid='1535' class='m'>reinterpret_cast</a>&lt;<a id='1538' tid='1537' class='m'>int8_t</a><a id='1540' tid='1539' class='m'>*</a>&gt;(<a id='1542' tid='1541' class='m'>addr</a>);
  <a id='1544' tid='1543' class='m'>*</a><a id='1546' tid='1545' class='m'>ptr</a> <a id='1548' tid='1547' class='m'>=</a> <a id='1550' tid='1549' class='m'>value</a>;
}


<span class='i'>int32_t* Simulator::ReadDW(int32_t addr) {
#if V8_TARGET_CAN_READ_UNALIGNED
  int32_t* ptr = reinterpret_cast&lt;int32_t*&gt;(addr);
  return ptr;
#else
  if ((addr & 3) == 0) {
    int32_t* ptr = reinterpret_cast&lt;int32_t*&gt;(addr);
    return ptr;
  }
  PrintF(&quot;Unaligned read at 0x%08x\n&quot;, addr);
  UNIMPLEMENTED();
  return 0;
#endif
}</span>


<span class='i'>void Simulator::WriteDW(int32_t addr, int32_t value1, int32_t value2) {
#if V8_TARGET_CAN_READ_UNALIGNED
  int32_t* ptr = reinterpret_cast&lt;int32_t*&gt;(addr);
  *ptr++ = value1;
  *ptr = value2;
  return;
#else
  if ((addr & 3) == 0) {
    int32_t* ptr = reinterpret_cast&lt;int32_t*&gt;(addr);
    *ptr++ = value1;
    *ptr = value2;
    return;
  }
  PrintF(&quot;Unaligned write at 0x%08x\n&quot;, addr);
  UNIMPLEMENTED();
#endif
}</span>


// Returns the limit of the stack area to enable checking for stack overflows.
<a id='1500' tid='1499' class='m'>uintptr_t</a> <a id='1502' tid='1501' class='m'>Simulator</a><a id='1504' tid='1503' class='m'>::</a><a id='1506' tid='1505' class='m'>StackLimit</a>() <a id='1508' tid='1507' class='m'>const</a> {
  // Leave a safety margin of 256 bytes to prevent overrunning the stack when
  // pushing values.
  <a id='1484' tid='1483' class='m'>return</a> <a id='1486' tid='1485' class='m'>reinterpret_cast</a>&lt;<a id='1488' tid='1487' class='m'>uintptr_t</a>&gt;(<a id='1490' tid='1489' class='m'>stack_</a>) <a id='1492' tid='1491' class='m'>+</a> <a id='1494' tid='1493' class='m'>256</a>;
}


// Unsupported instructions use Format to print an error and stop execution.
<a id='1446' tid='1445' class='m'>void</a> <a id='1448' tid='1447' class='m'>Simulator</a><a id='1450' tid='1449' class='m'>::</a><a id='1452' tid='1451' class='m'>Format</a>(<a id='1454' tid='1453' class='m'>Instruction</a><a id='1456' tid='1455' class='m'>*</a> <a id='1458' tid='1457' class='m'>instr</a>, <a id='1460' tid='1459' class='m'>const</a> <a id='1462' tid='1461' class='m'>char</a><a id='1464' tid='1463' class='m'>*</a> <a id='1466' tid='1465' class='m'>format</a>) {
  <a id='1468' tid='1467' class='m'>PrintF</a>(<a id='1470' tid='1469' class='m'>&quot;Simulator found unsupported instruction:\n 0x%08x: %s\n&quot;</a>,
         <a id='1472' tid='1471' class='m'>reinterpret_cast</a>&lt;<a id='1474' tid='1473' class='m'>intptr_t</a>&gt;(<a id='1476' tid='1475' class='m'>instr</a>), <a id='1478' tid='1477' class='m'>format</a>);
  <span class='i'>UNIMPLEMENTED();</span>
}


// Checks if the current instruction should be executed based on its
// condition bits.
<span class='i'>bool Simulator::ConditionallyExecute(Instruction* instr) {
  switch (instr-&gt;ConditionField()) {
    case eq: return z_flag_;
    case ne: return !z_flag_;
    case cs: return c_flag_;
    case cc: return !c_flag_;
    case mi: return n_flag_;
    case pl: return !n_flag_;
    case vs: return v_flag_;
    case vc: return !v_flag_;
    case hi: return c_flag_ && !z_flag_;
    case ls: return !c_flag_ || z_flag_;
    case ge: return n_flag_ == v_flag_;
    case lt: return n_flag_ != v_flag_;
    case gt: return !z_flag_ && (n_flag_ == v_flag_);
    case le: return z_flag_ || (n_flag_ != v_flag_);
    case al: return true;
    default: UNREACHABLE();
  }
  return false;
}</span>


// Calculate and set the Negative and Zero flags.
<span class='i'>void Simulator::SetNZFlags(int32_t val) {
  n_flag_ = (val &lt; 0);
  z_flag_ = (val == 0);
}</span>


// Set the Carry flag.
<span class='i'>void Simulator::SetCFlag(bool val) {
  c_flag_ = val;
}</span>


// Set the oVerflow flag.
<span class='i'>void Simulator::SetVFlag(bool val) {
  v_flag_ = val;
}</span>


// Calculate C flag value for additions.
<span class='i'>bool Simulator::CarryFrom(int32_t left, int32_t right, int32_t carry) {
  uint32_t uleft = static_cast&lt;uint32_t&gt;(left);
  uint32_t uright = static_cast&lt;uint32_t&gt;(right);
  uint32_t urest  = 0xffffffffU - uleft;

  return (uright &gt; urest) ||
         (carry && (((uright + 1) &gt; urest) || (uright &gt; (urest - 1))));
}</span>


// Calculate C flag value for subtractions.
<span class='i'>bool Simulator::BorrowFrom(int32_t left, int32_t right) {
  uint32_t uleft = static_cast&lt;uint32_t&gt;(left);
  uint32_t uright = static_cast&lt;uint32_t&gt;(right);

  return (uright &gt; uleft);
}</span>


// Calculate V flag value for additions and subtractions.
<span class='i'>bool Simulator::OverflowFrom(int32_t alu_out,
                             int32_t left, int32_t right, bool addition) {
  bool overflow;
  if (addition) {
               // operands have the same sign
    overflow = ((left &gt;= 0 && right &gt;= 0) || (left &lt; 0 && right &lt; 0))
               // and operands and result have different sign
               && ((left &lt; 0 && alu_out &gt;= 0) || (left &gt;= 0 && alu_out &lt; 0));
  } else {
               // operands have different signs
    overflow = ((left &lt; 0 && right &gt;= 0) || (left &gt;= 0 && right &lt; 0))
               // and first operand and result have different signs
               && ((left &lt; 0 && alu_out &gt;= 0) || (left &gt;= 0 && alu_out &lt; 0));
  }
  return overflow;
}</span>


// Support for VFP comparisons.
<span class='i'>void Simulator::Compute_FPSCR_Flags(double val1, double val2) {
  if (isnan(val1) || isnan(val2)) {
    n_flag_FPSCR_ = false;
    z_flag_FPSCR_ = false;
    c_flag_FPSCR_ = true;
    v_flag_FPSCR_ = true;
  // All non-NaN cases.
  } else if (val1 == val2) {
    n_flag_FPSCR_ = false;
    z_flag_FPSCR_ = true;
    c_flag_FPSCR_ = true;
    v_flag_FPSCR_ = false;
  } else if (val1 &lt; val2) {
    n_flag_FPSCR_ = true;
    z_flag_FPSCR_ = false;
    c_flag_FPSCR_ = false;
    v_flag_FPSCR_ = false;
  } else {
    // Case when (val1 &gt; val2).
    n_flag_FPSCR_ = false;
    z_flag_FPSCR_ = false;
    c_flag_FPSCR_ = true;
    v_flag_FPSCR_ = false;
  }
}</span>


<span class='i'>void Simulator::Copy_FPSCR_to_APSR() {
  n_flag_ = n_flag_FPSCR_;
  z_flag_ = z_flag_FPSCR_;
  c_flag_ = c_flag_FPSCR_;
  v_flag_ = v_flag_FPSCR_;
}</span>


// Addressing Mode 1 - Data-processing operands:
// Get the value based on the shifter_operand with register.
<span class='i'>int32_t Simulator::GetShiftRm(Instruction* instr, bool* carry_out) {
  ShiftOp shift = instr-&gt;ShiftField();
  int shift_amount = instr-&gt;ShiftAmountValue();
  int32_t result = get_register(instr-&gt;RmValue());
  if (instr-&gt;Bit(4) == 0) {
    // by immediate
    if ((shift == ROR) && (shift_amount == 0)) {
      UNIMPLEMENTED();
      return result;
    } else if (((shift == LSR) || (shift == ASR)) && (shift_amount == 0)) {
      shift_amount = 32;
    }
    switch (shift) {
      case ASR: {
        if (shift_amount == 0) {
          if (result &lt; 0) {
            result = 0xffffffff;
            *carry_out = true;
          } else {
            result = 0;
            *carry_out = false;
          }
        } else {
          result &gt;&gt;= (shift_amount - 1);
          *carry_out = (result & 1) == 1;
          result &gt;&gt;= 1;
        }
        break;
      }

      case LSL: {
        if (shift_amount == 0) {
          *carry_out = c_flag_;
        } else {
          result &lt;&lt;= (shift_amount - 1);
          *carry_out = (result &lt; 0);
          result &lt;&lt;= 1;
        }
        break;
      }

      case LSR: {
        if (shift_amount == 0) {
          result = 0;
          *carry_out = c_flag_;
        } else {
          uint32_t uresult = static_cast&lt;uint32_t&gt;(result);
          uresult &gt;&gt;= (shift_amount - 1);
          *carry_out = (uresult & 1) == 1;
          uresult &gt;&gt;= 1;
          result = static_cast&lt;int32_t&gt;(uresult);
        }
        break;
      }

      case ROR: {
        UNIMPLEMENTED();
        break;
      }

      default: {
        UNREACHABLE();
        break;
      }
    }
  } else {
    // by register
    int rs = instr-&gt;RsValue();
    shift_amount = get_register(rs) &0xff;
    switch (shift) {
      case ASR: {
        if (shift_amount == 0) {
          *carry_out = c_flag_;
        } else if (shift_amount &lt; 32) {
          result &gt;&gt;= (shift_amount - 1);
          *carry_out = (result & 1) == 1;
          result &gt;&gt;= 1;
        } else {
          ASSERT(shift_amount &gt;= 32);
          if (result &lt; 0) {
            *carry_out = true;
            result = 0xffffffff;
          } else {
            *carry_out = false;
            result = 0;
          }
        }
        break;
      }

      case LSL: {
        if (shift_amount == 0) {
          *carry_out = c_flag_;
        } else if (shift_amount &lt; 32) {
          result &lt;&lt;= (shift_amount - 1);
          *carry_out = (result &lt; 0);
          result &lt;&lt;= 1;
        } else if (shift_amount == 32) {
          *carry_out = (result & 1) == 1;
          result = 0;
        } else {
          ASSERT(shift_amount &gt; 32);
          *carry_out = false;
          result = 0;
        }
        break;
      }

      case LSR: {
        if (shift_amount == 0) {
          *carry_out = c_flag_;
        } else if (shift_amount &lt; 32) {
          uint32_t uresult = static_cast&lt;uint32_t&gt;(result);
          uresult &gt;&gt;= (shift_amount - 1);
          *carry_out = (uresult & 1) == 1;
          uresult &gt;&gt;= 1;
          result = static_cast&lt;int32_t&gt;(uresult);
        } else if (shift_amount == 32) {
          *carry_out = (result &lt; 0);
          result = 0;
        } else {
          *carry_out = false;
          result = 0;
        }
        break;
      }

      case ROR: {
        UNIMPLEMENTED();
        break;
      }

      default: {
        UNREACHABLE();
        break;
      }
    }
  }
  return result;
}</span>


// Addressing Mode 1 - Data-processing operands:
// Get the value based on the shifter_operand with immediate.
<span class='i'>int32_t Simulator::GetImm(Instruction* instr, bool* carry_out) {
  int rotate = instr-&gt;RotateValue() * 2;
  int immed8 = instr-&gt;Immed8Value();
  int imm = (immed8 &gt;&gt; rotate) | (immed8 &lt;&lt; (32 - rotate));
  *carry_out = (rotate == 0) ? c_flag_ : (imm &lt; 0);
  return imm;
}</span>


<span class='i'>static int count_bits(int bit_vector) {
  int count = 0;
  while (bit_vector != 0) {
    if ((bit_vector & 1) != 0) {
      count++;
    }
    bit_vector &gt;&gt;= 1;
  }
  return count;
}</span>


<span class='i'>void Simulator::ProcessPUW(Instruction* instr,
                           int num_regs,
                           int reg_size,
                           intptr_t* start_address,
                           intptr_t* end_address) {
  int rn = instr-&gt;RnValue();
  int32_t rn_val = get_register(rn);
  switch (instr-&gt;PUField()) {
    case da_x: {
      UNIMPLEMENTED();
      break;
    }
    case ia_x: {
      *start_address = rn_val;
      *end_address = rn_val + (num_regs * reg_size) - reg_size;
      rn_val = rn_val + (num_regs * reg_size);
      break;
    }
    case db_x: {
      *start_address = rn_val - (num_regs * reg_size);
      *end_address = rn_val - reg_size;
      rn_val = *start_address;
      break;
    }
    case ib_x: {
      *start_address = rn_val + reg_size;
      *end_address = rn_val + (num_regs * reg_size);
      rn_val = *end_address;
      break;
    }
    default: {
      UNREACHABLE();
      break;
    }
  }
  if (instr-&gt;HasW()) {
    set_register(rn, rn_val);
  }
}</span>

// Addressing Mode 4 - Load and Store Multiple
<span class='i'>void Simulator::HandleRList(Instruction* instr, bool load) {
  int rlist = instr-&gt;RlistValue();
  int num_regs = count_bits(rlist);

  intptr_t start_address = 0;
  intptr_t end_address = 0;
  ProcessPUW(instr, num_regs, kPointerSize, &start_address, &end_address);

  intptr_t* address = reinterpret_cast&lt;intptr_t*&gt;(start_address);
  int reg = 0;
  while (rlist != 0) {
    if ((rlist & 1) != 0) {
      if (load) {
        set_register(reg, *address);
      } else {
        *address = get_register(reg);
      }
      address += 1;
    }
    reg++;
    rlist &gt;&gt;= 1;
  }
  ASSERT(end_address == ((intptr_t)address) - 4);
}</span>


// Addressing Mode 6 - Load and Store Multiple Coprocessor registers.
<span class='i'>void Simulator::HandleVList(Instruction* instr) {
  VFPRegPrecision precision =
      (instr-&gt;SzValue() == 0) ? kSinglePrecision : kDoublePrecision;
  int operand_size = (precision == kSinglePrecision) ? 4 : 8;

  bool load = (instr-&gt;VLValue() == 0x1);

  int vd;
  int num_regs;
  vd = instr-&gt;VFPDRegValue(precision);
  if (precision == kSinglePrecision) {
    num_regs = instr-&gt;Immed8Value();
  } else {
    num_regs = instr-&gt;Immed8Value() / 2;
  }

  intptr_t start_address = 0;
  intptr_t end_address = 0;
  ProcessPUW(instr, num_regs, operand_size, &start_address, &end_address);

  intptr_t* address = reinterpret_cast&lt;intptr_t*&gt;(start_address);
  for (int reg = vd; reg &lt; vd + num_regs; reg++) {
    if (precision == kSinglePrecision) {
      if (load) {
        set_s_register_from_sinteger(
            reg, ReadW(reinterpret_cast&lt;int32_t&gt;(address), instr));
      } else {
        WriteW(reinterpret_cast&lt;int32_t&gt;(address),
               get_sinteger_from_s_register(reg), instr);
      }
      address += 1;
    } else {
      if (load) {
        set_s_register_from_sinteger(
            2 * reg, ReadW(reinterpret_cast&lt;int32_t&gt;(address), instr));
        set_s_register_from_sinteger(
            2 * reg + 1, ReadW(reinterpret_cast&lt;int32_t&gt;(address + 1), instr));
      } else {
        WriteW(reinterpret_cast&lt;int32_t&gt;(address),
               get_sinteger_from_s_register(2 * reg), instr);
        WriteW(reinterpret_cast&lt;int32_t&gt;(address + 1),
               get_sinteger_from_s_register(2 * reg + 1), instr);
      }
      address += 2;
    }
  }
  ASSERT(reinterpret_cast&lt;intptr_t&gt;(address) - operand_size == end_address);
}</span>


// Calls into the V8 runtime are based on this very simple interface.
// Note: To be able to return two values from some calls the code in runtime.cc
// uses the ObjectPair which is essentially two 32-bit values stuffed into a
// 64-bit value. With the code below we assume that all runtime calls return
// 64 bits of result. If they don&#39;t, the r1 result register contains a bogus
// value, which is fine because it is caller-saved.
<a id='1410' tid='1409' class='m'>typedef</a> <a id='1412' tid='1411' class='m'>int64_t</a> (<a id='1414' tid='1413' class='m'>*</a><a id='1416' tid='1415' class='m'>SimulatorRuntimeCall</a>)(<a id='1418' tid='1417' class='m'>int32_t</a> <a id='1420' tid='1419' class='m'>arg0</a>,
                                        <a id='1422' tid='1421' class='m'>int32_t</a> <a id='1424' tid='1423' class='m'>arg1</a>,
                                        <a id='1426' tid='1425' class='m'>int32_t</a> <a id='1428' tid='1427' class='m'>arg2</a>,
                                        <a id='1430' tid='1429' class='m'>int32_t</a> <a id='1432' tid='1431' class='m'>arg3</a>,
                                        <a id='1434' tid='1433' class='m'>int32_t</a> <a id='1436' tid='1435' class='m'>arg4</a>,
                                        <a id='1438' tid='1437' class='m'>int32_t</a> <a id='1440' tid='1439' class='m'>arg5</a>);
<a id='1382' tid='1381' class='m'>typedef</a> <a id='1384' tid='1383' class='m'>double</a> (<a id='1386' tid='1385' class='m'>*</a><a id='1388' tid='1387' class='m'>SimulatorRuntimeFPCall</a>)(<a id='1390' tid='1389' class='m'>int32_t</a> <a id='1392' tid='1391' class='m'>arg0</a>,
                                         <a id='1394' tid='1393' class='m'>int32_t</a> <a id='1396' tid='1395' class='m'>arg1</a>,
                                         <a id='1398' tid='1397' class='m'>int32_t</a> <a id='1400' tid='1399' class='m'>arg2</a>,
                                         <a id='1402' tid='1401' class='m'>int32_t</a> <a id='1404' tid='1403' class='m'>arg3</a>);

// This signature supports direct call in to API function native callback
// (refer to InvocationCallback in v8.h).
<a id='1356' tid='1355' class='m'>typedef</a> <a id='1358' tid='1357' class='m'>v8</a><a id='1360' tid='1359' class='m'>::</a><a id='1362' tid='1361' class='m'>Handle</a>&lt;<a id='1364' tid='1363' class='m'>v8</a><a id='1366' tid='1365' class='m'>::</a><a id='1368' tid='1367' class='m'>Value</a>&gt; (<a id='1370' tid='1369' class='m'>*</a><a id='1372' tid='1371' class='m'>SimulatorRuntimeDirectApiCall</a>)(<a id='1374' tid='1373' class='m'>int32_t</a> <a id='1376' tid='1375' class='m'>arg0</a>);

// This signature supports direct call to accessor getter callback.
<a id='1326' tid='1325' class='m'>typedef</a> <a id='1328' tid='1327' class='m'>v8</a><a id='1330' tid='1329' class='m'>::</a><a id='1332' tid='1331' class='m'>Handle</a>&lt;<a id='1334' tid='1333' class='m'>v8</a><a id='1336' tid='1335' class='m'>::</a><a id='1338' tid='1337' class='m'>Value</a>&gt; (<a id='1340' tid='1339' class='m'>*</a><a id='1342' tid='1341' class='m'>SimulatorRuntimeDirectGetterCall</a>)(<a id='1344' tid='1343' class='m'>int32_t</a> <a id='1346' tid='1345' class='m'>arg0</a>,
                                                                  <a id='1348' tid='1347' class='m'>int32_t</a> <a id='1350' tid='1349' class='m'>arg1</a>);

// Software interrupt instructions are used by the simulator to call into the
// C-based V8 runtime.
<a id='1294' tid='1293' class='m'>void</a> <a id='1296' tid='1295' class='m'>Simulator</a><a id='1298' tid='1297' class='m'>::</a><a id='1300' tid='1299' class='m'>SoftwareInterrupt</a>(<a id='1302' tid='1301' class='m'>Instruction</a><a id='1304' tid='1303' class='m'>*</a> <a id='1306' tid='1305' class='m'>instr</a>) {
  <span class='i'>int svc = instr-&gt;SvcValue();</span>
  <span class='i'>switch</span> (<span class='i'>svc</span>) {
    <span class='i'>case</span> <span class='i'>kCallRtRedirected</span>: {
      // Check if stack is aligned. Error if not aligned is reported below to
      // include information on the function called.
      <span class='i'>bool stack_aligned =
          (get_register(sp)
           & (::v8::internal::FLAG_sim_stack_alignment - 1)) == 0;</span>
      <a id='1308' tid='1307' class='m'>Redirection</a><a id='1310' tid='1309' class='m'>*</a> <a id='1312' tid='1311' class='m'>redirection</a> = <a id='1314' tid='1313' class='m'>Redirection</a><a id='1316' tid='1315' class='m'>::</a><a id='1318' tid='1317' class='m'>FromSwiInstruction</a>(<a id='1320' tid='1319' class='m'>instr</a>);
      <span class='i'>int32_t arg0 = get_register(r0);</span>
      <span class='i'>int32_t arg1 = get_register(r1);</span>
      <span class='i'>int32_t arg2 = get_register(r2);</span>
      <span class='i'>int32_t arg3 = get_register(r3);</span>
      <a id='1278' tid='1277' class='m'>int32_t</a><a id='1280' tid='1279' class='m'>*</a> <a id='1282' tid='1281' class='m'>stack_pointer</a> = <a id='1284' tid='1283' class='m'>reinterpret_cast</a>&lt;<a id='1286' tid='1285' class='m'>int32_t</a><a id='1288' tid='1287' class='m'>*</a>&gt;(<a id='1290' tid='1289' class='m'>get_register</a>(<a id='1292' tid='1291' class='m'>sp</a>));
      <span class='i'>int32_t arg4 = stack_pointer[0];</span>
      <span class='i'>int32_t arg5 = stack_pointer[1];</span>
      <a id='1194' tid='1193' class='m'>bool</a> <a id='1196' tid='1195' class='m'>fp_call</a> =
         (<a id='1198' tid='1197' class='m'>redirection</a>-&gt;<a id='1200' tid='1199' class='m'>type</a>() <a id='1202' tid='1201' class='m'>==</a> <a id='1204' tid='1203' class='m'>ExternalReference</a><a id='1206' tid='1205' class='m'>::</a><a id='1208' tid='1207' class='m'>BUILTIN_FP_FP_CALL</a>) <a id='1210' tid='1209' class='m'>||</a>
         (<a id='1212' tid='1211' class='m'>redirection</a>-&gt;<a id='1214' tid='1213' class='m'>type</a>() <a id='1216' tid='1215' class='m'>==</a> <a id='1218' tid='1217' class='m'>ExternalReference</a><a id='1220' tid='1219' class='m'>::</a><a id='1222' tid='1221' class='m'>BUILTIN_COMPARE_CALL</a>) <a id='1224' tid='1223' class='m'>||</a>
         (<a id='1226' tid='1225' class='m'>redirection</a>-&gt;<a id='1228' tid='1227' class='m'>type</a>() <a id='1230' tid='1229' class='m'>==</a> <a id='1232' tid='1231' class='m'>ExternalReference</a><a id='1234' tid='1233' class='m'>::</a><a id='1236' tid='1235' class='m'>BUILTIN_FP_CALL</a>) <a id='1238' tid='1237' class='m'>||</a>
         (<a id='1240' tid='1239' class='m'>redirection</a>-&gt;<a id='1242' tid='1241' class='m'>type</a>() <a id='1244' tid='1243' class='m'>==</a> <a id='1246' tid='1245' class='m'>ExternalReference</a><a id='1248' tid='1247' class='m'>::</a><a id='1250' tid='1249' class='m'>BUILTIN_FP_INT_CALL</a>);
      <span class='i'>if</span> <span class='i'>(use_eabi_hardfloat())</span> {
        // With the hard floating point calling convention, double
        // arguments are passed in VFP registers. Fetch the arguments
        // from there and call the builtin using soft floating point
        // convention.
        <a id='1154' tid='1153' class='m'>switch</a> (<a id='1156' tid='1155' class='m'>redirection</a>-&gt;<a id='1158' tid='1157' class='m'>type</a>()) {
        <span class='i'>case</span> <a id='1160' tid='1159' class='m'>ExternalReference</a><a id='1162' tid='1161' class='m'>::</a><a id='1164' tid='1163' class='m'>BUILTIN_FP_FP_CALL</a>:
        <a id='1120' tid='1119' class='m'>case</a> <a id='1122' tid='1121' class='m'>ExternalReference</a><a id='1124' tid='1123' class='m'>::</a><a id='1126' tid='1125' class='m'>BUILTIN_COMPARE_CALL</a>:
          <span class='i'>arg0 = vfp_register[0]</span>;
          <span class='i'>arg1 = vfp_register[1];</span>
          <span class='i'>arg2 = vfp_register[2];</span>
          <span class='i'>arg3 = vfp_register[3];</span>
          <span class='i'>break;</span>
        <a id='1060' tid='1059' class='m'>case</a> <a id='1062' tid='1061' class='m'>ExternalReference</a><a id='1064' tid='1063' class='m'>::</a><a id='1066' tid='1065' class='m'>BUILTIN_FP_CALL</a>:
          <span class='i'>arg0 = vfp_register[0]</span>;
          <span class='i'>arg1 = vfp_register[1];</span>
          <span class='i'>break;</span>
        <a id='796' tid='795' class='m'>case</a> <a id='798' tid='797' class='m'>ExternalReference</a><a id='800' tid='799' class='m'>::</a><a id='802' tid='801' class='m'>BUILTIN_FP_INT_CALL</a>:
          <span class='i'>arg0 = vfp_register[0]</span>;
          <span class='i'>arg1 = vfp_register[1];</span>
          <span class='i'>arg2 = get_register(0);</span>
          <span class='i'>break;</span>
        <a id='602' tid='601' class='m'>default</a>:
          <a id='604' tid='603' class='m'>break</a>;
        }
      }
      // This is dodgy but it works because the C entry stubs are never moved.
      // See comment in codegen-arm.cc and bug 1242173.
      <span class='i'>int32_t saved_lr = get_register(lr);</span>
      <a id='1108' tid='1107' class='m'>intptr_t</a> <a id='1110' tid='1109' class='m'>external</a> =
          <a id='1112' tid='1111' class='m'>reinterpret_cast</a>&lt;<a id='1114' tid='1113' class='m'>intptr_t</a>&gt;(<a id='1116' tid='1115' class='m'>redirection</a>-&gt;<a id='1118' tid='1117' class='m'>external_function</a>());
      <span class='i'>if</span> <span class='i'>(fp_call)</span> {
        <span class='i'>if</span> (<a id='966' tid='965' class='m'>::</a><a id='968' tid='967' class='m'>v8</a><a id='970' tid='969' class='m'>::</a><a id='972' tid='971' class='m'>internal</a><a id='974' tid='973' class='m'>::</a><a id='976' tid='975' class='m'>FLAG_trace_sim</a> <span class='i'>||</span> <span class='i'>!stack_aligned</span>) {
          <a id='1050' tid='1049' class='m'>SimulatorRuntimeFPCall</a> <a id='1052' tid='1051' class='m'>target</a> =
              <a id='1054' tid='1053' class='m'>reinterpret_cast</a>&lt;<a id='1056' tid='1055' class='m'>SimulatorRuntimeFPCall</a>&gt;(<a id='1058' tid='1057' class='m'>external</a>);
          <a id='978' tid='977' class='m'>double</a> <a id='980' tid='979' class='m'>dval0</a>, <a id='982' tid='981' class='m'>dval1</a>;
          <a id='816' tid='815' class='m'>int32_t</a> <a id='818' tid='817' class='m'>ival</a>;
          <span class='i'>switch</span> (<span class='i'>redirection-&gt;type()</span>) {
          <a id='118' tid='117' class='m'>case</a> <a id='532' tid='531' class='m'>ExternalReference</a><a id='534' tid='533' class='m'>::</a><a id='536' tid='535' class='m'>BUILTIN_FP_FP_CALL</a>:
          <a id='426' tid='425' class='m'>case</a> <a id='428' tid='427' class='m'>ExternalReference</a><a id='430' tid='429' class='m'>::</a><a id='432' tid='431' class='m'>BUILTIN_COMPARE_CALL</a>:
            <a id='434' tid='433' class='m'>GetFpArgs</a>(<a id='436' tid='435' class='m'>&</a><a id='438' tid='437' class='m'>dval0</a>, <a id='440' tid='439' class='m'>&</a><a id='442' tid='441' class='m'>dval1</a>);
            <a id='354' tid='353' class='m'>PrintF</a>(<span class='i'>&quot;Call to host function at %p with args %f, %f&quot;</span>,
                <a id='356' tid='355' class='m'>FUNCTION_ADDR</a>(<a id='358' tid='357' class='m'>target</a>), <span class='i'>dval0</span>, <span class='i'>dval1</span>);
            <a id='120' tid='119' class='m'>break</a>;
          <a id='314' tid='313' class='m'>case</a> <a id='316' tid='315' class='m'>ExternalReference</a><a id='318' tid='317' class='m'>::</a><a id='320' tid='319' class='m'>BUILTIN_FP_CALL</a>:
            <a id='322' tid='321' class='m'>GetFpArgs</a>(<a id='324' tid='323' class='m'>&</a><a id='326' tid='325' class='m'>dval0</a>);
            <a id='216' tid='215' class='m'>PrintF</a>(<span class='i'>&quot;Call to host function at %p with arg %f&quot;</span>,
                <a id='218' tid='217' class='m'>FUNCTION_ADDR</a>(<a id='220' tid='219' class='m'>target</a>), <span class='i'>dval0</span>);
            <a id='122' tid='121' class='m'>break</a>;
          <a id='184' tid='183' class='m'>case</a> <a id='186' tid='185' class='m'>ExternalReference</a><a id='188' tid='187' class='m'>::</a><a id='190' tid='189' class='m'>BUILTIN_FP_INT_CALL</a>:
            <a id='192' tid='191' class='m'>GetFpArgs</a>(<a id='194' tid='193' class='m'>&</a><a id='196' tid='195' class='m'>dval0</a>, <a id='198' tid='197' class='m'>&</a><a id='200' tid='199' class='m'>ival</a>);
            <a id='146' tid='145' class='m'>PrintF</a>(<span class='i'>&quot;Call to host function at %p with args %f, %d&quot;</span>,
                <a id='148' tid='147' class='m'>FUNCTION_ADDR</a>(<a id='150' tid='149' class='m'>target</a>), <span class='i'>dval0</span>, <span class='i'>ival</span>);
            <a id='124' tid='123' class='m'>break</a>;
          <a id='126' tid='125' class='m'>default</a>:
            <a id='128' tid='127' class='m'>UNREACHABLE</a>();
            <a id='130' tid='129' class='m'>break</a>;
          }
          <span class='i'>if (!stack_aligned) {
            PrintF(&quot; with unaligned stack %08x\n&quot;, get_register(sp));
          }</span>
          <span class='i'>PrintF(&quot;\n&quot;);</span>
        }
        <span class='i'>CHECK(stack_aligned);</span>
        <span class='i'>if</span> (<a id='804' tid='803' class='m'>redirection</a>-&gt;<a id='806' tid='805' class='m'>type</a>() <a id='808' tid='807' class='m'>!=</a> <a id='810' tid='809' class='m'>ExternalReference</a><a id='812' tid='811' class='m'>::</a><a id='814' tid='813' class='m'>BUILTIN_COMPARE_CALL</a>) {
          <span class='i'>SimulatorRuntimeFPCall target =
              reinterpret_cast&lt;SimulatorRuntimeFPCall&gt;(external);</span>
          <span class='i'>double</span> <a id='606' tid='605' class='m'>result</a> = <a id='608' tid='607' class='m'>target</a>(<a id='610' tid='609' class='m'>arg0</a>, <a id='612' tid='611' class='m'>arg1</a>, <a id='614' tid='613' class='m'>arg2</a>, <a id='616' tid='615' class='m'>arg3</a>);
          <span class='i'>SetFpResult(result);</span>
        } <span class='i'>else</span> {
          <span class='i'>SimulatorRuntimeCall target =
              reinterpret_cast&lt;SimulatorRuntimeCall&gt;(external);</span>
          <span class='i'>int64_t result = target(arg0, arg1, arg2, arg3, arg4, arg5);</span>
          <span class='i'>int32_t</span> <span class='i'>lo_res</span> = <a id='360' tid='359' class='m'>static_cast</a>&lt;<a id='362' tid='361' class='m'>int32_t</a>&gt;<span class='i'>(result)</span>;
          <span class='i'>int32_t hi_res = static_cast&lt;int32_t&gt;(result &gt;&gt; 32);</span>
          <span class='i'>if</span> (<a id='328' tid='327' class='m'>::</a><a id='330' tid='329' class='m'>v8</a><a id='332' tid='331' class='m'>::</a><a id='334' tid='333' class='m'>internal</a><a id='336' tid='335' class='m'>::</a><a id='338' tid='337' class='m'>FLAG_trace_sim</a>) <span class='i'>{
            PrintF(&quot;Returned %08x\n&quot;, lo_res);
          }</span>
          <span class='i'>set_register(r0, lo_res);</span>
          <span class='i'>set_register(r1, hi_res);</span>
        }
      } <span class='i'>else</span> <a id='820' tid='819' class='m'>if</a> (<a id='822' tid='821' class='m'>redirection</a>-&gt;<a id='824' tid='823' class='m'>type</a>() <a id='826' tid='825' class='m'>==</a> <a id='828' tid='827' class='m'>ExternalReference</a><a id='830' tid='829' class='m'>::</a><a id='832' tid='831' class='m'>DIRECT_API_CALL</a>) {
        <a id='872' tid='871' class='m'>SimulatorRuntimeDirectApiCall</a> <a id='874' tid='873' class='m'>target</a> =
            <a id='876' tid='875' class='m'>reinterpret_cast</a>&lt;<a id='878' tid='877' class='m'>SimulatorRuntimeDirectApiCall</a>&gt;(<a id='880' tid='879' class='m'>external</a>);
        <a id='882' tid='881' class='m'>if</a> (<a id='954' tid='953' class='m'>::</a><a id='956' tid='955' class='m'>v8</a><a id='958' tid='957' class='m'>::</a><a id='960' tid='959' class='m'>internal</a><a id='962' tid='961' class='m'>::</a><a id='964' tid='963' class='m'>FLAG_trace_sim</a> <span class='i'>||</span> <span class='i'>!stack_aligned</span>) {
          <span class='i'>PrintF</span>(<span class='i'>&quot;Call to host function at %p args %08x&quot;</span>,
              <a id='884' tid='883' class='m'>FUNCTION_ADDR</a>(<a id='886' tid='885' class='m'>target</a>), <span class='i'>arg0</span>);
          <span class='i'>if (!stack_aligned) {
            PrintF(&quot; with unaligned stack %08x\n&quot;, get_register(sp));
          }</span>
          <span class='i'>PrintF(&quot;\n&quot;);</span>
        }
        <span class='i'>CHECK(stack_aligned);</span>
        <a id='444' tid='443' class='m'>v8</a><a id='446' tid='445' class='m'>::</a><a id='448' tid='447' class='m'>Handle</a>&lt;<a id='450' tid='449' class='m'>v8</a><a id='452' tid='451' class='m'>::</a><a id='454' tid='453' class='m'>Value</a>&gt; <span class='i'>result = target(arg0)</span>;
        <span class='i'>if</span> (<a id='618' tid='617' class='m'>::</a><a id='620' tid='619' class='m'>v8</a><a id='622' tid='621' class='m'>::</a><a id='624' tid='623' class='m'>internal</a><a id='626' tid='625' class='m'>::</a><a id='628' tid='627' class='m'>FLAG_trace_sim</a>) {
          <span class='i'>PrintF</span>(<span class='i'>&quot;Returned %p\n&quot;</span>, <span class='i'>reinterpret_cast&lt;void *&gt;</span>(<a id='538' tid='537' class='m'>*</a><a id='540' tid='539' class='m'>result</a>));
        }
        <span class='i'>set_register(r0, (int32_t) *result);</span>
      } <a id='834' tid='833' class='m'>else</a> <a id='836' tid='835' class='m'>if</a> (<a id='838' tid='837' class='m'>redirection</a>-&gt;<a id='840' tid='839' class='m'>type</a>() <a id='842' tid='841' class='m'>==</a> <a id='844' tid='843' class='m'>ExternalReference</a><a id='846' tid='845' class='m'>::</a><a id='848' tid='847' class='m'>DIRECT_GETTER_CALL</a>) {
        <a id='850' tid='849' class='m'>SimulatorRuntimeDirectGetterCall</a> <a id='852' tid='851' class='m'>target</a> =
            <a id='854' tid='853' class='m'>reinterpret_cast</a>&lt;<a id='856' tid='855' class='m'>SimulatorRuntimeDirectGetterCall</a>&gt;(<a id='858' tid='857' class='m'>external</a>);
        <span class='i'>if</span> <span class='i'>(::v8::internal::FLAG_trace_sim || !stack_aligned)</span> {
          <a id='630' tid='629' class='m'>PrintF</a>(<span class='i'>&quot;Call to host function at %p args %08x %08x&quot;</span>,
              <a id='632' tid='631' class='m'>FUNCTION_ADDR</a>(<a id='634' tid='633' class='m'>target</a>), <span class='i'>arg0</span>, <span class='i'>arg1</span>);
          <span class='i'>if (!stack_aligned) {
            PrintF(&quot; with unaligned stack %08x\n&quot;, get_register(sp));
          }</span>
          <span class='i'>PrintF(&quot;\n&quot;);</span>
        }
        <span class='i'>CHECK(stack_aligned);</span>
        <a id='542' tid='541' class='m'>v8</a><a id='544' tid='543' class='m'>::</a><a id='546' tid='545' class='m'>Handle</a>&lt;<a id='548' tid='547' class='m'>v8</a><a id='550' tid='549' class='m'>::</a><a id='552' tid='551' class='m'>Value</a>&gt; <span class='i'>result = target(arg0, arg1)</span>;
        <span class='i'>if</span> <span class='i'>(::v8::internal::FLAG_trace_sim)</span> {
          <span class='i'>PrintF</span>(<span class='i'>&quot;Returned %p\n&quot;</span>, <span class='i'>reinterpret_cast&lt;void *&gt;</span>(<a id='456' tid='455' class='m'>*</a><a id='458' tid='457' class='m'>result</a>));
        }
        <span class='i'>set_register(r0, (int32_t) *result);</span>
      } <a id='860' tid='859' class='m'>else</a> {
        // builtin call.
        <span class='i'>ASSERT(redirection-&gt;type() == ExternalReference::BUILTIN_CALL);</span>
        <a id='862' tid='861' class='m'>SimulatorRuntimeCall</a> <a id='864' tid='863' class='m'>target</a> =
            <a id='866' tid='865' class='m'>reinterpret_cast</a>&lt;<a id='868' tid='867' class='m'>SimulatorRuntimeCall</a>&gt;(<a id='870' tid='869' class='m'>external</a>);
        <a id='636' tid='635' class='m'>if</a> (<a id='638' tid='637' class='m'>::</a><a id='640' tid='639' class='m'>v8</a><a id='642' tid='641' class='m'>::</a><a id='644' tid='643' class='m'>internal</a><a id='646' tid='645' class='m'>::</a><a id='648' tid='647' class='m'>FLAG_trace_sim</a> <span class='i'>||</span> <span class='i'>!stack_aligned</span>) {
          <span class='i'>PrintF</span>(
              <span class='i'>&quot;Call to host function at %p&quot;
              &quot;args %08x, %08x, %08x, %08x, %08x, %08x&quot;</span>,
              <a id='650' tid='649' class='m'>FUNCTION_ADDR</a>(<a id='652' tid='651' class='m'>target</a>),
              <span class='i'>arg0</span>,
              <span class='i'>arg1</span>,
              <span class='i'>arg2</span>,
              <span class='i'>arg3</span>,
              <span class='i'>arg4</span>,
              <span class='i'>arg5</span>);
          <span class='i'>if (!stack_aligned) {
            PrintF(&quot; with unaligned stack %08x\n&quot;, get_register(sp));
          }</span>
          <span class='i'>PrintF(&quot;\n&quot;);</span>
        }
        <span class='i'>CHECK(stack_aligned);</span>
        <a id='554' tid='553' class='m'>int64_t</a> <a id='556' tid='555' class='m'>result</a> = <a id='558' tid='557' class='m'>target</a>(<a id='560' tid='559' class='m'>arg0</a>, <a id='562' tid='561' class='m'>arg1</a>, <a id='564' tid='563' class='m'>arg2</a>, <a id='566' tid='565' class='m'>arg3</a>, <a id='568' tid='567' class='m'>arg4</a>, <a id='570' tid='569' class='m'>arg5</a>);
        <span class='i'>int32_t</span> <span class='i'>lo_res</span> = <a id='460' tid='459' class='m'>static_cast</a>&lt;<a id='462' tid='461' class='m'>int32_t</a>&gt;(<a id='464' tid='463' class='m'>result</a>);
        <span class='i'>int32_t hi_res = static_cast&lt;int32_t&gt;(result &gt;&gt; 32);</span>
        <span class='i'>if (::v8::internal::FLAG_trace_sim) {
          PrintF(&quot;Returned %08x\n&quot;, lo_res);
        }</span>
        <span class='i'>set_register(r0, lo_res);</span>
        <span class='i'>set_register(r1, hi_res);</span>
      }
      <span class='i'>set_register(lr, saved_lr);</span>
      <span class='i'>set_pc(get_register(lr));</span>
      <span class='i'>break;</span>
    }
    <span class='i'>case</span> <span class='i'>kBreakpoint</span>: {
      <span class='i'>ArmDebugger dbg(this)</span>;
      <a id='1274' tid='1273' class='m'>dbg</a>.<a id='1276' tid='1275' class='m'>Debug</a>();
      <span class='i'>break;</span>
    }
    // stop uses all codes greater than 1 &lt;&lt; 23.
    <span class='i'>default</span>: {
      <span class='i'>if</span> <span class='i'>(svc &gt;= (1 &lt;&lt; 23))</span> {
        <span class='i'>uint32_t code = svc & kStopCodeMask;</span>
        <span class='i'>if</span> <span class='i'>(isWatchedStop(code))</span> {
          <a id='1252' tid='1251' class='m'>IncreaseStopCounter</a>(<a id='1254' tid='1253' class='m'>code</a>);
        }
        // Stop if it is enabled, otherwise go on jumping over the stop
        // and the message address.
        <span class='i'>if (isEnabledStop(code)) {
          ArmDebugger dbg(this);
          dbg.Stop(instr);
        } else {
          set_pc(get_pc() + 2 * Instruction::kInstrSize);
        }</span>
      } <span class='i'>else {
        // This is not a valid svc code.
        UNREACHABLE();
        break;
      }</span>
    }
  }
}


// Stop helper functions.
<span class='i'>bool Simulator::isStopInstruction(Instruction* instr) {
  return (instr-&gt;Bits(27, 24) == 0xF) && (instr-&gt;SvcValue() &gt;= kStopCode);
}</span>


<span class='i'>bool Simulator::isWatchedStop(uint32_t code) {
  ASSERT(code &lt;= kMaxStopCode);
  return code &lt; kNumOfWatchedStops;
}</span>


<span class='i'>bool</span> <span class='i'>Simulator::isEnabledStop</span><span class='i'>(uint32_t code)</span> {
  <span class='i'>ASSERT(code &lt;= kMaxStopCode);</span>
  // Unwatched stops are always enabled.
  <a id='1256' tid='1255' class='m'>return</a> <span class='i'>!isWatchedStop(code)</span> <span class='i'>||</span>
    <a id='1258' tid='1257' class='m'>!</a>(<a id='1260' tid='1259' class='m'>watched_stops</a>[<a id='1262' tid='1261' class='m'>code</a>].<a id='1264' tid='1263' class='m'>count</a> <a id='1266' tid='1265' class='m'>&</a> <a id='1268' tid='1267' class='m'>kStopDisabledBit</a>);
}


<a id='1166' tid='1165' class='m'>void</a> <a id='1168' tid='1167' class='m'>Simulator</a><a id='1170' tid='1169' class='m'>::</a><a id='1172' tid='1171' class='m'>EnableStop</a>(<a id='1174' tid='1173' class='m'>uint32_t</a> <a id='1176' tid='1175' class='m'>code</a>) {
  <span class='i'>ASSERT(isWatchedStop(code));</span>
  <span class='i'>if</span> <span class='i'>(!isEnabledStop(code))</span> {
    <a id='1178' tid='1177' class='m'>watched_stops</a>[<a id='1180' tid='1179' class='m'>code</a>].<a id='1182' tid='1181' class='m'>count</a> <a id='1184' tid='1183' class='m'>&=</a> <a id='1186' tid='1185' class='m'>~</a><a id='1188' tid='1187' class='m'>kStopDisabledBit</a>;
  }
}


<a id='1128' tid='1127' class='m'>void</a> <a id='1130' tid='1129' class='m'>Simulator</a><a id='1132' tid='1131' class='m'>::</a><a id='1134' tid='1133' class='m'>DisableStop</a>(<a id='1136' tid='1135' class='m'>uint32_t</a> <a id='1138' tid='1137' class='m'>code</a>) {
  <span class='i'>ASSERT(isWatchedStop(code));</span>
  <span class='i'>if</span> <span class='i'>(isEnabledStop(code))</span> {
    <a id='1140' tid='1139' class='m'>watched_stops</a>[<a id='1142' tid='1141' class='m'>code</a>].<a id='1144' tid='1143' class='m'>count</a> <a id='1146' tid='1145' class='m'>|=</a> <a id='1148' tid='1147' class='m'>kStopDisabledBit</a>;
  }
}


<a id='1088' tid='1087' class='m'>void</a> <a id='1090' tid='1089' class='m'>Simulator</a><a id='1092' tid='1091' class='m'>::</a><a id='1094' tid='1093' class='m'>IncreaseStopCounter</a>(<a id='1096' tid='1095' class='m'>uint32_t</a> <a id='1098' tid='1097' class='m'>code</a>) {
  <a id='1100' tid='1099' class='m'>ASSERT</a>(<a id='1102' tid='1101' class='m'>code</a> <a id='1104' tid='1103' class='m'>&lt;=</a> <a id='1106' tid='1105' class='m'>kMaxStopCode</a>);
  <span class='i'>ASSERT(isWatchedStop(code));</span>
  <a id='984' tid='983' class='m'>if</a> ((<a id='1068' tid='1067' class='m'>watched_stops</a>[<a id='1070' tid='1069' class='m'>code</a>].<a id='1072' tid='1071' class='m'>count</a> <a id='1074' tid='1073' class='m'>&</a> <a id='1076' tid='1075' class='m'>~</a>(<a id='1078' tid='1077' class='m'>1</a> <a id='1080' tid='1079' class='m'>&lt;&lt;</a> <a id='1082' tid='1081' class='m'>31</a>)) <a id='1084' tid='1083' class='m'>==</a> <a id='1086' tid='1085' class='m'>0x7fffffff</a>) {
    <a id='986' tid='985' class='m'>PrintF</a>(<a id='988' tid='987' class='m'>&quot;Stop counter for code %i has overflowed.\n&quot;</a>
           <a id='990' tid='989' class='m'>&quot;Enabling this code and reseting the counter to 0.\n&quot;</a>, <a id='992' tid='991' class='m'>code</a>);
    <a id='994' tid='993' class='m'>watched_stops</a>[<a id='996' tid='995' class='m'>code</a>].<a id='998' tid='997' class='m'>count</a> <a id='1000' tid='999' class='m'>=</a> <a id='1002' tid='1001' class='m'>0</a>;
    <a id='1004' tid='1003' class='m'>EnableStop</a>(<a id='1006' tid='1005' class='m'>code</a>);
  } <a id='1008' tid='1007' class='m'>else</a> {
    <a id='1010' tid='1009' class='m'>watched_stops</a>[<a id='1012' tid='1011' class='m'>code</a>].<a id='1014' tid='1013' class='m'>count</a><a id='1016' tid='1015' class='m'>++</a>;
  }
}


// Print a stop status.
<a id='1034' tid='1033' class='m'>void</a> <a id='1036' tid='1035' class='m'>Simulator</a><a id='1038' tid='1037' class='m'>::</a><a id='1040' tid='1039' class='m'>PrintStopInfo</a>(<a id='1042' tid='1041' class='m'>uint32_t</a> <a id='1044' tid='1043' class='m'>code</a>) {
  <span class='i'>ASSERT(code &lt;= kMaxStopCode);</span>
  <span class='i'>if</span> <span class='i'>(!isWatchedStop(code))</span> <span class='i'>{
    PrintF(&quot;Stop not watched.&quot;);
  }</span> <span class='i'>else</span> {
    <span class='i'>const</span> <a id='1046' tid='1045' class='m'>char</a><a id='1048' tid='1047' class='m'>*</a> <span class='i'>state = isEnabledStop(code) ? &quot;Enabled&quot; : &quot;Disabled&quot;</span>;
    <a id='1018' tid='1017' class='m'>int32_t</a> <a id='1020' tid='1019' class='m'>count</a> = <a id='1022' tid='1021' class='m'>watched_stops</a>[<a id='1024' tid='1023' class='m'>code</a>].<a id='1026' tid='1025' class='m'>count</a> <a id='1028' tid='1027' class='m'>&</a> <a id='1030' tid='1029' class='m'>~</a><a id='1032' tid='1031' class='m'>kStopDisabledBit</a>;
    // Don&#39;t print the state of unused breakpoints.
    <a id='888' tid='887' class='m'>if</a> (<a id='890' tid='889' class='m'>count</a> <a id='892' tid='891' class='m'>!=</a> <a id='894' tid='893' class='m'>0</a>) {
      <a id='896' tid='895' class='m'>if</a> (<a id='898' tid='897' class='m'>watched_stops</a>[<a id='900' tid='899' class='m'>code</a>].<a id='902' tid='901' class='m'>desc</a>) {
        <a id='904' tid='903' class='m'>PrintF</a>(<a id='906' tid='905' class='m'>&quot;stop %i - 0x%x: \t%s, \tcounter = %i, \t%s\n&quot;</a>,
               <a id='908' tid='907' class='m'>code</a>, <a id='910' tid='909' class='m'>code</a>, <a id='912' tid='911' class='m'>state</a>, <a id='914' tid='913' class='m'>count</a>, <a id='916' tid='915' class='m'>watched_stops</a>[<a id='918' tid='917' class='m'>code</a>].<a id='920' tid='919' class='m'>desc</a>);
      } <a id='922' tid='921' class='m'>else</a> {
        <a id='924' tid='923' class='m'>PrintF</a>(<a id='926' tid='925' class='m'>&quot;stop %i - 0x%x: \t%s, \tcounter = %i\n&quot;</a>,
               <a id='928' tid='927' class='m'>code</a>, <a id='930' tid='929' class='m'>code</a>, <a id='932' tid='931' class='m'>state</a>, <a id='934' tid='933' class='m'>count</a>);
      }
    }
  }
}


// Handle execution based on instruction types.

// Instruction types 0 and 1 are both rolled into one function because they
// only differ in the handling of the shifter_operand.
<span class='i'>void Simulator::DecodeType01(Instruction* instr) {
  int type = instr-&gt;TypeValue();
  if ((type == 0) && instr-&gt;IsSpecialType0()) {
    // multiply instruction or extra loads and stores
    if (instr-&gt;Bits(7, 4) == 9) {
      if (instr-&gt;Bit(24) == 0) {
        // Raw field decoding here. Multiply instructions have their Rd in
        // funny places.
        int rn = instr-&gt;RnValue();
        int rm = instr-&gt;RmValue();
        int rs = instr-&gt;RsValue();
        int32_t rs_val = get_register(rs);
        int32_t rm_val = get_register(rm);
        if (instr-&gt;Bit(23) == 0) {
          if (instr-&gt;Bit(21) == 0) {
            // The MUL instruction description (A 4.1.33) refers to Rd as being
            // the destination for the operation, but it confusingly uses the
            // Rn field to encode it.
            // Format(instr, &quot;mul&#39;cond&#39;s &#39;rn, &#39;rm, &#39;rs&quot;);
            int rd = rn;  // Remap the rn field to the Rd register.
            int32_t alu_out = rm_val * rs_val;
            set_register(rd, alu_out);
            if (instr-&gt;HasS()) {
              SetNZFlags(alu_out);
            }
          } else {
            // The MLA instruction description (A 4.1.28) refers to the order
            // of registers as &quot;Rd, Rm, Rs, Rn&quot;. But confusingly it uses the
            // Rn field to encode the Rd register and the Rd field to encode
            // the Rn register.
            Format(instr, &quot;mla&#39;cond&#39;s &#39;rn, &#39;rm, &#39;rs, &#39;rd&quot;);
          }
        } else {
          // The signed/long multiply instructions use the terms RdHi and RdLo
          // when referring to the target registers. They are mapped to the Rn
          // and Rd fields as follows:
          // RdLo == Rd
          // RdHi == Rn (This is confusingly stored in variable rd here
          //             because the mul instruction from above uses the
          //             Rn field to encode the Rd register. Good luck figuring
          //             this out without reading the ARM instruction manual
          //             at a very detailed level.)
          // Format(instr, &quot;&#39;um&#39;al&#39;cond&#39;s &#39;rd, &#39;rn, &#39;rs, &#39;rm&quot;);
          int rd_hi = rn;  // Remap the rn field to the RdHi register.
          int rd_lo = instr-&gt;RdValue();
          int32_t hi_res = 0;
          int32_t lo_res = 0;
          if (instr-&gt;Bit(22) == 1) {
            int64_t left_op  = static_cast&lt;int32_t&gt;(rm_val);
            int64_t right_op = static_cast&lt;int32_t&gt;(rs_val);
            uint64_t result = left_op * right_op;
            hi_res = static_cast&lt;int32_t&gt;(result &gt;&gt; 32);
            lo_res = static_cast&lt;int32_t&gt;(result & 0xffffffff);
          } else {
            // unsigned multiply
            uint64_t left_op  = static_cast&lt;uint32_t&gt;(rm_val);
            uint64_t right_op = static_cast&lt;uint32_t&gt;(rs_val);
            uint64_t result = left_op * right_op;
            hi_res = static_cast&lt;int32_t&gt;(result &gt;&gt; 32);
            lo_res = static_cast&lt;int32_t&gt;(result & 0xffffffff);
          }
          set_register(rd_lo, lo_res);
          set_register(rd_hi, hi_res);
          if (instr-&gt;HasS()) {
            UNIMPLEMENTED();
          }
        }
      } else {
        UNIMPLEMENTED();  // Not used by V8.
      }
    } else {
      // extra load/store instructions
      int rd = instr-&gt;RdValue();
      int rn = instr-&gt;RnValue();
      int32_t rn_val = get_register(rn);
      int32_t addr = 0;
      if (instr-&gt;Bit(22) == 0) {
        int rm = instr-&gt;RmValue();
        int32_t rm_val = get_register(rm);
        switch (instr-&gt;PUField()) {
          case da_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn], -&#39;rm&quot;);
            ASSERT(!instr-&gt;HasW());
            addr = rn_val;
            rn_val -= rm_val;
            set_register(rn, rn_val);
            break;
          }
          case ia_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn], +&#39;rm&quot;);
            ASSERT(!instr-&gt;HasW());
            addr = rn_val;
            rn_val += rm_val;
            set_register(rn, rn_val);
            break;
          }
          case db_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn, -&#39;rm]&#39;w&quot;);
            rn_val -= rm_val;
            addr = rn_val;
            if (instr-&gt;HasW()) {
              set_register(rn, rn_val);
            }
            break;
          }
          case ib_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn, +&#39;rm]&#39;w&quot;);
            rn_val += rm_val;
            addr = rn_val;
            if (instr-&gt;HasW()) {
              set_register(rn, rn_val);
            }
            break;
          }
          default: {
            // The PU field is a 2-bit field.
            UNREACHABLE();
            break;
          }
        }
      } else {
        int32_t imm_val = (instr-&gt;ImmedHValue() &lt;&lt; 4) | instr-&gt;ImmedLValue();
        switch (instr-&gt;PUField()) {
          case da_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn], #-&#39;off8&quot;);
            ASSERT(!instr-&gt;HasW());
            addr = rn_val;
            rn_val -= imm_val;
            set_register(rn, rn_val);
            break;
          }
          case ia_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn], #+&#39;off8&quot;);
            ASSERT(!instr-&gt;HasW());
            addr = rn_val;
            rn_val += imm_val;
            set_register(rn, rn_val);
            break;
          }
          case db_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn, #-&#39;off8]&#39;w&quot;);
            rn_val -= imm_val;
            addr = rn_val;
            if (instr-&gt;HasW()) {
              set_register(rn, rn_val);
            }
            break;
          }
          case ib_x: {
            // Format(instr, &quot;&#39;memop&#39;cond&#39;sign&#39;h &#39;rd, [&#39;rn, #+&#39;off8]&#39;w&quot;);
            rn_val += imm_val;
            addr = rn_val;
            if (instr-&gt;HasW()) {
              set_register(rn, rn_val);
            }
            break;
          }
          default: {
            // The PU field is a 2-bit field.
            UNREACHABLE();
            break;
          }
        }
      }
      if (((instr-&gt;Bits(7, 4) & 0xd) == 0xd) && (instr-&gt;Bit(20) == 0)) {
        ASSERT((rd % 2) == 0);
        if (instr-&gt;HasH()) {
          // The strd instruction.
          int32_t value1 = get_register(rd);
          int32_t value2 = get_register(rd+1);
          WriteDW(addr, value1, value2);
        } else {
          // The ldrd instruction.
          int* rn_data = ReadDW(addr);
          set_dw_register(rd, rn_data);
        }
      } else if (instr-&gt;HasH()) {
        if (instr-&gt;HasSign()) {
          if (instr-&gt;HasL()) {
            int16_t val = ReadH(addr, instr);
            set_register(rd, val);
          } else {
            int16_t val = get_register(rd);
            WriteH(addr, val, instr);
          }
        } else {
          if (instr-&gt;HasL()) {
            uint16_t val = ReadHU(addr, instr);
            set_register(rd, val);
          } else {
            uint16_t val = get_register(rd);
            WriteH(addr, val, instr);
          }
        }
      } else {
        // signed byte loads
        ASSERT(instr-&gt;HasSign());
        ASSERT(instr-&gt;HasL());
        int8_t val = ReadB(addr);
        set_register(rd, val);
      }
      return;
    }
  } else if ((type == 0) && instr-&gt;IsMiscType0()) {
    if (instr-&gt;Bits(22, 21) == 1) {
      int rm = instr-&gt;RmValue();
      switch (instr-&gt;BitField(7, 4)) {
        case BX:
          set_pc(get_register(rm));
          break;
        case BLX: {
          uint32_t old_pc = get_pc();
          set_pc(get_register(rm));
          set_register(lr, old_pc + Instruction::kInstrSize);
          break;
        }
        case BKPT: {
          ArmDebugger dbg(this);
          PrintF(&quot;Simulator hit BKPT.\n&quot;);
          dbg.Debug();
          break;
        }
        default:
          UNIMPLEMENTED();
      }
    } else if (instr-&gt;Bits(22, 21) == 3) {
      int rm = instr-&gt;RmValue();
      int rd = instr-&gt;RdValue();
      switch (instr-&gt;BitField(7, 4)) {
        case CLZ: {
          uint32_t bits = get_register(rm);
          int leading_zeros = 0;
          if (bits == 0) {
            leading_zeros = 32;
          } else {
            while ((bits & 0x80000000u) == 0) {
              bits &lt;&lt;= 1;
              leading_zeros++;
            }
          }
          set_register(rd, leading_zeros);
          break;
        }
        default:
          UNIMPLEMENTED();
      }
    } else {
      PrintF(&quot;%08x\n&quot;, instr-&gt;InstructionBits());
      UNIMPLEMENTED();
    }
  } else {
    int rd = instr-&gt;RdValue();
    int rn = instr-&gt;RnValue();
    int32_t rn_val = get_register(rn);
    int32_t shifter_operand = 0;
    bool shifter_carry_out = 0;
    if (type == 0) {
      shifter_operand = GetShiftRm(instr, &shifter_carry_out);
    } else {
      ASSERT(instr-&gt;TypeValue() == 1);
      shifter_operand = GetImm(instr, &shifter_carry_out);
    }
    int32_t alu_out;

    switch (instr-&gt;OpcodeField()) {
      case AND: {
        // Format(instr, &quot;and&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;and&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = rn_val & shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        }
        break;
      }

      case EOR: {
        // Format(instr, &quot;eor&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;eor&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = rn_val ^ shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        }
        break;
      }

      case SUB: {
        // Format(instr, &quot;sub&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;sub&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = rn_val - shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(!BorrowFrom(rn_val, shifter_operand));
          SetVFlag(OverflowFrom(alu_out, rn_val, shifter_operand, false));
        }
        break;
      }

      case RSB: {
        // Format(instr, &quot;rsb&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;rsb&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = shifter_operand - rn_val;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(!BorrowFrom(shifter_operand, rn_val));
          SetVFlag(OverflowFrom(alu_out, shifter_operand, rn_val, false));
        }
        break;
      }

      case ADD: {
        // Format(instr, &quot;add&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;add&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = rn_val + shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(CarryFrom(rn_val, shifter_operand));
          SetVFlag(OverflowFrom(alu_out, rn_val, shifter_operand, true));
        }
        break;
      }

      case ADC: {
        // Format(instr, &quot;adc&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;adc&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = rn_val + shifter_operand + GetCarry();
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(CarryFrom(rn_val, shifter_operand, GetCarry()));
          SetVFlag(OverflowFrom(alu_out, rn_val, shifter_operand, true));
        }
        break;
      }

      case SBC: {
        Format(instr, &quot;sbc&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        Format(instr, &quot;sbc&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        break;
      }

      case RSC: {
        Format(instr, &quot;rsc&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        Format(instr, &quot;rsc&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        break;
      }

      case TST: {
        if (instr-&gt;HasS()) {
          // Format(instr, &quot;tst&#39;cond &#39;rn, &#39;shift_rm&quot;);
          // Format(instr, &quot;tst&#39;cond &#39;rn, &#39;imm&quot;);
          alu_out = rn_val & shifter_operand;
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        } else {
          // Format(instr, &quot;movw&#39;cond &#39;rd, &#39;imm&quot;).
          alu_out = instr-&gt;ImmedMovwMovtValue();
          set_register(rd, alu_out);
        }
        break;
      }

      case TEQ: {
        if (instr-&gt;HasS()) {
          // Format(instr, &quot;teq&#39;cond &#39;rn, &#39;shift_rm&quot;);
          // Format(instr, &quot;teq&#39;cond &#39;rn, &#39;imm&quot;);
          alu_out = rn_val ^ shifter_operand;
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        } else {
          // Other instructions matching this pattern are handled in the
          // miscellaneous instructions part above.
          UNREACHABLE();
        }
        break;
      }

      case CMP: {
        if (instr-&gt;HasS()) {
          // Format(instr, &quot;cmp&#39;cond &#39;rn, &#39;shift_rm&quot;);
          // Format(instr, &quot;cmp&#39;cond &#39;rn, &#39;imm&quot;);
          alu_out = rn_val - shifter_operand;
          SetNZFlags(alu_out);
          SetCFlag(!BorrowFrom(rn_val, shifter_operand));
          SetVFlag(OverflowFrom(alu_out, rn_val, shifter_operand, false));
        } else {
          // Format(instr, &quot;movt&#39;cond &#39;rd, &#39;imm&quot;).
          alu_out = (get_register(rd) & 0xffff) |
              (instr-&gt;ImmedMovwMovtValue() &lt;&lt; 16);
          set_register(rd, alu_out);
        }
        break;
      }

      case CMN: {
        if (instr-&gt;HasS()) {
          // Format(instr, &quot;cmn&#39;cond &#39;rn, &#39;shift_rm&quot;);
          // Format(instr, &quot;cmn&#39;cond &#39;rn, &#39;imm&quot;);
          alu_out = rn_val + shifter_operand;
          SetNZFlags(alu_out);
          SetCFlag(!CarryFrom(rn_val, shifter_operand));
          SetVFlag(OverflowFrom(alu_out, rn_val, shifter_operand, true));
        } else {
          // Other instructions matching this pattern are handled in the
          // miscellaneous instructions part above.
          UNREACHABLE();
        }
        break;
      }

      case ORR: {
        // Format(instr, &quot;orr&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;orr&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = rn_val | shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        }
        break;
      }

      case MOV: {
        // Format(instr, &quot;mov&#39;cond&#39;s &#39;rd, &#39;shift_rm&quot;);
        // Format(instr, &quot;mov&#39;cond&#39;s &#39;rd, &#39;imm&quot;);
        alu_out = shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        }
        break;
      }

      case BIC: {
        // Format(instr, &quot;bic&#39;cond&#39;s &#39;rd, &#39;rn, &#39;shift_rm&quot;);
        // Format(instr, &quot;bic&#39;cond&#39;s &#39;rd, &#39;rn, &#39;imm&quot;);
        alu_out = rn_val & ~shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        }
        break;
      }

      case MVN: {
        // Format(instr, &quot;mvn&#39;cond&#39;s &#39;rd, &#39;shift_rm&quot;);
        // Format(instr, &quot;mvn&#39;cond&#39;s &#39;rd, &#39;imm&quot;);
        alu_out = ~shifter_operand;
        set_register(rd, alu_out);
        if (instr-&gt;HasS()) {
          SetNZFlags(alu_out);
          SetCFlag(shifter_carry_out);
        }
        break;
      }

      default: {
        UNREACHABLE();
        break;
      }
    }
  }
}</span>


<span class='i'>void Simulator::DecodeType2(Instruction* instr) {
  int rd = instr-&gt;RdValue();
  int rn = instr-&gt;RnValue();
  int32_t rn_val = get_register(rn);
  int32_t im_val = instr-&gt;Offset12Value();
  int32_t addr = 0;
  switch (instr-&gt;PUField()) {
    case da_x: {
      // Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn], #-&#39;off12&quot;);
      ASSERT(!instr-&gt;HasW());
      addr = rn_val;
      rn_val -= im_val;
      set_register(rn, rn_val);
      break;
    }
    case ia_x: {
      // Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn], #+&#39;off12&quot;);
      ASSERT(!instr-&gt;HasW());
      addr = rn_val;
      rn_val += im_val;
      set_register(rn, rn_val);
      break;
    }
    case db_x: {
      // Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn, #-&#39;off12]&#39;w&quot;);
      rn_val -= im_val;
      addr = rn_val;
      if (instr-&gt;HasW()) {
        set_register(rn, rn_val);
      }
      break;
    }
    case ib_x: {
      // Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn, #+&#39;off12]&#39;w&quot;);
      rn_val += im_val;
      addr = rn_val;
      if (instr-&gt;HasW()) {
        set_register(rn, rn_val);
      }
      break;
    }
    default: {
      UNREACHABLE();
      break;
    }
  }
  if (instr-&gt;HasB()) {
    if (instr-&gt;HasL()) {
      byte val = ReadBU(addr);
      set_register(rd, val);
    } else {
      byte val = get_register(rd);
      WriteB(addr, val);
    }
  } else {
    if (instr-&gt;HasL()) {
      set_register(rd, ReadW(addr, instr));
    } else {
      WriteW(addr, get_register(rd), instr);
    }
  }
}</span>


<span class='i'>void Simulator::DecodeType3(Instruction* instr) {
  int rd = instr-&gt;RdValue();
  int rn = instr-&gt;RnValue();
  int32_t rn_val = get_register(rn);
  bool shifter_carry_out = 0;
  int32_t shifter_operand = GetShiftRm(instr, &shifter_carry_out);
  int32_t addr = 0;
  switch (instr-&gt;PUField()) {
    case da_x: {
      ASSERT(!instr-&gt;HasW());
      Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn], -&#39;shift_rm&quot;);
      UNIMPLEMENTED();
      break;
    }
    case ia_x: {
      if (instr-&gt;HasW()) {
        ASSERT(instr-&gt;Bits(5, 4) == 0x1);

        if (instr-&gt;Bit(22) == 0x1) {  // USAT.
          int32_t sat_pos = instr-&gt;Bits(20, 16);
          int32_t sat_val = (1 &lt;&lt; sat_pos) - 1;
          int32_t shift = instr-&gt;Bits(11, 7);
          int32_t shift_type = instr-&gt;Bit(6);
          int32_t rm_val = get_register(instr-&gt;RmValue());
          if (shift_type == 0) {  // LSL
            rm_val &lt;&lt;= shift;
          } else {  // ASR
            rm_val &gt;&gt;= shift;
          }
          // If saturation occurs, the Q flag should be set in the CPSR.
          // There is no Q flag yet, and no instruction (MRS) to read the
          // CPSR directly.
          if (rm_val &gt; sat_val) {
            rm_val = sat_val;
          } else if (rm_val &lt; 0) {
            rm_val = 0;
          }
          set_register(rd, rm_val);
        } else {  // SSAT.
          UNIMPLEMENTED();
        }
        return;
      } else {
        Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn], +&#39;shift_rm&quot;);
        UNIMPLEMENTED();
      }
      break;
    }
    case db_x: {
      // Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn, -&#39;shift_rm]&#39;w&quot;);
      addr = rn_val - shifter_operand;
      if (instr-&gt;HasW()) {
        set_register(rn, addr);
      }
      break;
    }
    case ib_x: {
      if (instr-&gt;HasW() && (instr-&gt;Bits(6, 4) == 0x5)) {
        uint32_t widthminus1 = static_cast&lt;uint32_t&gt;(instr-&gt;Bits(20, 16));
        uint32_t lsbit = static_cast&lt;uint32_t&gt;(instr-&gt;Bits(11, 7));
        uint32_t msbit = widthminus1 + lsbit;
        if (msbit &lt;= 31) {
          if (instr-&gt;Bit(22)) {
            // ubfx - unsigned bitfield extract.
            uint32_t rm_val =
                static_cast&lt;uint32_t&gt;(get_register(instr-&gt;RmValue()));
            uint32_t extr_val = rm_val &lt;&lt; (31 - msbit);
            extr_val = extr_val &gt;&gt; (31 - widthminus1);
            set_register(instr-&gt;RdValue(), extr_val);
          } else {
            // sbfx - signed bitfield extract.
            int32_t rm_val = get_register(instr-&gt;RmValue());
            int32_t extr_val = rm_val &lt;&lt; (31 - msbit);
            extr_val = extr_val &gt;&gt; (31 - widthminus1);
            set_register(instr-&gt;RdValue(), extr_val);
          }
        } else {
          UNREACHABLE();
        }
        return;
      } else if (!instr-&gt;HasW() && (instr-&gt;Bits(6, 4) == 0x1)) {
        uint32_t lsbit = static_cast&lt;uint32_t&gt;(instr-&gt;Bits(11, 7));
        uint32_t msbit = static_cast&lt;uint32_t&gt;(instr-&gt;Bits(20, 16));
        if (msbit &gt;= lsbit) {
          // bfc or bfi - bitfield clear/insert.
          uint32_t rd_val =
              static_cast&lt;uint32_t&gt;(get_register(instr-&gt;RdValue()));
          uint32_t bitcount = msbit - lsbit + 1;
          uint32_t mask = (1 &lt;&lt; bitcount) - 1;
          rd_val &= ~(mask &lt;&lt; lsbit);
          if (instr-&gt;RmValue() != 15) {
            // bfi - bitfield insert.
            uint32_t rm_val =
                static_cast&lt;uint32_t&gt;(get_register(instr-&gt;RmValue()));
            rm_val &= mask;
            rd_val |= rm_val &lt;&lt; lsbit;
          }
          set_register(instr-&gt;RdValue(), rd_val);
        } else {
          UNREACHABLE();
        }
        return;
      } else {
        // Format(instr, &quot;&#39;memop&#39;cond&#39;b &#39;rd, [&#39;rn, +&#39;shift_rm]&#39;w&quot;);
        addr = rn_val + shifter_operand;
        if (instr-&gt;HasW()) {
          set_register(rn, addr);
        }
      }
      break;
    }
    default: {
      UNREACHABLE();
      break;
    }
  }
  if (instr-&gt;HasB()) {
    if (instr-&gt;HasL()) {
      uint8_t byte = ReadB(addr);
      set_register(rd, byte);
    } else {
      uint8_t byte = get_register(rd);
      WriteB(addr, byte);
    }
  } else {
    if (instr-&gt;HasL()) {
      set_register(rd, ReadW(addr, instr));
    } else {
      WriteW(addr, get_register(rd), instr);
    }
  }
}</span>


<span class='i'>void Simulator::DecodeType4(Instruction* instr) {
  ASSERT(instr-&gt;Bit(22) == 0);  // only allowed to be set in privileged mode
  if (instr-&gt;HasL()) {
    // Format(instr, &quot;ldm&#39;cond&#39;pu &#39;rn&#39;w, &#39;rlist&quot;);
    HandleRList(instr, true);
  } else {
    // Format(instr, &quot;stm&#39;cond&#39;pu &#39;rn&#39;w, &#39;rlist&quot;);
    HandleRList(instr, false);
  }
}</span>


<span class='i'>void Simulator::DecodeType5(Instruction* instr) {
  // Format(instr, &quot;b&#39;l&#39;cond &#39;target&quot;);
  int off = (instr-&gt;SImmed24Value() &lt;&lt; 2);
  intptr_t pc_address = get_pc();
  if (instr-&gt;HasLink()) {
    set_register(lr, pc_address + Instruction::kInstrSize);
  }
  int pc_reg = get_register(pc);
  set_pc(pc_reg + off);
}</span>


<span class='i'>void Simulator::DecodeType6(Instruction* instr) {
  DecodeType6CoprocessorIns(instr);
}</span>


<span class='i'>void Simulator::DecodeType7(Instruction* instr) {
  if (instr-&gt;Bit(24) == 1) {
    SoftwareInterrupt(instr);
  } else {
    DecodeTypeVFP(instr);
  }
}</span>


// void Simulator::DecodeTypeVFP(Instruction* instr)
// The Following ARMv7 VFPv instructions are currently supported.
// vmov :Sn = Rt
// vmov :Rt = Sn
// vcvt: Dd = Sm
// vcvt: Sd = Dm
// Dd = vabs(Dm)
// Dd = vneg(Dm)
// Dd = vadd(Dn, Dm)
// Dd = vsub(Dn, Dm)
// Dd = vmul(Dn, Dm)
// Dd = vdiv(Dn, Dm)
// vcmp(Dd, Dm)
// vmrs
// Dd = vsqrt(Dm)
<span class='i'>void Simulator::DecodeTypeVFP(Instruction* instr) {
  ASSERT((instr-&gt;TypeValue() == 7) && (instr-&gt;Bit(24) == 0x0) );
  ASSERT(instr-&gt;Bits(11, 9) == 0x5);

  // Obtain double precision register codes.
  int vm = instr-&gt;VFPMRegValue(kDoublePrecision);
  int vd = instr-&gt;VFPDRegValue(kDoublePrecision);
  int vn = instr-&gt;VFPNRegValue(kDoublePrecision);

  if (instr-&gt;Bit(4) == 0) {
    if (instr-&gt;Opc1Value() == 0x7) {
      // Other data processing instructions
      if ((instr-&gt;Opc2Value() == 0x0) && (instr-&gt;Opc3Value() == 0x1)) {
        // vmov register to register.
        if (instr-&gt;SzValue() == 0x1) {
          int m = instr-&gt;VFPMRegValue(kDoublePrecision);
          int d = instr-&gt;VFPDRegValue(kDoublePrecision);
          set_d_register_from_double(d, get_double_from_d_register(m));
        } else {
          int m = instr-&gt;VFPMRegValue(kSinglePrecision);
          int d = instr-&gt;VFPDRegValue(kSinglePrecision);
          set_s_register_from_float(d, get_float_from_s_register(m));
        }
      } else if ((instr-&gt;Opc2Value() == 0x0) && (instr-&gt;Opc3Value() == 0x3)) {
        // vabs
        double dm_value = get_double_from_d_register(vm);
        double dd_value = fabs(dm_value);
        set_d_register_from_double(vd, dd_value);
      } else if ((instr-&gt;Opc2Value() == 0x1) && (instr-&gt;Opc3Value() == 0x1)) {
        // vneg
        double dm_value = get_double_from_d_register(vm);
        double dd_value = -dm_value;
        set_d_register_from_double(vd, dd_value);
      } else if ((instr-&gt;Opc2Value() == 0x7) && (instr-&gt;Opc3Value() == 0x3)) {
        DecodeVCVTBetweenDoubleAndSingle(instr);
      } else if ((instr-&gt;Opc2Value() == 0x8) && (instr-&gt;Opc3Value() & 0x1)) {
        DecodeVCVTBetweenFloatingPointAndInteger(instr);
      } else if (((instr-&gt;Opc2Value() &gt;&gt; 1) == 0x6) &&
                 (instr-&gt;Opc3Value() & 0x1)) {
        DecodeVCVTBetweenFloatingPointAndInteger(instr);
      } else if (((instr-&gt;Opc2Value() == 0x4) || (instr-&gt;Opc2Value() == 0x5)) &&
                 (instr-&gt;Opc3Value() & 0x1)) {
        DecodeVCMP(instr);
      } else if (((instr-&gt;Opc2Value() == 0x1)) && (instr-&gt;Opc3Value() == 0x3)) {
        // vsqrt
        double dm_value = get_double_from_d_register(vm);
        double dd_value = sqrt(dm_value);
        set_d_register_from_double(vd, dd_value);
      } else if (instr-&gt;Opc3Value() == 0x0) {
        // vmov immediate.
        if (instr-&gt;SzValue() == 0x1) {
          set_d_register_from_double(vd, instr-&gt;DoubleImmedVmov());
        } else {
          UNREACHABLE();  // Not used by v8.
        }
      } else {
        UNREACHABLE();  // Not used by V8.
      }
    } else if (instr-&gt;Opc1Value() == 0x3) {
      if (instr-&gt;SzValue() != 0x1) {
        UNREACHABLE();  // Not used by V8.
      }

      if (instr-&gt;Opc3Value() & 0x1) {
        // vsub
        double dn_value = get_double_from_d_register(vn);
        double dm_value = get_double_from_d_register(vm);
        double dd_value = dn_value - dm_value;
        set_d_register_from_double(vd, dd_value);
      } else {
        // vadd
        double dn_value = get_double_from_d_register(vn);
        double dm_value = get_double_from_d_register(vm);
        double dd_value = dn_value + dm_value;
        set_d_register_from_double(vd, dd_value);
      }
    } else if ((instr-&gt;Opc1Value() == 0x2) && !(instr-&gt;Opc3Value() & 0x1)) {
      // vmul
      if (instr-&gt;SzValue() != 0x1) {
        UNREACHABLE();  // Not used by V8.
      }

      double dn_value = get_double_from_d_register(vn);
      double dm_value = get_double_from_d_register(vm);
      double dd_value = dn_value * dm_value;
      set_d_register_from_double(vd, dd_value);
    } else if ((instr-&gt;Opc1Value() == 0x4) && !(instr-&gt;Opc3Value() & 0x1)) {
      // vdiv
      if (instr-&gt;SzValue() != 0x1) {
        UNREACHABLE();  // Not used by V8.
      }

      double dn_value = get_double_from_d_register(vn);
      double dm_value = get_double_from_d_register(vm);
      double dd_value = dn_value / dm_value;
      div_zero_vfp_flag_ = (dm_value == 0);
      set_d_register_from_double(vd, dd_value);
    } else {
      UNIMPLEMENTED();  // Not used by V8.
    }
  } else {
    if ((instr-&gt;VCValue() == 0x0) &&
        (instr-&gt;VAValue() == 0x0)) {
      DecodeVMOVBetweenCoreAndSinglePrecisionRegisters(instr);
    } else if ((instr-&gt;VLValue() == 0x1) &&
               (instr-&gt;VCValue() == 0x0) &&
               (instr-&gt;VAValue() == 0x7) &&
               (instr-&gt;Bits(19, 16) == 0x1)) {
      // vmrs
      uint32_t rt = instr-&gt;RtValue();
      if (rt == 0xF) {
        Copy_FPSCR_to_APSR();
      } else {
        // Emulate FPSCR from the Simulator flags.
        uint32_t fpscr = (n_flag_FPSCR_ &lt;&lt; 31) |
                         (z_flag_FPSCR_ &lt;&lt; 30) |
                         (c_flag_FPSCR_ &lt;&lt; 29) |
                         (v_flag_FPSCR_ &lt;&lt; 28) |
                         (inexact_vfp_flag_ &lt;&lt; 4) |
                         (underflow_vfp_flag_ &lt;&lt; 3) |
                         (overflow_vfp_flag_ &lt;&lt; 2) |
                         (div_zero_vfp_flag_ &lt;&lt; 1) |
                         (inv_op_vfp_flag_ &lt;&lt; 0) |
                         (FPSCR_rounding_mode_);
        set_register(rt, fpscr);
      }
    } else if ((instr-&gt;VLValue() == 0x0) &&
               (instr-&gt;VCValue() == 0x0) &&
               (instr-&gt;VAValue() == 0x7) &&
               (instr-&gt;Bits(19, 16) == 0x1)) {
      // vmsr
      uint32_t rt = instr-&gt;RtValue();
      if (rt == pc) {
        UNREACHABLE();
      } else {
        uint32_t rt_value = get_register(rt);
        n_flag_FPSCR_ = (rt_value &gt;&gt; 31) & 1;
        z_flag_FPSCR_ = (rt_value &gt;&gt; 30) & 1;
        c_flag_FPSCR_ = (rt_value &gt;&gt; 29) & 1;
        v_flag_FPSCR_ = (rt_value &gt;&gt; 28) & 1;
        inexact_vfp_flag_ = (rt_value &gt;&gt; 4) & 1;
        underflow_vfp_flag_ = (rt_value &gt;&gt; 3) & 1;
        overflow_vfp_flag_ = (rt_value &gt;&gt; 2) & 1;
        div_zero_vfp_flag_ = (rt_value &gt;&gt; 1) & 1;
        inv_op_vfp_flag_ = (rt_value &gt;&gt; 0) & 1;
        FPSCR_rounding_mode_ =
            static_cast&lt;VFPRoundingMode&gt;((rt_value) & kVFPRoundingModeMask);
      }
    } else {
      UNIMPLEMENTED();  // Not used by V8.
    }
  }
}</span>


<span class='i'>void Simulator::DecodeVMOVBetweenCoreAndSinglePrecisionRegisters(
    Instruction* instr) {
  ASSERT((instr-&gt;Bit(4) == 1) && (instr-&gt;VCValue() == 0x0) &&
         (instr-&gt;VAValue() == 0x0));

  int t = instr-&gt;RtValue();
  int n = instr-&gt;VFPNRegValue(kSinglePrecision);
  bool to_arm_register = (instr-&gt;VLValue() == 0x1);

  if (to_arm_register) {
    int32_t int_value = get_sinteger_from_s_register(n);
    set_register(t, int_value);
  } else {
    int32_t rs_val = get_register(t);
    set_s_register_from_sinteger(n, rs_val);
  }
}</span>


<span class='i'>void Simulator::DecodeVCMP(Instruction* instr) {
  ASSERT((instr-&gt;Bit(4) == 0) && (instr-&gt;Opc1Value() == 0x7));
  ASSERT(((instr-&gt;Opc2Value() == 0x4) || (instr-&gt;Opc2Value() == 0x5)) &&
         (instr-&gt;Opc3Value() & 0x1));
  // Comparison.

  VFPRegPrecision precision = kSinglePrecision;
  if (instr-&gt;SzValue() == 1) {
    precision = kDoublePrecision;
  }

  int d = instr-&gt;VFPDRegValue(precision);
  int m = 0;
  if (instr-&gt;Opc2Value() == 0x4) {
    m = instr-&gt;VFPMRegValue(precision);
  }

  if (precision == kDoublePrecision) {
    double dd_value = get_double_from_d_register(d);
    double dm_value = 0.0;
    if (instr-&gt;Opc2Value() == 0x4) {
      dm_value = get_double_from_d_register(m);
    }

    // Raise exceptions for quiet NaNs if necessary.
    if (instr-&gt;Bit(7) == 1) {
      if (isnan(dd_value)) {
        inv_op_vfp_flag_ = true;
      }
    }

    Compute_FPSCR_Flags(dd_value, dm_value);
  } else {
    UNIMPLEMENTED();  // Not used by V8.
  }
}</span>


<span class='i'>void Simulator::DecodeVCVTBetweenDoubleAndSingle(Instruction* instr) {
  ASSERT((instr-&gt;Bit(4) == 0) && (instr-&gt;Opc1Value() == 0x7));
  ASSERT((instr-&gt;Opc2Value() == 0x7) && (instr-&gt;Opc3Value() == 0x3));

  VFPRegPrecision dst_precision = kDoublePrecision;
  VFPRegPrecision src_precision = kSinglePrecision;
  if (instr-&gt;SzValue() == 1) {
    dst_precision = kSinglePrecision;
    src_precision = kDoublePrecision;
  }

  int dst = instr-&gt;VFPDRegValue(dst_precision);
  int src = instr-&gt;VFPMRegValue(src_precision);

  if (dst_precision == kSinglePrecision) {
    double val = get_double_from_d_register(src);
    set_s_register_from_float(dst, static_cast&lt;float&gt;(val));
  } else {
    float val = get_float_from_s_register(src);
    set_d_register_from_double(dst, static_cast&lt;double&gt;(val));
  }
}</span>

<span class='i'>bool get_inv_op_vfp_flag(VFPRoundingMode mode,
                         double val,
                         bool unsigned_) {
  ASSERT((mode == RN) || (mode == RM) || (mode == RZ));
  double max_uint = static_cast&lt;double&gt;(0xffffffffu);
  double max_int = static_cast&lt;double&gt;(kMaxInt);
  double min_int = static_cast&lt;double&gt;(kMinInt);

  // Check for NaN.
  if (val != val) {
    return true;
  }

  // Check for overflow. This code works because 32bit integers can be
  // exactly represented by ieee-754 64bit floating-point values.
  switch (mode) {
    case RN:
      return  unsigned_ ? (val &gt;= (max_uint + 0.5)) ||
                          (val &lt; -0.5)
                        : (val &gt;= (max_int + 0.5)) ||
                          (val &lt; (min_int - 0.5));

    case RM:
      return  unsigned_ ? (val &gt;= (max_uint + 1.0)) ||
                          (val &lt; 0)
                        : (val &gt;= (max_int + 1.0)) ||
                          (val &lt; min_int);

    case RZ:
      return  unsigned_ ? (val &gt;= (max_uint + 1.0)) ||
                          (val &lt;= -1)
                        : (val &gt;= (max_int + 1.0)) ||
                          (val &lt;= (min_int - 1.0));
    default:
      UNREACHABLE();
      return true;
  }
}</span>


// We call this function only if we had a vfp invalid exception.
// It returns the correct saturated value.
<span class='i'>int VFPConversionSaturate(double val, bool unsigned_res) {
  if (val != val) {
    return 0;
  } else {
    if (unsigned_res) {
      return (val &lt; 0) ? 0 : 0xffffffffu;
    } else {
      return (val &lt; 0) ? kMinInt : kMaxInt;
    }
  }
}</span>


<span class='i'>void Simulator::DecodeVCVTBetweenFloatingPointAndInteger(Instruction* instr) {
  ASSERT((instr-&gt;Bit(4) == 0) && (instr-&gt;Opc1Value() == 0x7) &&
         (instr-&gt;Bits(27, 23) == 0x1D));
  ASSERT(((instr-&gt;Opc2Value() == 0x8) && (instr-&gt;Opc3Value() & 0x1)) ||
         (((instr-&gt;Opc2Value() &gt;&gt; 1) == 0x6) && (instr-&gt;Opc3Value() & 0x1)));

  // Conversion between floating-point and integer.
  bool to_integer = (instr-&gt;Bit(18) == 1);

  VFPRegPrecision src_precision = (instr-&gt;SzValue() == 1) ? kDoublePrecision
                                                          : kSinglePrecision;

  if (to_integer) {
    // We are playing with code close to the C++ standard&#39;s limits below,
    // hence the very simple code and heavy checks.
    //
    // Note:
    // C++ defines default type casting from floating point to integer as
    // (close to) rounding toward zero (&quot;fractional part discarded&quot;).

    int dst = instr-&gt;VFPDRegValue(kSinglePrecision);
    int src = instr-&gt;VFPMRegValue(src_precision);

    // Bit 7 in vcvt instructions indicates if we should use the FPSCR rounding
    // mode or the default Round to Zero mode.
    VFPRoundingMode mode = (instr-&gt;Bit(7) != 1) ? FPSCR_rounding_mode_
                                                : RZ;
    ASSERT((mode == RM) || (mode == RZ) || (mode == RN));

    bool unsigned_integer = (instr-&gt;Bit(16) == 0);
    bool double_precision = (src_precision == kDoublePrecision);

    double val = double_precision ? get_double_from_d_register(src)
                                  : get_float_from_s_register(src);

    int temp = unsigned_integer ? static_cast&lt;uint32_t&gt;(val)
                                : static_cast&lt;int32_t&gt;(val);

    inv_op_vfp_flag_ = get_inv_op_vfp_flag(mode, val, unsigned_integer);

    double abs_diff =
      unsigned_integer ? fabs(val - static_cast&lt;uint32_t&gt;(temp))
                       : fabs(val - temp);

    inexact_vfp_flag_ = (abs_diff != 0);

    if (inv_op_vfp_flag_) {
      temp = VFPConversionSaturate(val, unsigned_integer);
    } else {
      switch (mode) {
        case RN: {
          int val_sign = (val &gt; 0) ? 1 : -1;
          if (abs_diff &gt; 0.5) {
            temp += val_sign;
          } else if (abs_diff == 0.5) {
            // Round to even if exactly halfway.
            temp = ((temp % 2) == 0) ? temp : temp + val_sign;
          }
          break;
        }

        case RM:
          temp = temp &gt; val ? temp - 1 : temp;
          break;

        case RZ:
          // Nothing to do.
          break;

        default:
          UNREACHABLE();
      }
    }

    // Update the destination register.
    set_s_register_from_sinteger(dst, temp);

  } else {
    bool unsigned_integer = (instr-&gt;Bit(7) == 0);

    int dst = instr-&gt;VFPDRegValue(src_precision);
    int src = instr-&gt;VFPMRegValue(kSinglePrecision);

    int val = get_sinteger_from_s_register(src);

    if (src_precision == kDoublePrecision) {
      if (unsigned_integer) {
        set_d_register_from_double(dst,
                                   static_cast&lt;double&gt;((uint32_t)val));
      } else {
        set_d_register_from_double(dst, static_cast&lt;double&gt;(val));
      }
    } else {
      if (unsigned_integer) {
        set_s_register_from_float(dst,
                                  static_cast&lt;float&gt;((uint32_t)val));
      } else {
        set_s_register_from_float(dst, static_cast&lt;float&gt;(val));
      }
    }
  }
}</span>


// void Simulator::DecodeType6CoprocessorIns(Instruction* instr)
// Decode Type 6 coprocessor instructions.
// Dm = vmov(Rt, Rt2)
// &lt;Rt, Rt2&gt; = vmov(Dm)
// Ddst = MEM(Rbase + 4*offset).
// MEM(Rbase + 4*offset) = Dsrc.
<span class='i'>void Simulator::DecodeType6CoprocessorIns(Instruction* instr) {
  ASSERT((instr-&gt;TypeValue() == 6));

  if (instr-&gt;CoprocessorValue() == 0xA) {
    switch (instr-&gt;OpcodeValue()) {
      case 0x8:
      case 0xA:
      case 0xC:
      case 0xE: {  // Load and store single precision float to memory.
        int rn = instr-&gt;RnValue();
        int vd = instr-&gt;VFPDRegValue(kSinglePrecision);
        int offset = instr-&gt;Immed8Value();
        if (!instr-&gt;HasU()) {
          offset = -offset;
        }

        int32_t address = get_register(rn) + 4 * offset;
        if (instr-&gt;HasL()) {
          // Load double from memory: vldr.
          set_s_register_from_sinteger(vd, ReadW(address, instr));
        } else {
          // Store double to memory: vstr.
          WriteW(address, get_sinteger_from_s_register(vd), instr);
        }
        break;
      }
      case 0x4:
      case 0x5:
      case 0x6:
      case 0x7:
      case 0x9:
      case 0xB:
        // Load/store multiple single from memory: vldm/vstm.
        HandleVList(instr);
        break;
      default:
        UNIMPLEMENTED();  // Not used by V8.
    }
  } else if (instr-&gt;CoprocessorValue() == 0xB) {
    switch (instr-&gt;OpcodeValue()) {
      case 0x2:
        // Load and store double to two GP registers
        if (instr-&gt;Bits(7, 4) != 0x1) {
          UNIMPLEMENTED();  // Not used by V8.
        } else {
          int rt = instr-&gt;RtValue();
          int rn = instr-&gt;RnValue();
          int vm = instr-&gt;VmValue();
          if (instr-&gt;HasL()) {
            int32_t rt_int_value = get_sinteger_from_s_register(2*vm);
            int32_t rn_int_value = get_sinteger_from_s_register(2*vm+1);

            set_register(rt, rt_int_value);
            set_register(rn, rn_int_value);
          } else {
            int32_t rs_val = get_register(rt);
            int32_t rn_val = get_register(rn);

            set_s_register_from_sinteger(2*vm, rs_val);
            set_s_register_from_sinteger((2*vm+1), rn_val);
          }
        }
        break;
      case 0x8:
      case 0xC: {  // Load and store double to memory.
        int rn = instr-&gt;RnValue();
        int vd = instr-&gt;VdValue();
        int offset = instr-&gt;Immed8Value();
        if (!instr-&gt;HasU()) {
          offset = -offset;
        }
        int32_t address = get_register(rn) + 4 * offset;
        if (instr-&gt;HasL()) {
          // Load double from memory: vldr.
          set_s_register_from_sinteger(2*vd, ReadW(address, instr));
          set_s_register_from_sinteger(2*vd + 1, ReadW(address + 4, instr));
        } else {
          // Store double to memory: vstr.
          WriteW(address, get_sinteger_from_s_register(2*vd), instr);
          WriteW(address + 4, get_sinteger_from_s_register(2*vd + 1), instr);
        }
        break;
      }
      case 0x4:
      case 0x5:
      case 0x9:
        // Load/store multiple double from memory: vldm/vstm.
        HandleVList(instr);
        break;
      default:
        UNIMPLEMENTED();  // Not used by V8.
    }
  } else {
    UNIMPLEMENTED();  // Not used by V8.
  }
}</span>


// Executes the current instruction.
<span class='i'>void</span> <a id='348' tid='347' class='m'>Simulator</a><a id='350' tid='349' class='m'>::</a><a id='352' tid='351' class='m'>InstructionDecode</a><span class='i'>(Instruction* instr)</span> {
  <a id='222' tid='221' class='m'>if</a> (<a id='224' tid='223' class='m'>v8</a><a id='226' tid='225' class='m'>::</a><a id='228' tid='227' class='m'>internal</a><a id='230' tid='229' class='m'>::</a><a id='232' tid='231' class='m'>FLAG_check_icache</a>) {
    <a id='234' tid='233' class='m'>CheckICache</a>(<a id='236' tid='235' class='m'>isolate_</a>-&gt;<a id='238' tid='237' class='m'>simulator_i_cache</a>(), <a id='240' tid='239' class='m'>instr</a>);
  }
  <a id='202' tid='201' class='m'>pc_modified_</a> <a id='204' tid='203' class='m'>=</a> <a id='206' tid='205' class='m'>false</a>;
  <a id='242' tid='241' class='m'>if</a> (<a id='654' tid='653' class='m'>::</a><a id='656' tid='655' class='m'>v8</a><a id='658' tid='657' class='m'>::</a><a id='660' tid='659' class='m'>internal</a><a id='662' tid='661' class='m'>::</a><a id='664' tid='663' class='m'>FLAG_trace_sim</a>) {
    <a id='254' tid='253' class='m'>disasm</a><a id='256' tid='255' class='m'>::</a><a id='258' tid='257' class='m'>NameConverter</a> <a id='260' tid='259' class='m'>converter</a>;
    <a id='244' tid='243' class='m'>disasm</a><a id='246' tid='245' class='m'>::</a><a id='248' tid='247' class='m'>Disassembler</a> <a id='250' tid='249' class='m'>dasm</a>(<a id='252' tid='251' class='m'>converter</a>);
    // use a reasonably large buffer
    <a id='262' tid='261' class='m'>v8</a><a id='264' tid='263' class='m'>::</a><a id='266' tid='265' class='m'>internal</a><a id='268' tid='267' class='m'>::</a><a id='270' tid='269' class='m'>EmbeddedVector</a>&lt;<a id='272' tid='271' class='m'>char</a>, <a id='274' tid='273' class='m'>256</a>&gt; <a id='276' tid='275' class='m'>buffer</a>;
    <a id='278' tid='277' class='m'>dasm</a>.<a id='280' tid='279' class='m'>InstructionDecode</a>(<a id='282' tid='281' class='m'>buffer</a>,
                           <a id='284' tid='283' class='m'>reinterpret_cast</a>&lt;<a id='286' tid='285' class='m'>byte</a><a id='288' tid='287' class='m'>*</a>&gt;(<a id='290' tid='289' class='m'>instr</a>));
    <a id='292' tid='291' class='m'>PrintF</a>(<a id='294' tid='293' class='m'>&quot;  0x%08x  %s\n&quot;</a>, <a id='296' tid='295' class='m'>reinterpret_cast</a>&lt;<a id='298' tid='297' class='m'>intptr_t</a>&gt;(<a id='300' tid='299' class='m'>instr</a>), <a id='302' tid='301' class='m'>buffer</a>.<a id='304' tid='303' class='m'>start</a>());
  }
  <span class='i'>if</span> <span class='i'>(instr-&gt;ConditionField() == kSpecialCondition)</span> <span class='i'>{
    UNIMPLEMENTED();
  }</span> <span class='i'>else</span> <span class='i'>if</span> <span class='i'>(ConditionallyExecute(instr))</span> <span class='i'>{
    switch (instr-&gt;TypeValue()) {
      case 0:
      case 1: {
        DecodeType01(instr);
        break;
      }
      case 2: {
        DecodeType2(instr);
        break;
      }
      case 3: {
        DecodeType3(instr);
        break;
      }
      case 4: {
        DecodeType4(instr);
        break;
      }
      case 5: {
        DecodeType5(instr);
        break;
      }
      case 6: {
        DecodeType6(instr);
        break;
      }
      case 7: {
        DecodeType7(instr);
        break;
      }
      default: {
        UNIMPLEMENTED();
        break;
      }
    }
  // If the instruction is a non taken conditional stop, we need to skip the
  // inlined message address.
  }</span> <a id='936' tid='935' class='m'>else</a> <span class='i'>if</span> <span class='i'>(instr-&gt;IsStop())</span> {
    <a id='938' tid='937' class='m'>set_pc</a>(<a id='940' tid='939' class='m'>get_pc</a>() <a id='942' tid='941' class='m'>+</a> <a id='944' tid='943' class='m'>2</a> <a id='946' tid='945' class='m'>*</a> <a id='948' tid='947' class='m'>Instruction</a><a id='950' tid='949' class='m'>::</a><a id='952' tid='951' class='m'>kInstrSize</a>);
  }
  <a id='152' tid='151' class='m'>if</a> (<a id='154' tid='153' class='m'>!</a><a id='156' tid='155' class='m'>pc_modified_</a>) {
    <a id='158' tid='157' class='m'>set_register</a>(<a id='160' tid='159' class='m'>pc</a>, <a id='162' tid='161' class='m'>reinterpret_cast</a>&lt;<a id='164' tid='163' class='m'>int32_t</a>&gt;(<a id='166' tid='165' class='m'>instr</a>)
                         <a id='168' tid='167' class='m'>+</a> <a id='170' tid='169' class='m'>Instruction</a><a id='172' tid='171' class='m'>::</a><a id='174' tid='173' class='m'>kInstrSize</a>);
  }
}


<a id='666' tid='665' class='m'>void</a> <a id='668' tid='667' class='m'>Simulator</a><a id='670' tid='669' class='m'>::</a><a id='672' tid='671' class='m'>Execute</a>() {
  // Get the PC to simulate. Cannot use the accessor here as we need the
  // raw PC value and not the one used as input to arithmetic instructions.
  <a id='674' tid='673' class='m'>int</a> <a id='676' tid='675' class='m'>program_counter</a> = <a id='678' tid='677' class='m'>get_pc</a>();

  <a id='680' tid='679' class='m'>if</a> (<a id='682' tid='681' class='m'>::</a><a id='684' tid='683' class='m'>v8</a><a id='686' tid='685' class='m'>::</a><a id='688' tid='687' class='m'>internal</a><a id='690' tid='689' class='m'>::</a><a id='692' tid='691' class='m'>FLAG_stop_sim_at</a> <a id='694' tid='693' class='m'>==</a> <a id='696' tid='695' class='m'>0</a>) {
    // Fast version of the dispatch loop without checking whether the simulator
    // should be stopping at a particular executed instruction.
    <a id='698' tid='697' class='m'>while</a> (<a id='700' tid='699' class='m'>program_counter</a> <a id='702' tid='701' class='m'>!=</a> <a id='704' tid='703' class='m'>end_sim_pc</a>) {
      <a id='706' tid='705' class='m'>Instruction</a><a id='708' tid='707' class='m'>*</a> <a id='710' tid='709' class='m'>instr</a> = <a id='712' tid='711' class='m'>reinterpret_cast</a>&lt;<a id='714' tid='713' class='m'>Instruction</a><a id='716' tid='715' class='m'>*</a>&gt;(<a id='718' tid='717' class='m'>program_counter</a>);
      <a id='720' tid='719' class='m'>icount_</a><a id='722' tid='721' class='m'>++</a>;
      <a id='724' tid='723' class='m'>InstructionDecode</a>(<a id='726' tid='725' class='m'>instr</a>);
      <a id='728' tid='727' class='m'>program_counter</a> <a id='730' tid='729' class='m'>=</a> <a id='732' tid='731' class='m'>get_pc</a>();
    }
  } <a id='734' tid='733' class='m'>else</a> {
    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
    // we reach the particular instuction count.
    <a id='736' tid='735' class='m'>while</a> (<a id='738' tid='737' class='m'>program_counter</a> <a id='740' tid='739' class='m'>!=</a> <a id='742' tid='741' class='m'>end_sim_pc</a>) {
      <a id='744' tid='743' class='m'>Instruction</a><a id='746' tid='745' class='m'>*</a> <a id='748' tid='747' class='m'>instr</a> = <a id='750' tid='749' class='m'>reinterpret_cast</a>&lt;<a id='752' tid='751' class='m'>Instruction</a><a id='754' tid='753' class='m'>*</a>&gt;(<a id='756' tid='755' class='m'>program_counter</a>);
      <a id='758' tid='757' class='m'>icount_</a><a id='760' tid='759' class='m'>++</a>;
      <a id='762' tid='761' class='m'>if</a> (<a id='764' tid='763' class='m'>icount_</a> <a id='766' tid='765' class='m'>==</a> <a id='768' tid='767' class='m'>::</a><a id='770' tid='769' class='m'>v8</a><a id='772' tid='771' class='m'>::</a><a id='774' tid='773' class='m'>internal</a><a id='776' tid='775' class='m'>::</a><a id='778' tid='777' class='m'>FLAG_stop_sim_at</a>) {
        <span class='i'>ArmDebugger dbg(this)</span>;
        <a id='780' tid='779' class='m'>dbg</a>.<a id='782' tid='781' class='m'>Debug</a>();
      } <a id='784' tid='783' class='m'>else</a> {
        <a id='786' tid='785' class='m'>InstructionDecode</a>(<a id='788' tid='787' class='m'>instr</a>);
      }
      <a id='790' tid='789' class='m'>program_counter</a> <a id='792' tid='791' class='m'>=</a> <a id='794' tid='793' class='m'>get_pc</a>();
    }
  }
}


<a id='578' tid='577' class='m'>int32_t</a> <a id='580' tid='579' class='m'>Simulator</a><a id='582' tid='581' class='m'>::</a><a id='584' tid='583' class='m'>Call</a>(<a id='586' tid='585' class='m'>byte</a><a id='588' tid='587' class='m'>*</a> <a id='590' tid='589' class='m'>entry</a>, <a id='592' tid='591' class='m'>int</a> <a id='594' tid='593' class='m'>argument_count</a>, <a id='596' tid='595' class='m'>...</a>) {
  <a id='598' tid='597' class='m'>va_list</a> <a id='600' tid='599' class='m'>parameters</a>;
  <a id='572' tid='571' class='m'>va_start</a>(<a id='574' tid='573' class='m'>parameters</a>, <a id='576' tid='575' class='m'>argument_count</a>);
  // Setup arguments

  // First four arguments passed in registers.
  <a id='466' tid='465' class='m'>ASSERT</a>(<a id='468' tid='467' class='m'>argument_count</a> <a id='470' tid='469' class='m'>&gt;=</a> <a id='472' tid='471' class='m'>4</a>);
  <a id='364' tid='363' class='m'>set_register</a>(<span class='i'>r0</span>, <a id='366' tid='365' class='m'>va_arg</a>(<a id='368' tid='367' class='m'>parameters</a>, <a id='370' tid='369' class='m'>int32_t</a>));
  <a id='340' tid='339' class='m'>set_register</a>(<span class='i'>r1</span>, <a id='342' tid='341' class='m'>va_arg</a>(<a id='344' tid='343' class='m'>parameters</a>, <a id='346' tid='345' class='m'>int32_t</a>));
  <a id='306' tid='305' class='m'>set_register</a>(<span class='i'>r2</span>, <a id='308' tid='307' class='m'>va_arg</a>(<a id='310' tid='309' class='m'>parameters</a>, <a id='312' tid='311' class='m'>int32_t</a>));
  <a id='208' tid='207' class='m'>set_register</a>(<span class='i'>r3</span>, <a id='210' tid='209' class='m'>va_arg</a>(<a id='212' tid='211' class='m'>parameters</a>, <a id='214' tid='213' class='m'>int32_t</a>));

  // Remaining arguments passed on stack.
  <a id='176' tid='175' class='m'>int</a> <a id='178' tid='177' class='m'>original_stack</a> = <a id='180' tid='179' class='m'>get_register</a>(<a id='182' tid='181' class='m'>sp</a>);
  // Compute position of stack on entry to generated code.
  <a id='132' tid='131' class='m'>int</a> <a id='134' tid='133' class='m'>entry_stack</a> = (<a id='136' tid='135' class='m'>original_stack</a> <a id='138' tid='137' class='m'>-</a> (<a id='140' tid='139' class='m'>argument_count</a> <a id='142' tid='141' class='m'>-</a> <a id='144' tid='143' class='m'>4</a>) <span class='i'>*</span> <span class='i'>sizeof(int32_t)</span>);
  <a id='94' tid='93' class='m'>if</a> (<a id='96' tid='95' class='m'>OS</a><a id='98' tid='97' class='m'>::</a><a id='100' tid='99' class='m'>ActivationFrameAlignment</a>() <a id='102' tid='101' class='m'>!=</a> <a id='104' tid='103' class='m'>0</a>) {
    <a id='106' tid='105' class='m'>entry_stack</a> <a id='108' tid='107' class='m'>&=</a> <a id='110' tid='109' class='m'>-</a><a id='112' tid='111' class='m'>OS</a><a id='114' tid='113' class='m'>::</a><a id='116' tid='115' class='m'>ActivationFrameAlignment</a>();
  }
  // Store remaining arguments on stack, from low to high memory.
  <a id='80' tid='79' class='m'>intptr_t</a><a id='82' tid='81' class='m'>*</a> <a id='84' tid='83' class='m'>stack_argument</a> = <a id='86' tid='85' class='m'>reinterpret_cast</a>&lt;<a id='88' tid='87' class='m'>intptr_t</a><a id='90' tid='89' class='m'>*</a>&gt;(<a id='92' tid='91' class='m'>entry_stack</a>);
  <a id='46' tid='45' class='m'>for</a> (<a id='48' tid='47' class='m'>int</a> <a id='50' tid='49' class='m'>i</a> = <a id='52' tid='51' class='m'>4</a>; <a id='54' tid='53' class='m'>i</a> <a id='56' tid='55' class='m'>&lt;</a> <a id='58' tid='57' class='m'>argument_count</a>; <a id='60' tid='59' class='m'>i</a><a id='62' tid='61' class='m'>++</a>) {
    <a id='64' tid='63' class='m'>stack_argument</a>[<a id='66' tid='65' class='m'>i</a> <a id='68' tid='67' class='m'>-</a> <a id='70' tid='69' class='m'>4</a>] <a id='72' tid='71' class='m'>=</a> <a id='74' tid='73' class='m'>va_arg</a>(<a id='76' tid='75' class='m'>parameters</a>, <a id='78' tid='77' class='m'>int32_t</a>);
  }
  <a id='42' tid='41' class='m'>va_end</a>(<a id='44' tid='43' class='m'>parameters</a>);
  <a id='36' tid='35' class='m'>set_register</a>(<a id='38' tid='37' class='m'>sp</a>, <a id='40' tid='39' class='m'>entry_stack</a>);

  // Prepare to execute the code at entry
  <a id='26' tid='25' class='m'>set_register</a>(<a id='28' tid='27' class='m'>pc</a>, <a id='30' tid='29' class='m'>reinterpret_cast</a>&lt;<a id='32' tid='31' class='m'>int32_t</a>&gt;(<a id='34' tid='33' class='m'>entry</a>));
  // Put down marker for end of simulation. The simulator will stop simulation
  // when the PC reaches this value. By saving the &quot;end simulation&quot; value into
  // the LR the simulation stops when returning to this call point.
  <span class='i'>set_register(lr, end_sim_pc);</span>

  // Remember the values of callee-saved registers.
  // The code below assumes that r9 is not used as sb (static base) in
  // simulator code and therefore is regarded as a callee-saved register.
  <span class='i'>int32_t r4_val = get_register(r4);</span>
  <span class='i'>int32_t r5_val = get_register(r5);</span>
  <span class='i'>int32_t r6_val = get_register(r6);</span>
  <span class='i'>int32_t r7_val = get_register(r7);</span>
  <span class='i'>int32_t r8_val = get_register(r8);</span>
  <span class='i'>int32_t r9_val = get_register(r9);</span>
  <span class='i'>int32_t r10_val = get_register(r10);</span>
  <span class='i'>int32_t r11_val = get_register(r11);</span>

  // Setup the callee-saved registers with a known value. To be able to check
  // that they are preserved properly across JS execution.
  <a id='20' tid='19' class='m'>int32_t</a> <a id='22' tid='21' class='m'>callee_saved_value</a> = <a id='24' tid='23' class='m'>icount_</a>;
  <span class='i'>set_register(r4, callee_saved_value);</span>
  <span class='i'>set_register(r5, callee_saved_value);</span>
  <span class='i'>set_register(r6, callee_saved_value);</span>
  <span class='i'>set_register(r7, callee_saved_value);</span>
  <span class='i'>set_register(r8, callee_saved_value);</span>
  <span class='i'>set_register(r9, callee_saved_value);</span>
  <span class='i'>set_register(r10, callee_saved_value);</span>
  <span class='i'>set_register(r11, callee_saved_value);</span>

  // Start the simulation
  <span class='i'>Execute();</span>

  // Check that the callee-saved registers have been preserved.
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r4));</span>
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r5));</span>
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r6));</span>
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r7));</span>
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r8));</span>
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r9));</span>
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r10));</span>
  <span class='i'>CHECK_EQ(callee_saved_value, get_register(r11));</span>

  // Restore callee-saved registers with the original value.
  <span class='i'>set_register(r4, r4_val);</span>
  <span class='i'>set_register(r5, r5_val);</span>
  <span class='i'>set_register(r6, r6_val);</span>
  <span class='i'>set_register(r7, r7_val);</span>
  <span class='i'>set_register(r8, r8_val);</span>
  <span class='i'>set_register(r9, r9_val);</span>
  <span class='i'>set_register(r10, r10_val);</span>
  <span class='i'>set_register(r11, r11_val);</span>

  // Pop stack passed arguments.
  <a id='12' tid='11' class='m'>CHECK_EQ</a>(<a id='14' tid='13' class='m'>entry_stack</a>, <a id='16' tid='15' class='m'>get_register</a>(<a id='18' tid='17' class='m'>sp</a>));
  <a id='6' tid='5' class='m'>set_register</a>(<a id='8' tid='7' class='m'>sp</a>, <a id='10' tid='9' class='m'>original_stack</a>);

  <span class='i'>int32_t result = get_register(r0);</span>
  <a id='2' tid='1' class='m'>return</a> <a id='4' tid='3' class='m'>result</a>;
}


<a id='474' tid='473' class='m'>uintptr_t</a> <a id='476' tid='475' class='m'>Simulator</a><a id='478' tid='477' class='m'>::</a><a id='480' tid='479' class='m'>PushAddress</a>(<a id='482' tid='481' class='m'>uintptr_t</a> <a id='484' tid='483' class='m'>address</a>) {
  <a id='486' tid='485' class='m'>int</a> <a id='488' tid='487' class='m'>new_sp</a> = <a id='490' tid='489' class='m'>get_register</a>(<a id='492' tid='491' class='m'>sp</a>) <a id='494' tid='493' class='m'>-</a> <a id='496' tid='495' class='m'>sizeof</a>(<a id='498' tid='497' class='m'>uintptr_t</a>);
  <a id='500' tid='499' class='m'>uintptr_t</a><a id='502' tid='501' class='m'>*</a> <a id='504' tid='503' class='m'>stack_slot</a> = <a id='506' tid='505' class='m'>reinterpret_cast</a>&lt;<a id='508' tid='507' class='m'>uintptr_t</a><a id='510' tid='509' class='m'>*</a>&gt;(<a id='512' tid='511' class='m'>new_sp</a>);
  <a id='514' tid='513' class='m'>*</a><a id='516' tid='515' class='m'>stack_slot</a> <a id='518' tid='517' class='m'>=</a> <a id='520' tid='519' class='m'>address</a>;
  <a id='522' tid='521' class='m'>set_register</a>(<a id='524' tid='523' class='m'>sp</a>, <a id='526' tid='525' class='m'>new_sp</a>);
  <a id='528' tid='527' class='m'>return</a> <a id='530' tid='529' class='m'>new_sp</a>;
}


<a id='372' tid='371' class='m'>uintptr_t</a> <a id='374' tid='373' class='m'>Simulator</a><a id='376' tid='375' class='m'>::</a><a id='378' tid='377' class='m'>PopAddress</a>() {
  <a id='380' tid='379' class='m'>int</a> <a id='382' tid='381' class='m'>current_sp</a> = <a id='384' tid='383' class='m'>get_register</a>(<a id='386' tid='385' class='m'>sp</a>);
  <a id='388' tid='387' class='m'>uintptr_t</a><a id='390' tid='389' class='m'>*</a> <a id='392' tid='391' class='m'>stack_slot</a> = <a id='394' tid='393' class='m'>reinterpret_cast</a>&lt;<a id='396' tid='395' class='m'>uintptr_t</a><a id='398' tid='397' class='m'>*</a>&gt;(<a id='400' tid='399' class='m'>current_sp</a>);
  <a id='402' tid='401' class='m'>uintptr_t</a> <a id='404' tid='403' class='m'>address</a> = <a id='406' tid='405' class='m'>*</a><a id='408' tid='407' class='m'>stack_slot</a>;
  <a id='410' tid='409' class='m'>set_register</a>(<a id='412' tid='411' class='m'>sp</a>, <a id='414' tid='413' class='m'>current_sp</a> <a id='416' tid='415' class='m'>+</a> <a id='418' tid='417' class='m'>sizeof</a>(<a id='420' tid='419' class='m'>uintptr_t</a>));
  <a id='422' tid='421' class='m'>return</a> <a id='424' tid='423' class='m'>address</a>;
}

} }  // namespace v8::internal

<span class='i'>#endif</span>  // USE_SIMULATOR

<span class='i'>#endif</span>  // V8_TARGET_ARCH_ARM


</pre>
</div>
</body>
</html>
