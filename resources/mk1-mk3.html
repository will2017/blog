<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<LINK href="diff.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="nav.js"></script>
</head>
<body>
<div id="left" class="src">
<pre>
<a id='leftstart' tid='rightstart'></a>
<span class='d'>;;; This file was generated by writeminikanren.pl
</span><span class='d'>;;; Generated at 2007-10-25 15:24:42
</span>
(<a id='407' tid='408' class='m'>define-syntax</a> <a id='409' tid='410' class='m'>lambdag@</a>
  <span class='d'>(syntax-rules ()
    ((_ (p) e) (lambda (p) e)))</span>)

(<a id='393' tid='394' class='m'>define-syntax</a> <a id='395' tid='396' class='m'>lambdaf@</a>
  (<a id='397' tid='398' class='m'>syntax-rules</a> ()
    ((<a id='399' tid='400' class='m'>_</a> () <a id='401' tid='402' class='m'>e</a>) (<a id='403' tid='404' class='m'>lambda</a> () <a id='405' tid='406' class='m'>e</a>))))

(<a id='487' tid='488' class='m'>define-syntax</a> <a id='489' tid='490' class='m'>run*</a>
  (<a id='491' tid='492' class='m'>syntax-rules</a> ()
    ((<a id='493' tid='494' class='m'>_</a> (<a id='495' tid='496' class='m'>x</a>) <a id='497' tid='498' class='m'>g</a> <a id='499' tid='500' class='m'>...</a>) (<a id='501' tid='502' class='m'>run</a> <a id='503' tid='504' class='m'>#f</a> (<a id='505' tid='506' class='m'>x</a>) <a id='507' tid='508' class='m'>g</a> <a id='509' tid='510' class='m'>...</a>))))

<span class='d'>(define-syntax rhs
  (syntax-rules ()
    ((_ x) (cdr x))))</span>

<span class='d'>(define-syntax lhs
  (syntax-rules ()
    ((_ x) (car x))))</span>

<span class='d'>(define-syntax size-s
  (syntax-rules ()
    ((_ x) (length x))))</span>

<span class='d'>(define-syntax var
  (syntax-rules ()
    ((_ x) (vector x))))</span>

(<span class='d'>define-syntax</span> <span class='d'>var?</span>
  (<span class='d'>syntax-rules</span> <span class='d'>()</span>
    (<span class='d'>(_ x)</span> (<a id='119' tid='120' class='m'>vector?</a> <a id='121' tid='122' class='m'>x</a>))))


<span class='d'>(define empty-s &#39;())</span>

(<a id='529' tid='530' class='m'>define</a> <a id='531' tid='532' class='m'>walk</a>
  <span class='d'>(lambda (v s)
    (cond
      ((var? v)
       (let ((a (assq v s)))
         (cond
           (a (walk (rhs a) s))
           (else v))))
      (else v)))</span>)

(<span class='d'>define</span> <span class='d'>ext-s</span>
  (<span class='d'>lambda</span> <span class='d'>(x v s)</span>
    (<span class='d'>cons</span> <span class='d'>`</span>(<a id='41' tid='42' class='m'>,</a><a id='43' tid='44' class='m'>x</a> <a id='45' tid='46' class='m'>.</a> <a id='47' tid='48' class='m'>,</a><a id='49' tid='50' class='m'>v</a>) <span class='d'>s</span>)))

(<a id='525' tid='526' class='m'>define</a> <a id='527' tid='528' class='m'>unify</a>
  (<span class='d'>lambda</span> <span class='d'>(v w s)</span>
    (<span class='d'>let</span> <span class='d'>((v (walk v s))
          (w (walk w s)))</span>
      (<span class='d'>cond</span>
        <span class='d'>((eq? v w) s)</span>
        <span class='d'>((var? v) (ext-s v w s))</span>
        <span class='d'>((var? w) (ext-s w v s))</span>
        ((<span class='d'>and</span> (<a id='123' tid='124' class='m'>pair?</a> <a id='125' tid='126' class='m'>v</a>) <span class='d'>(pair? w)</span>)
         (<a id='127' tid='128' class='m'>let</a> ((<span class='d'>s</span> (<span class='d'>unify</span> (<a id='129' tid='130' class='m'>car</a> <a id='131' tid='132' class='m'>v</a>) <span class='d'>(car w)</span> <span class='d'>s</span>)))
           (<span class='d'>and</span> <span class='d'>s</span> (<span class='d'>unify</span> (<a id='133' tid='134' class='m'>cdr</a> <a id='135' tid='136' class='m'>v</a>) <span class='d'>(cdr w)</span> <span class='d'>s</span>))))
        <span class='d'>((equal? v w) s)</span>
        <span class='d'>(else #f)</span>))))

(<span class='d'>define</span> <span class='d'>unify-check</span>
  (<span class='d'>lambda</span> <span class='d'>(u v s)</span>
    (<span class='d'>let</span> <span class='d'>((u (walk u s))
          (v (walk v s)))</span>
      (<span class='d'>cond</span>
        <span class='d'>((eq? u v) s)</span>
        <span class='d'>((var? u) (ext-s-check u v s))</span>
        <span class='d'>((var? v) (ext-s-check v u s))</span>
        ((<a id='109' tid='110' class='m'>and</a> (<a id='111' tid='112' class='m'>pair?</a> <a id='113' tid='114' class='m'>u</a>) (<a id='115' tid='116' class='m'>pair?</a> <a id='117' tid='118' class='m'>v</a>))
         <span class='d'>(let ((s (unify-check 
                    (car u) (car v) s)))
           (and s (unify-check 
                    (cdr u) (cdr v) s)))</span>)
        <span class='d'>((equal? u v) s)</span>
        <span class='d'>(else #f)</span>))))

 
<span class='d'>(define ext-s-check
  (lambda (x v s)
    (cond
      ((occurs-check x v s) #f)
      (else (ext-s x v s)))))</span>

(<a id='447' tid='448' class='m'>define</a> <a id='449' tid='450' class='m'>occurs-check</a>
  (<span class='d'>lambda</span> <span class='d'>(x v s)</span>
    (<span class='d'>let</span> <span class='d'>((v (walk v s)))</span>
      (<span class='d'>cond</span>
        (<span class='d'>(var? v)</span> (<a id='137' tid='138' class='m'>eq?</a> <a id='139' tid='140' class='m'>v</a> <a id='141' tid='142' class='m'>x</a>))
        <span class='d'>((pair? v) 
         (or 
           (occurs-check x (car v) s)
           (occurs-check x (cdr v) s)))</span>
        <span class='d'>(else #f)</span>))))

(<a id='533' tid='534' class='m'>define</a> <a id='535' tid='536' class='m'>walk*</a>
  <span class='d'>(lambda (w s)
    (let ((v (walk w s)))
      (cond
        ((var? v) v)
        ((pair? v)
         (cons
           (walk* (car v) s)
           (walk* (cdr v) s)))
        (else v))))</span>)

<span class='d'>(define reify-s
  (lambda (v s)
    (let ((v (walk v s)))
      (cond
        ((var? v)
         (ext-s v (reify-name (size-s s)) s))
        ((pair? v) (reify-s (cdr v)
                     (reify-s (car v) s)))
        (else s)))))</span>

(<a id='463' tid='464' class='m'>define</a> <a id='465' tid='466' class='m'>reify-name</a>
  (<a id='467' tid='468' class='m'>lambda</a> (<a id='469' tid='470' class='m'>n</a>)
    (<a id='471' tid='472' class='m'>string-&gt;symbol</a>
      (<a id='473' tid='474' class='m'>string-append</a> <a id='475' tid='476' class='m'>&quot;_&quot;</a> <a id='477' tid='478' class='m'>&quot;.&quot;</a> (<a id='479' tid='480' class='m'>number-&gt;string</a> <a id='481' tid='482' class='m'>n</a>)))))

(<a id='459' tid='460' class='m'>define</a> <a id='461' tid='462' class='m'>reify</a>
  <span class='d'>(lambda (v s)
    (let ((v (walk* v s)))
      (walk* v (reify-s v empty-s))))</span>)

(<a id='303' tid='304' class='m'>define</a> <a id='305' tid='306' class='m'>==</a> 
  (<span class='d'>lambda</span> (<a id='33' tid='34' class='m'>u</a> <a id='35' tid='36' class='m'>v</a>)
    <span class='d'>(lambdag@ (s) (unify u v s))</span>))

<span class='d'>(define ==-check
  (lambda (v w)
    (lambdag@ (s)
      (unify-check v w s))))</span>

<span class='d'>(define-syntax mzero 
  (syntax-rules () ((_) #f)))</span>

(<a id='379' tid='380' class='m'>define-syntax</a> <a id='381' tid='382' class='m'>inc</a> 
  (<a id='383' tid='384' class='m'>syntax-rules</a> () ((<a id='385' tid='386' class='m'>_</a> <a id='387' tid='388' class='m'>e</a>) (<a id='389' tid='390' class='m'>lambdaf@</a> () <a id='391' tid='392' class='m'>e</a>))))

<span class='d'>(define-syntax unit 
  (syntax-rules () ((_ a) a)))</span>

<span class='d'>(define-syntax choice 
  (syntax-rules () ((_ a f) (cons a f))))</span>
 
(<a id='345' tid='346' class='m'>define-syntax</a> <a id='347' tid='348' class='m'>case-inf</a>
  (<a id='143' tid='144' class='m'>syntax-rules</a> ()
    ((<span class='d'>_</span> <span class='d'>e</span> <span class='d'>(() e0)</span> ((<a id='145' tid='146' class='m'>f^</a>) <a id='147' tid='148' class='m'>e1</a>) <span class='d'>((a^) e2)</span> <span class='d'>((a f) e3)</span>)
     <span class='d'>(let ((a-inf e))
       (cond
         ((not a-inf) e0)
         ((procedure? a-inf) (let ((f^ a-inf)) e1))
         ((not (and (pair? a-inf)
                    (procedure? (cdr a-inf))))
          (let ((a^ a-inf)) e2))
         (else (let ((a (car a-inf)) (f (cdr a-inf))) 
                 e3))))</span>)))

(<a id='483' tid='484' class='m'>define-syntax</a> <a id='485' tid='486' class='m'>run</a>
  (<a id='149' tid='150' class='m'>syntax-rules</a> ()
    ((<a id='151' tid='152' class='m'>_</a> <a id='153' tid='154' class='m'>n</a> (<a id='155' tid='156' class='m'>x</a>) <a id='157' tid='158' class='m'>g0</a> <a id='159' tid='160' class='m'>g</a> <a id='161' tid='162' class='m'>...</a>)
     <span class='d'>(take n
       (lambdaf@ ()
         ((exist (x) g0 g ... 
            (lambdag@ (s)
              (cons (reify x s) &#39;())))
          empty-s)))</span>)))
 
(<a id='521' tid='522' class='m'>define</a> <a id='523' tid='524' class='m'>take</a>
  (<a id='163' tid='164' class='m'>lambda</a> (<a id='165' tid='166' class='m'>n</a> <a id='167' tid='168' class='m'>f</a>)
    (<span class='d'>if</span> (<a id='169' tid='170' class='m'>and</a> <a id='171' tid='172' class='m'>n</a> (<a id='173' tid='174' class='m'>zero?</a> <a id='175' tid='176' class='m'>n</a>)) 
      <span class='d'>&#39;</span><span class='d'>()</span>
      (<span class='d'>case-inf</span> <span class='d'>(f)</span>
        <span class='d'>(() &#39;())</span>
        ((<a id='51' tid='52' class='m'>f</a>) (<a id='53' tid='54' class='m'>take</a> <a id='55' tid='56' class='m'>n</a> <a id='57' tid='58' class='m'>f</a>))
        <span class='d'>((a) a)</span>
        (<span class='d'>(a f)</span>
         (<span class='d'>cons</span> <span class='d'>(car a)</span>
           (<a id='9' tid='10' class='m'>take</a> (<a id='11' tid='12' class='m'>and</a> <a id='13' tid='14' class='m'>n</a> (<a id='15' tid='16' class='m'>-</a> <a id='17' tid='18' class='m'>n</a> <a id='19' tid='20' class='m'>1</a>)) <a id='21' tid='22' class='m'>f</a>)))))))

 
(<span class='d'>define-syntax</span> <span class='d'>exist</span>
  (<a id='83' tid='84' class='m'>syntax-rules</a> ()
    ((<a id='85' tid='86' class='m'>_</a> (<a id='87' tid='88' class='m'>x</a> <a id='89' tid='90' class='m'>...</a>) <a id='91' tid='92' class='m'>g0</a> <a id='93' tid='94' class='m'>g</a> <a id='95' tid='96' class='m'>...</a>)
     (<span class='d'>lambdag@</span> <span class='d'>(s)</span>
       (<a id='97' tid='98' class='m'>inc</a>
         (<span class='d'>let</span> ((<a id='99' tid='100' class='m'>x</a> (<a id='101' tid='102' class='m'>var</a> <a id='103' tid='104' class='m'>&#39;</a><a id='105' tid='106' class='m'>x</a>)) <a id='107' tid='108' class='m'>...</a>)
           <span class='d'>(bind* (g0 s) g ...)</span>))))))
 
(<a id='311' tid='312' class='m'>define-syntax</a> <a id='313' tid='314' class='m'>bind*</a>
  (<a id='315' tid='316' class='m'>syntax-rules</a> ()
    ((<a id='317' tid='318' class='m'>_</a> <a id='319' tid='320' class='m'>e</a>) <a id='321' tid='322' class='m'>e</a>)
    ((<a id='323' tid='324' class='m'>_</a> <a id='325' tid='326' class='m'>e</a> <a id='327' tid='328' class='m'>g0</a> <a id='329' tid='330' class='m'>g</a> <a id='331' tid='332' class='m'>...</a>) (<a id='333' tid='334' class='m'>bind*</a> (<a id='335' tid='336' class='m'>bind</a> <a id='337' tid='338' class='m'>e</a> <a id='339' tid='340' class='m'>g0</a>) <a id='341' tid='342' class='m'>g</a> <a id='343' tid='344' class='m'>...</a>))))
 
(<a id='307' tid='308' class='m'>define</a> <a id='309' tid='310' class='m'>bind</a>
  (<span class='d'>lambda</span> <span class='d'>(a-inf g)</span>
    (<span class='d'>case-inf</span> <span class='d'>a-inf</span>
      <span class='d'>(() (mzero))</span>
      ((<a id='23' tid='24' class='m'>f</a>) (<a id='25' tid='26' class='m'>inc</a> (<a id='27' tid='28' class='m'>bind</a> (<a id='29' tid='30' class='m'>f</a>) <a id='31' tid='32' class='m'>g</a>)))
      <span class='d'>((a) (g a))</span>
      (<span class='d'>(a f)</span> (<span class='d'>mplus</span> <span class='d'>(g a)</span> (<a id='1' tid='2' class='m'>lambdaf@</a> () (<a id='3' tid='4' class='m'>bind</a> (<a id='5' tid='6' class='m'>f</a>) <a id='7' tid='8' class='m'>g</a>)))))))

(<a id='353' tid='354' class='m'>define-syntax</a> <a id='355' tid='356' class='m'>conde</a>
  (<a id='177' tid='178' class='m'>syntax-rules</a> ()
    ((<a id='179' tid='180' class='m'>_</a> (<a id='181' tid='182' class='m'>g0</a> <a id='183' tid='184' class='m'>g</a> <a id='185' tid='186' class='m'>...</a>) (<a id='187' tid='188' class='m'>g1</a> <a id='189' tid='190' class='m'>g^</a> <a id='191' tid='192' class='m'>...</a>) <a id='193' tid='194' class='m'>...</a>)
     <span class='d'>(lambdag@ (s) 
       (inc 
         (mplus* 
           (bind* (g0 s) g ...)
           (bind* (g1 s) g^ ...) ...)))</span>)))
 
(<a id='415' tid='416' class='m'>define-syntax</a> <a id='417' tid='418' class='m'>mplus*</a>
  (<a id='419' tid='420' class='m'>syntax-rules</a> ()
    ((<a id='421' tid='422' class='m'>_</a> <a id='423' tid='424' class='m'>e</a>) <a id='425' tid='426' class='m'>e</a>)
    ((<a id='427' tid='428' class='m'>_</a> <a id='429' tid='430' class='m'>e0</a> <a id='431' tid='432' class='m'>e</a> <a id='433' tid='434' class='m'>...</a>) (<a id='435' tid='436' class='m'>mplus</a> <a id='437' tid='438' class='m'>e0</a> 
                    (<a id='439' tid='440' class='m'>lambdaf@</a> () (<a id='441' tid='442' class='m'>mplus*</a> <a id='443' tid='444' class='m'>e</a> <a id='445' tid='446' class='m'>...</a>))))))
 
(<a id='411' tid='412' class='m'>define</a> <a id='413' tid='414' class='m'>mplus</a>
  (<span class='d'>lambda</span> <span class='d'>(a-inf f)</span>
    (<span class='d'>case-inf</span> <span class='d'>a-inf</span>
      <span class='d'>(() (f))</span>
      ((<a id='195' tid='196' class='m'>f^</a>) (<a id='197' tid='198' class='m'>inc</a> (<a id='199' tid='200' class='m'>mplus</a> (<a id='201' tid='202' class='m'>f</a>) <a id='203' tid='204' class='m'>f^</a>)))
      <span class='d'>((a) (choice a f))</span>
      (<span class='d'>(a f^)</span> (<span class='d'>choice</span> <span class='d'>a</span> (<a id='59' tid='60' class='m'>lambdaf@</a> () (<a id='61' tid='62' class='m'>mplus</a> (<a id='63' tid='64' class='m'>f</a>) <a id='65' tid='66' class='m'>f^</a>)))))))

(<a id='349' tid='350' class='m'>define-syntax</a> <a id='351' tid='352' class='m'>conda</a>
  (<a id='205' tid='206' class='m'>syntax-rules</a> ()
    ((<a id='207' tid='208' class='m'>_</a> (<a id='209' tid='210' class='m'>g0</a> <a id='211' tid='212' class='m'>g</a> <a id='213' tid='214' class='m'>...</a>) (<a id='215' tid='216' class='m'>g1</a> <a id='217' tid='218' class='m'>g^</a> <a id='219' tid='220' class='m'>...</a>) <a id='221' tid='222' class='m'>...</a>)
     <span class='d'>(lambdag@ (s)
       (inc
         (ifa ((g0 s) g ...)
              ((g1 s) g^ ...) ...)))</span>)))
 
(<a id='371' tid='372' class='m'>define-syntax</a> <a id='373' tid='374' class='m'>ifa</a>
  (<a id='223' tid='224' class='m'>syntax-rules</a> ()
    ((<a id='225' tid='226' class='m'>_</a>) (<a id='227' tid='228' class='m'>mzero</a>))
    ((<a id='229' tid='230' class='m'>_</a> (<a id='231' tid='232' class='m'>e</a> <a id='233' tid='234' class='m'>g</a> <a id='235' tid='236' class='m'>...</a>) <a id='237' tid='238' class='m'>b</a> <a id='239' tid='240' class='m'>...</a>)
     (<span class='d'>let</span> <span class='d'>loop</span> <span class='d'>((a-inf e))</span>
       (<span class='d'>case-inf</span> <span class='d'>a-inf</span>
         (() (<a id='241' tid='242' class='m'>ifa</a> <a id='243' tid='244' class='m'>b</a> <a id='245' tid='246' class='m'>...</a>))
         ((<a id='67' tid='68' class='m'>f</a>) (<a id='69' tid='70' class='m'>inc</a> (<a id='71' tid='72' class='m'>loop</a> (<a id='73' tid='74' class='m'>f</a>))))
         <span class='d'>((a) (bind* a-inf g ...))</span>
         ((<a id='37' tid='38' class='m'>a</a> <a id='39' tid='40' class='m'>f</a>) <span class='d'>(bind* a-inf g ...)</span>))))))

(<a id='357' tid='358' class='m'>define-syntax</a> <a id='359' tid='360' class='m'>condu</a>
  (<a id='247' tid='248' class='m'>syntax-rules</a> ()
    ((<a id='249' tid='250' class='m'>_</a> (<a id='251' tid='252' class='m'>g0</a> <a id='253' tid='254' class='m'>g</a> <a id='255' tid='256' class='m'>...</a>) (<a id='257' tid='258' class='m'>g1</a> <a id='259' tid='260' class='m'>g^</a> <a id='261' tid='262' class='m'>...</a>) <a id='263' tid='264' class='m'>...</a>)
     <span class='d'>(lambdag@ (s)
       (inc
         (ifu ((g0 s) g ...)
              ((g1 s) g^ ...) ...)))</span>)))
 
(<a id='375' tid='376' class='m'>define-syntax</a> <a id='377' tid='378' class='m'>ifu</a>
  (<a id='265' tid='266' class='m'>syntax-rules</a> ()
    ((<a id='267' tid='268' class='m'>_</a>) (<a id='269' tid='270' class='m'>mzero</a>))
    ((<a id='271' tid='272' class='m'>_</a> (<a id='273' tid='274' class='m'>e</a> <a id='275' tid='276' class='m'>g</a> <a id='277' tid='278' class='m'>...</a>) <a id='279' tid='280' class='m'>b</a> <a id='281' tid='282' class='m'>...</a>)
     (<span class='d'>let</span> <span class='d'>loop</span> <span class='d'>((a-inf e))</span>
       (<span class='d'>case-inf</span> <span class='d'>a-inf</span>
         (() (<a id='283' tid='284' class='m'>ifu</a> <a id='285' tid='286' class='m'>b</a> <a id='287' tid='288' class='m'>...</a>))
         ((<a id='75' tid='76' class='m'>f</a>) (<a id='77' tid='78' class='m'>inc</a> (<a id='79' tid='80' class='m'>loop</a> (<a id='81' tid='82' class='m'>f</a>))))
         <span class='d'>((a) (bind* a-inf g ...))</span>
         <span class='d'>((a f) (bind* (unit a) g ...))</span>)))))

(<a id='455' tid='456' class='m'>define-syntax</a> <a id='457' tid='458' class='m'>project</a>
  (<a id='289' tid='290' class='m'>syntax-rules</a> ()
    ((<a id='291' tid='292' class='m'>_</a> (<a id='293' tid='294' class='m'>x</a> <a id='295' tid='296' class='m'>...</a>) <a id='297' tid='298' class='m'>g</a> <a id='299' tid='300' class='m'>g*</a> <a id='301' tid='302' class='m'>...</a>)
     <span class='d'>(lambdag@ (s)
       (let ((x (walk* x s)) ...)
         ((exist () g g* ...) s)))</span>)))

(<a id='511' tid='512' class='m'>define</a> <a id='513' tid='514' class='m'>succeed</a> (<a id='515' tid='516' class='m'>==</a> <a id='517' tid='518' class='m'>#f</a> <a id='519' tid='520' class='m'>#f</a>))

(<a id='361' tid='362' class='m'>define</a> <a id='363' tid='364' class='m'>fail</a> (<a id='365' tid='366' class='m'>==</a> <a id='367' tid='368' class='m'>#f</a> <a id='369' tid='370' class='m'>#t</a>))

(<a id='451' tid='452' class='m'>define</a> <a id='453' tid='454' class='m'>onceo</a>
  <span class='d'>(lambda (g)
    (condu
      (g succeed)
      (else fail)))</span>)


</pre>
</div>
<div id="right" class="src">
<pre>
<a id='rightstart' tid='leftstart'></a>
<span class='i'>;; Recently improved by Jason Hemann and Dan Friedman
</span>
<span class='i'>;; The code of this system comprises two steps.  The first step is to run
</span><span class='i'>;; a goal and check if the result fails to make sense: we term this
</span><span class='i'>;; &quot;fast fail&quot;.  If each goal goes to completion, then we have the reify
</span><span class='i'>;; step.  The work of the reify step is to take the final state of the
</span><span class='i'>;; computation and return a Scheme value.  This also comprises two steps.
</span><span class='i'>;; The first step is to try every funtion in a cycle of functions that try
</span><span class='i'>;; to make a new state, which is then fed to the next function in the cycle.
</span><span class='i'>;; Each cycle function takes a state and returns a state: it cannot fail.
</span><span class='i'>;; When one of the functions does not improve the state, it becomes the
</span><span class='i'>;; function to reach without ever changing the state by the intervening
</span><span class='i'>;; functions.  When no improvements can be made we have found a fixed point.
</span><span class='i'>;; Each of these intervening cycle functions tried to change the state, but
</span><span class='i'>;; couldn&#39;t.  Next we turn the value along with the non-empty fields of the
</span><span class='i'>;; state into a list structure.  Reification does not appear to be a
</span><span class='i'>;; bottleneck, since it is just turning an answer into something readable.
</span><span class='i'>;; There may be many answers, and each answer has to be reified.
</span>
<span class='i'>;; We have just added not-pairo to the system.  It appears to be working
</span><span class='i'>;; and passes our test cases. It&#39;s field is called A.
</span>
<span class='i'>(define rhs
  (lambda (pr)
    (cdr pr)))</span>
 
<span class='i'>(define lhs
  (lambda (pr)
    (car pr)))</span>

<span class='i'>(define-syntax case-value
  (syntax-rules ()
    ((_ u ((t1) e0) ((at dt) e1) ((t2) e2))
     (let ((t u))
       (cond
	 ((var? t) (let ((t1 t)) e0))
	 ((pair? t) (let ((at (car t)) (dt (cdr t))) e1))
	 (else (let ((t2 t)) e2)))))))</span>

<span class='i'>(define var
  (lambda (dummy)
    (vector dummy)))</span>
 
(<span class='i'>define</span> <span class='i'>var?</span>
  (<span class='i'>lambda</span> <span class='i'>(x)</span>
    (<a id='120' tid='119' class='m'>vector?</a> <a id='122' tid='121' class='m'>x</a>)))

(<a id='530' tid='529' class='m'>define</a> <a id='532' tid='531' class='m'>walk</a>
  <span class='i'>(lambda (u H)
    (cond
      ((and (var? u) (assq u H)) =&gt;
       (lambda (pr) (walk (rhs pr) H)))
      (else u)))</span>)

(<a id='526' tid='525' class='m'>define</a> <a id='528' tid='527' class='m'>unify</a>
  (<span class='i'>lambda</span> <span class='i'>(u v H)</span>
    (<span class='i'>let</span> <span class='i'>((u (walk u H))
          (v (walk v H)))</span>
      (<span class='i'>cond</span>
        ((<span class='i'>and</span> <span class='i'>(pair? u)</span> (<a id='124' tid='123' class='m'>pair?</a> <a id='126' tid='125' class='m'>v</a>))
         (<a id='128' tid='127' class='m'>let</a> ((<span class='i'>H</span> (<span class='i'>unify</span> <span class='i'>(car u)</span> (<a id='130' tid='129' class='m'>car</a> <a id='132' tid='131' class='m'>v</a>) <span class='i'>H</span>)))
           (<span class='i'>and</span> <span class='i'>H</span>
             (<span class='i'>unify</span> <span class='i'>(cdr u)</span> (<a id='134' tid='133' class='m'>cdr</a> <a id='136' tid='135' class='m'>v</a>) <span class='i'>H</span>))))
        <span class='i'>(else (unify-nonpair u v H))</span>))))
 
<span class='i'>(define unify-nonpair
  (lambda (u v H)
    (cond
      ((eq? u v) H)
      ((var? u) (ext-H-check u v H))
      ((var? v) (ext-H-check v u H))
      ((equal? u v) H)
      (else #f))))</span>

<span class='i'>(define ext-H-check
  (lambda (x v H)
    (case-value v
      ((v) (ext-H x v H))
      ((au du) (cond
                 ((occurs-check x v H) #f)
                 (else (ext-H x v H))))
      ((v) (ext-H x v H)))))</span>
 
(<span class='i'>define</span> <span class='i'>ext-H</span>
  (<span class='i'>lambda</span> <span class='i'>(x v H)</span>
    (<span class='i'>cons</span> <span class='i'>`</span>(<a id='42' tid='41' class='m'>,</a><a id='44' tid='43' class='m'>x</a> <a id='46' tid='45' class='m'>.</a> <a id='48' tid='47' class='m'>,</a><a id='50' tid='49' class='m'>v</a>) <span class='i'>H</span>)))
     
(<a id='448' tid='447' class='m'>define</a> <a id='450' tid='449' class='m'>occurs-check</a>
  (<span class='i'>lambda</span> <span class='i'>(x v H)</span>
    (<span class='i'>case-value</span> <span class='i'>(walk v H)</span>
      (<span class='i'>(v)</span> (<a id='138' tid='137' class='m'>eq?</a> <a id='140' tid='139' class='m'>v</a> <a id='142' tid='141' class='m'>x</a>))
      <span class='i'>((av dv)
       (or (occurs-check x av H)
           (occurs-check x dv H)))</span>
      <span class='i'>((v) #f)</span>)))

<span class='i'>(define prefix-H
  (lambda (H0 H)
    (cond
      ((eq? H0 H) &#39;())
      (else (cons (car H0)
              (prefix-H (cdr H0) H))))))</span>

(<a id='534' tid='533' class='m'>define</a> <a id='536' tid='535' class='m'>walk*</a>
  <span class='i'>(lambda (v H)
    (case-value (walk v H)
      ((v) v)
      ((av dv)
       (cons (walk* av H) (walk* dv H)))
      ((v) v)))</span>)

<span class='i'>(define reify-R
  (lambda (v R)
    (case-value (walk v R)
      ((v) (let ((n (length R)))
             (let ((name (reify-name n)))
               (ext-H v name R))))
      ((av dv) (let ((R (reify-R av R)))
                 (reify-R dv R)))
      ((v) R))))</span>

(<span class='i'>define</span> <span class='i'>unify-safe</span>
  (<span class='i'>lambda</span> <span class='i'>(u v H)</span>
    (<span class='i'>let</span> <span class='i'>((u (walk u H))
          (v (walk v H)))</span>
      (<span class='i'>cond</span>
        ((<a id='110' tid='109' class='m'>and</a> (<a id='112' tid='111' class='m'>pair?</a> <a id='114' tid='113' class='m'>u</a>) (<a id='116' tid='115' class='m'>pair?</a> <a id='118' tid='117' class='m'>v</a>))
         <span class='i'>(let ((H (unify-safe (car u) (car v) H)))
           (and H
             (unify-safe (cdr u) (cdr v) H)))</span>)
        <span class='i'>(else (unify-nonpair-safe u v H))</span>))))
  
<span class='i'>(define unify-nonpair-safe
  (lambda (u v H)
    (cond
      ((eq? u v) H)
      ((var? u) (ext-H u v H))
      ((var? v) (ext-H v u H))
      (else H))))</span>

(<a id='464' tid='463' class='m'>define</a> <a id='466' tid='465' class='m'>reify-name</a>
  (<a id='468' tid='467' class='m'>lambda</a> (<a id='470' tid='469' class='m'>n</a>)
    (<a id='472' tid='471' class='m'>string-&gt;symbol</a>
      (<a id='474' tid='473' class='m'>string-append</a> <a id='476' tid='475' class='m'>&quot;_&quot;</a> <a id='478' tid='477' class='m'>&quot;.&quot;</a> (<a id='480' tid='479' class='m'>number-&gt;string</a> <a id='482' tid='481' class='m'>n</a>)))))

(<a id='460' tid='459' class='m'>define</a> <a id='462' tid='461' class='m'>reify</a>
  <span class='i'>(lambda (x)
    (lambda (c)
      (let ((c (cycle c)))
        (let ((H (c-&gt;H c)))
          (let ((D (walk* (c-&gt;D c) H))
                (Y (walk* (c-&gt;Y c) H)) 
                (N (walk* (c-&gt;N c) H))
                (A (walk* (c-&gt;A c) H))
                (T (walk* (c-&gt;T c) H)))
          (let ((v (walk* x H)))
            (let ((R (reify-R v &#39;())))
              (reify+
                v R c H D Y N A T))))))))</span>)
 
<span class='i'>(define reify+
  (lambda (v R c H D Y N A T)
    (reify++ v R
      (D-subsumed
       (remp
          (lambda (d) 
            (anyvar? (walk* d H) R))
          (drop-from-D-using-T H
            (c-&gt;Y c) (c-&gt;N c)
	    (c-&gt;A c) (c-&gt;T c)
            (rem-xx-from-D D H)))) 
      (remp (lambda (y) (anyvar? y R))
        Y)
      (remp (lambda (n) (anyvar? n R))
        N)
      (remp (lambda (a) (anyvar? a R))
        A)
      (remp (lambda (t) (anyvar? t R))
        T))))</span>
 
<span class='i'>(define reify++
  (lambda (v R D Y N A T)
    (form (walk* v R) (walk* D R)
          (walk* Y R) (walk* N R)
          (walk* A R) (T-subsumed (walk* T R)))))</span>
 
<span class='i'>(define form
  (lambda (v D Y N A T)
    (let ((fd (sort-D D))
          (fy (sorter Y))
          (fn (sorter N))
          (fa (sorter A))
          (ft (sorter T)))
      (let ((fd (if (null? fd) fd
                    (let ((fd (drop-dot-D fd)))
                      `((=/= . ,fd)))))
            (fy (if (null? fy) fy `((sym . ,fy))))
            (fn (if (null? fn) fn `((num . ,fn))))
            (fa (if (null? fa) fa `((not-pair . ,fa))))
            (ft (if (null? ft) ft
                    (let ((ft (drop-dot ft)))
                      `((absento . ,ft))))))
        (cond
          ((and (null? fd) (null? fy)
                (null? fn) (null? fa)
                (null? ft))
           v)
          (else (append `(,v) fd fa fn fy ft)))))))</span>

<span class='i'>(define lex&lt;=?
  (lambda (x y)
    (cond
      ((vector? x) #t)
      ((vector? y) #f)
      ((port? x) #t)
      ((port? y) #f)
      ((procedure? x) #t)
      ((procedure? y) #f)
      ((boolean? x)
       (cond
         ((boolean? y) (or (not x) (eq? x y)))
         (else #t)))
      ((boolean? y) #f)
      ((null? x) #t)
      ((null? y) #f)
      ((char? x)
       (cond
         ((char? y) (char&lt;=? x y))
         (else #t)))
      ((char? y) #f)
      ((number? x)
       (cond
         ((number? y) (&lt;= x y))
         (else #t)))
      ((number? y) #f)
      ((string? x)
       (cond
         ((string? y) (string&lt;=? x y))
         (else #t)))
      ((string? y) #f)
      ((symbol? x)
       (cond
         ((symbol? y)
          (string&lt;=? (symbol-&gt;string x)
                     (symbol-&gt;string y)))
         (else #t)))
      ((symbol? y) #f)
      ((pair? x)
       (cond
         ((pair? y)
          (cond          
            ((equal? (car x) (car y))
             (lex&lt;=? (cdr x) (cdr y)))
            (else (lex&lt;=? (car x) (car y)))))))
      ((pair? y) #f)
      (else #t))))</span>

<span class='i'>(define sorter
  (lambda (ls)
    (sort lex&lt;=? ls)))</span>
 
<span class='i'>(define sort-D
  (lambda (D)
    (sorter
      (map sort-d D))))</span>
 
<span class='i'>(define sort-d
  (lambda (d)
    (sort
      (lambda (x y)
        (lex&lt;=? (car x) (car y)))
      (map sort-pr d))))</span>
 
<span class='i'>(define drop-dot
  (lambda (X)
    (map (lambda (t)
           (let ((a (lhs t))
                 (d (rhs t)))
             `(,a ,d)))
         X)))</span>
          
<span class='i'>(define datum-&gt;string
  (lambda (x)
    (call-with-string-output-port
      (lambda (p) (display x p)))))</span>         
 
<span class='i'>(define drop-dot-D
  (lambda (D)
    (map drop-dot D)))</span>
 
<span class='i'>(define lex&lt;-reified-name?
  (lambda (r)
    (char&lt;?
      (string-ref (datum-&gt;string r) 0)
      (string-ref &quot;_&quot; 0))))</span>
               
<span class='i'>(define sort-pr
  (lambda (pr)
    (let ((l (lhs pr))
          (r (rhs pr)))
      (cond
        ((lex&lt;-reified-name? r) pr)
        ((lex&lt;=? r l) `(,r . ,l))
        (else pr)))))</span>

<span class='i'>(define rem-xx-from-D
  (lambda (D H)
    (remp not
      (map (lambda (d)
             (let ((d-l (lhs d))
                   (d-r (rhs d)))
	       (let ((H0 (unify-safe d-l d-r H)))
		 (prefix-H H0 H))))
        D))))</span>
            
<span class='i'>(define anyvar?
  (lambda (u H)
    (case-value u
      ((u) (var? (walk u H)))
      ((au du) (or (anyvar? au H)
                   (anyvar? du H)))
      ((u) #f))))</span>

<span class='i'>(define drop-from-D-using-T
  (lambda (H Y N A T D)
    (remp (lambda (d)
	    (exists
	      (T-superfluous-pr? H Y N A T)
	      d))
	  D)))</span>
 
<span class='i'>(define T-superfluous-pr?
  (lambda (H Y N A T)
    (lambda (pr)
      (let ((pr-a (walk (lhs pr) H))
            (pr-d (walk (rhs pr) H)))
        (cond
          ((exists
             (lambda (t)
               (let ((t-a (walk (lhs t) H))
                     (t-d (walk (rhs t) H)))
                 (terms-pairwise=?
                   pr-a pr-d t-a t-d H)))
             T)
           (for-all
             (stays-in-T? H Y N A pr-a pr-d)
             T))
          (else #f))))))</span>

<span class='i'>(define stays-in-T?
  (lambda (H Y N A pr-a pr-d)
    (lambda (t)
      (let ((t-a (walk (lhs t) H))
            (t-d (walk (rhs t) H)))
        (or
          (not
            (terms-pairwise=?
              pr-a pr-d t-a t-d H))
          (untyped-var? H Y N A t-d)
          (pair? t-d))))))</span>
     
<span class='i'>(define terms-pairwise=?
  (lambda (pr-a pr-d t-a t-d H)
    (or (and (term=? pr-a t-a H)
             (term=? pr-d t-a H))
        (and (term=? pr-a t-d H)
             (term=? pr-d t-a H)))))</span>            

<span class='i'>(define D-subsumed
  (lambda (D)
    (let D-subsumed ((D D) (D0 &#39;()))
      (cond
        ((null? D) D0)
        ((or (D-subsumed? (car D) (cdr D))
             (D-subsumed? (car D) D0))
         (D-subsumed (cdr D) D0))
        (else (D-subsumed (cdr D)
                (cons (car D) D0)))))))</span>
 
<span class='i'>(define D-subsumed?
  (lambda (d D0)
    (cond
      ((null? D0) #f)
      (else
       (let ((d^ (unify* (car D0) d)))
         (or (and d^ (eq? d^ d))
             (D-subsumed? d (cdr D0))))))))</span>
 
<span class='i'>(define unify*
  (lambda (d H)
    (unify (map lhs d) (map rhs d) H)))</span>
 
<span class='i'>(define unify*-safe
  (lambda (d H)
    (unify-safe
      (map lhs d)
      (map rhs d)
      H)))</span>

<span class='i'>(define T-subsumed
  (lambda (T)
    (let T-subsumed ((T T) (T0 &#39;()))
      (cond
        ((null? T) T0)
        (else
         (let ((l (lhs (car T)))
               (r (rhs (car T))))
           (cond
             ((or
                (T-subsumed? l r (cdr T))
                (T-subsumed? l r T0))
              (T-subsumed (cdr T) T0))
             (else
              (T-subsumed (cdr T)
                (cons (car T) T0))))))))))</span>
 
<span class='i'>(define T-subsumed? 
  (lambda (l r T)
    (cond
      ((null? T) #f)
      (else
       (let ((l^ (lhs (car T)))
             (r^ (rhs (car T))))
         (or
           (and (eq? r r^) (member* l^ l))
           (T-subsumed? l r (cdr T))))))))</span>
 
<span class='i'>(define member*
  (lambda (x u)
    (cond
      ((eq? x u) #t)
      ((pair? u)
       (or (member* x (car u))
           (member* x (cdr u))))
      (else #f))))</span>    

(<a id='408' tid='407' class='m'>define-syntax</a> <a id='410' tid='409' class='m'>lambdag@</a>
  <span class='i'>(syntax-rules (:)
    ((_ (c) e) (lambda (c) e))
    ((_ (c : H D Y N A T) e)
     (lambda (c)
       (let ((H (c-&gt;H c)) (D (c-&gt;D c))
             (Y (c-&gt;Y c)) (N (c-&gt;N c))
             (A (c-&gt;A c)) (T (c-&gt;T c)))
         e))))</span>)
          
(<a id='394' tid='393' class='m'>define-syntax</a> <a id='396' tid='395' class='m'>lambdaf@</a>
  (<a id='398' tid='397' class='m'>syntax-rules</a> ()
    ((<a id='400' tid='399' class='m'>_</a> () <a id='402' tid='401' class='m'>e</a>) (<a id='404' tid='403' class='m'>lambda</a> () <a id='406' tid='405' class='m'>e</a>))))
 
<span class='i'>(define mzero (lambda () #f))</span>
<span class='i'>(define unit (lambdag@ (c) c))</span>
<span class='i'>(define choice (lambda (c f) (cons c f)))</span>
(<a id='380' tid='379' class='m'>define-syntax</a> <a id='382' tid='381' class='m'>inc</a>
  (<a id='384' tid='383' class='m'>syntax-rules</a> ()
    ((<a id='386' tid='385' class='m'>_</a> <a id='388' tid='387' class='m'>e</a>) (<a id='390' tid='389' class='m'>lambdaf@</a> () <a id='392' tid='391' class='m'>e</a>))))
<span class='i'>(define empty-f (lambdaf@ () (mzero)))</span>
<span class='i'>(define State
  (lambda (H D Y N A T)
    `(,H ,D ,Y ,N ,A ,T)))</span>
<span class='i'>(define empty-c &#39;(() () () () () ()))</span>
         
          
(<a id='346' tid='345' class='m'>define-syntax</a> <a id='348' tid='347' class='m'>case-inf</a>
  (<a id='144' tid='143' class='m'>syntax-rules</a> ()
    ((<span class='i'>_</span> <span class='i'>e</span> <span class='i'>(() e0)</span> ((<a id='146' tid='145' class='m'>f^</a>) <a id='148' tid='147' class='m'>e1</a>) <span class='i'>((c^) e2)</span> <span class='i'>((c f) e3)</span>)
     <span class='i'>(let ((c-inf e))
       (cond
         ((not c-inf) e0)
         ((procedure? c-inf)  (let ((f^ c-inf)) e1))
         ((not (and (pair? c-inf)
                 (procedure? (cdr c-inf))))
          (let ((c^ c-inf)) e2))
         (else (let ((c (car c-inf)) (f (cdr c-inf))) 
                 e3))))</span>)))
 
(<span class='i'>define-syntax</span> <span class='i'>fresh</span>
  (<a id='84' tid='83' class='m'>syntax-rules</a> ()
    ((<a id='86' tid='85' class='m'>_</a> (<a id='88' tid='87' class='m'>x</a> <a id='90' tid='89' class='m'>...</a>) <a id='92' tid='91' class='m'>g0</a> <a id='94' tid='93' class='m'>g</a> <a id='96' tid='95' class='m'>...</a>)
     (<span class='i'>lambdag@</span> <span class='i'>(c)</span>
       (<a id='98' tid='97' class='m'>inc</a>
         (<span class='i'>let</span> ((<a id='100' tid='99' class='m'>x</a> (<a id='102' tid='101' class='m'>var</a> <a id='104' tid='103' class='m'>&#39;</a><a id='106' tid='105' class='m'>x</a>)) <a id='108' tid='107' class='m'>...</a>)
           <span class='i'>(bind* (g0 c) g ...)</span>))))))
 
(<a id='308' tid='307' class='m'>define</a> <a id='310' tid='309' class='m'>bind</a>
  (<span class='i'>lambda</span> <span class='i'>(c-inf g)</span>
    (<span class='i'>case-inf</span> <span class='i'>c-inf</span>
      <span class='i'>(() (mzero))</span>
      ((<a id='24' tid='23' class='m'>f</a>) (<a id='26' tid='25' class='m'>inc</a> (<a id='28' tid='27' class='m'>bind</a> (<a id='30' tid='29' class='m'>f</a>) <a id='32' tid='31' class='m'>g</a>)))
      <span class='i'>((c) (g c))</span>
      (<span class='i'>(c f)</span> (<span class='i'>mplus</span> <span class='i'>(g c)</span> (<a id='2' tid='1' class='m'>lambdaf@</a> () (<a id='4' tid='3' class='m'>bind</a> (<a id='6' tid='5' class='m'>f</a>) <a id='8' tid='7' class='m'>g</a>)))))))                 

(<a id='484' tid='483' class='m'>define-syntax</a> <a id='486' tid='485' class='m'>run</a>
  (<a id='150' tid='149' class='m'>syntax-rules</a> ()
    ((<a id='152' tid='151' class='m'>_</a> <a id='154' tid='153' class='m'>n</a> (<a id='156' tid='155' class='m'>x</a>) <a id='158' tid='157' class='m'>g0</a> <a id='160' tid='159' class='m'>g</a> <a id='162' tid='161' class='m'>...</a>)
     <span class='i'>(take n
       (lambdaf@ ()
         ((fresh (x) g0 g ...
            (lambdag@ (final-c)
              (let ((z ((reify x) final-c)))
                (choice z empty-f))))
          empty-c)))</span>)))
 
(<a id='488' tid='487' class='m'>define-syntax</a> <a id='490' tid='489' class='m'>run*</a>
  (<a id='492' tid='491' class='m'>syntax-rules</a> ()
    ((<a id='494' tid='493' class='m'>_</a> (<a id='496' tid='495' class='m'>x</a>) <a id='498' tid='497' class='m'>g</a> <a id='500' tid='499' class='m'>...</a>) (<a id='502' tid='501' class='m'>run</a> <a id='504' tid='503' class='m'>#f</a> (<a id='506' tid='505' class='m'>x</a>) <a id='508' tid='507' class='m'>g</a> <a id='510' tid='509' class='m'>...</a>))))
 
(<a id='522' tid='521' class='m'>define</a> <a id='524' tid='523' class='m'>take</a>
  (<a id='164' tid='163' class='m'>lambda</a> (<a id='166' tid='165' class='m'>n</a> <a id='168' tid='167' class='m'>f</a>)
    (<span class='i'>cond</span>
      ((<a id='170' tid='169' class='m'>and</a> <a id='172' tid='171' class='m'>n</a> (<a id='174' tid='173' class='m'>zero?</a> <a id='176' tid='175' class='m'>n</a>)) <span class='i'>&#39;</span><span class='i'>()</span>)
      (<span class='i'>else</span>
       (<span class='i'>case-inf</span> <span class='i'>(f)</span> 
         <span class='i'>(() &#39;())</span>
         ((<a id='52' tid='51' class='m'>f</a>) (<a id='54' tid='53' class='m'>take</a> <a id='56' tid='55' class='m'>n</a> <a id='58' tid='57' class='m'>f</a>))
         <span class='i'>((c) (cons c &#39;()))</span>
         (<span class='i'>(c f)</span> (<span class='i'>cons</span> <span class='i'>c</span>
                  (<a id='10' tid='9' class='m'>take</a> (<a id='12' tid='11' class='m'>and</a> <a id='14' tid='13' class='m'>n</a> (<a id='16' tid='15' class='m'>-</a> <a id='18' tid='17' class='m'>n</a> <a id='20' tid='19' class='m'>1</a>)) <a id='22' tid='21' class='m'>f</a>))))))))
 
(<a id='354' tid='353' class='m'>define-syntax</a> <a id='356' tid='355' class='m'>conde</a>
  (<a id='178' tid='177' class='m'>syntax-rules</a> ()
    ((<a id='180' tid='179' class='m'>_</a> (<a id='182' tid='181' class='m'>g0</a> <a id='184' tid='183' class='m'>g</a> <a id='186' tid='185' class='m'>...</a>) (<a id='188' tid='187' class='m'>g1</a> <a id='190' tid='189' class='m'>g^</a> <a id='192' tid='191' class='m'>...</a>) <a id='194' tid='193' class='m'>...</a>)
     <span class='i'>(lambdag@ (c) 
       (inc 
         (mplus* 
           (bind* (g0 c) g ...)
           (bind* (g1 c) g^ ...) ...)))</span>)))
 
(<a id='416' tid='415' class='m'>define-syntax</a> <a id='418' tid='417' class='m'>mplus*</a>
  (<a id='420' tid='419' class='m'>syntax-rules</a> ()
    ((<a id='422' tid='421' class='m'>_</a> <a id='424' tid='423' class='m'>e</a>) <a id='426' tid='425' class='m'>e</a>)
    ((<a id='428' tid='427' class='m'>_</a> <a id='430' tid='429' class='m'>e0</a> <a id='432' tid='431' class='m'>e</a> <a id='434' tid='433' class='m'>...</a>) (<a id='436' tid='435' class='m'>mplus</a> <a id='438' tid='437' class='m'>e0</a> 
                    (<a id='440' tid='439' class='m'>lambdaf@</a> () (<a id='442' tid='441' class='m'>mplus*</a> <a id='444' tid='443' class='m'>e</a> <a id='446' tid='445' class='m'>...</a>))))))
 
(<a id='412' tid='411' class='m'>define</a> <a id='414' tid='413' class='m'>mplus</a>
  (<span class='i'>lambda</span> <span class='i'>(c-inf f)</span>
    (<span class='i'>case-inf</span> <span class='i'>c-inf</span>
      <span class='i'>(() (f))</span>
      ((<a id='196' tid='195' class='m'>f^</a>) (<a id='198' tid='197' class='m'>inc</a> (<a id='200' tid='199' class='m'>mplus</a> (<a id='202' tid='201' class='m'>f</a>) <a id='204' tid='203' class='m'>f^</a>)))
      <span class='i'>((c) (choice c f))</span>
      (<span class='i'>(c f^)</span> (<span class='i'>choice</span> <span class='i'>c</span> (<a id='60' tid='59' class='m'>lambdaf@</a> () (<a id='62' tid='61' class='m'>mplus</a> (<a id='64' tid='63' class='m'>f</a>) <a id='66' tid='65' class='m'>f^</a>)))))))
 
(<a id='312' tid='311' class='m'>define-syntax</a> <a id='314' tid='313' class='m'>bind*</a>
  (<a id='316' tid='315' class='m'>syntax-rules</a> ()
    ((<a id='318' tid='317' class='m'>_</a> <a id='320' tid='319' class='m'>e</a>) <a id='322' tid='321' class='m'>e</a>)
    ((<a id='324' tid='323' class='m'>_</a> <a id='326' tid='325' class='m'>e</a> <a id='328' tid='327' class='m'>g0</a> <a id='330' tid='329' class='m'>g</a> <a id='332' tid='331' class='m'>...</a>) (<a id='334' tid='333' class='m'>bind*</a> (<a id='336' tid='335' class='m'>bind</a> <a id='338' tid='337' class='m'>e</a> <a id='340' tid='339' class='m'>g0</a>) <a id='342' tid='341' class='m'>g</a> <a id='344' tid='343' class='m'>...</a>))))          

<span class='i'>(define c-&gt;H (lambda (c) (car c)))</span>
<span class='i'>(define c-&gt;D (lambda (c) (cadr c)))</span>
<span class='i'>(define c-&gt;Y (lambda (c) (caddr c)))</span>
<span class='i'>(define c-&gt;N (lambda (c) (cadddr c)))</span>
<span class='i'>(define c-&gt;A (lambda (c) (cadddr (cdr c))))</span>
<span class='i'>(define c-&gt;T (lambda (c) (cadddr (cddr c))))</span>
 
<span class='i'>(define absento
  (lambda (u v)
    (lambdag@ (c : H D Y N A T)
      (cond
        ((mem-check u v H) (mzero))
        (else
         (unit (State H D Y N A `((,u . ,v) . ,T))))))))</span>
 
<span class='i'>(define mem-check
  (lambda (u t H)
    (let ((t (walk t H)))
      (cond
        ((pair? t)
         (or (term=? u t H)
             (mem-check u (car t) H)
             (mem-check u (cdr t) H)))
        (else (term=? u t H))))))</span>

<span class='i'>(define term=?
  (lambda (u v H)
    (let ((u (walk u H))
          (v (walk v H)))
      (cond
        ((and (pair? u) (pair? v))
         (and (term=? (car u) (car v) H)
              (term=? (cdr u) (cdr v) H)))
        (else (term=?-nonpair u v H))))))</span>

<span class='i'>(define term=?-nonpair
  (lambda (u v H)
    (cond
      ((eq? u v) #t)
      ((var? u) #f)
      ((var? v) #f)
      ((equal? u v) #t)
      (else #f))))</span>

<span class='i'>(define ground-non-type?
  (lambda (pred)
    (lambda (u H)
      (let ((u (walk u H)))
        (cond
          ((var? u) #f)
          (else (not (pred u))))))))</span>
     
<span class='i'>(define ground-non-symbol?
  (ground-non-type? symbol?))</span>      
 
<span class='i'>(define ground-non-number?
  (ground-non-type? number?))</span>

<span class='i'>(define not-pair? (lambda (x) (not (pair? x))))</span>

<span class='i'>(define ground-pair?
  (ground-non-type? not-pair?))</span>
 
<span class='i'>(define symbolo
  (lambda (u)
    (lambdag@ (c : H D Y N A T)
      (cond
        ((ground-non-symbol? u H) (mzero))
        ((mem-check u N H) (mzero))
        (else (unit (State H D `(,u . ,Y) N A T)))))))</span>
 
<span class='i'>(define numbero 
  (lambda (u)
    (lambdag@ (c : H D Y N A T)
      (cond
        ((ground-non-number? u H) (mzero))
        ((mem-check u Y H) (mzero))
        (else (unit (State H D Y `(,u . ,N) A T)))))))</span>

<span class='i'>(define not-pairo
  (lambda (u)
    (lambdag@ (c : H D Y N A T)
      (cond
        ((ground-pair? u H) (mzero))
        (else (unit (State H D Y N `(,u . ,A) T)))))))</span>

<span class='i'>(define =/=
  (lambda (u v)
    (lambdag@ (c : H D Y N A T)
      (cond
        ((unify u v H) =&gt;
         (lambda (H0)
           (cond
             ((eq? H0 H) (mzero))
             (else
              (let ((d `(,u . ,v)))
                (unit
                  (State H `(,d . ,D) Y N A T)))))))
        (else c)))))</span>    
 
(<a id='304' tid='303' class='m'>define</a> <a id='306' tid='305' class='m'>==</a>
  (<span class='i'>lambda</span> (<a id='34' tid='33' class='m'>u</a> <a id='36' tid='35' class='m'>v</a>)
    <span class='i'>(lambdag@ (c : H D Y N A T)
      (cond
        ((unify u v H) =&gt;
         (lambda (H0)
           (cond
             ((eq? H0 H) (unit c))
             (else
              (cond
                ((==fail-check H0 D Y N A T)
                 (mzero))
                (else
                 (unit (State H0 D Y N A T))))))))
        (else (mzero))))</span>))
 
<span class='i'>(define ==fail-check
  (lambda (H0 D Y N A T)  
    (or (atomic-fail-check H0 Y ground-non-symbol?)
        (atomic-fail-check H0 N ground-non-number?)
        (atomic-fail-check H0 A ground-pair?)        
        (symbolo-numbero-fail-check H0 Y N)
        (=/=-fail-check H0 D)
        (absento-fail-check H0 T))))</span>

<span class='i'>(define atomic-fail-check
  (lambda (H A pred)
    (exists
      (lambda (a)
        (pred (walk a H) H))
      A)))</span>
 
<span class='i'>(define symbolo-numbero-fail-check 
  (lambda (H Y N)
    (let ((N (map (lambda (n) (walk n H)) N)))    
      (exists
        (lambda (y)
          (exists (same-var? (walk y H)) N))
        Y))))</span>
 
<span class='i'>(define absento-fail-check
  (lambda (H T)
    (exists
      (lambda (t) (mem-check (lhs t) (rhs t) H))
      T)))</span>
 
<span class='i'>(define =/=-fail-check
  (lambda (H D)
    (exists
      (lambda (d) (term=? (lhs d) (rhs d) H))
      D)))</span>
 
<span class='i'>(define tagged?
  (lambda (H Y y^)
    (exists (lambda (y) (eqv? (walk y H) y^)) Y)))</span>
 
<span class='i'>(define untyped-var?
  (lambda (H Y N A t)
    (let ((in-type? (lambda (y)
                      (eq? (walk y H) t))))
      (and (var? t)
           (not (exists in-type? Y))
           (not (exists in-type? N))
           (not (exists in-type? A))))))</span>
 
<span class='i'>(define const?
  (lambda (H)
    (lambda (a)
      (not (var? (walk a H))))))</span>
 
<span class='i'>(define drop-from-N-b/c-const
  (lambdag@ (c : H D Y N A T)
    (cond
      ((find (const? H) N) =&gt;
       (lambda (n)
         (State H D Y (remq1 n N) A T)))
      (else c))))</span>
 
<span class='i'>(define drop-from-Y-b/c-const
  (lambdag@ (c : H D Y N A T)
    (cond
      ((find (const? H) Y) =&gt;
       (lambda (y)
         (State H D (remq1 y Y) N A T)))
      (else c))))</span>

<span class='i'>(define drop-from-A-b/c-const
  (lambdag@ (c : H D Y N A T)
    (cond
      ((find (const? H) A) =&gt;
       (lambda (a)
         (State H D Y N (remq1 a A) T)))
      ((memp (lambda (x) (not (walk x H))) A) =&gt;
       (lambda (a*)
         (State H D Y N (remq1 (car a*) A) T)))
      (else c))))</span>
 
<span class='i'>(define remq1
  (lambda (elem ls)
    (cond
      ((null? ls) &#39;())
      ((eq? (car ls) elem) (cdr ls))
      (else (cons (car ls)
              (remq1 elem (cdr ls)))))))</span>
 
<span class='i'>(define same-var?
  (lambda (v)
    (lambda (v^)
      (and (var? v) (var? v^) (eq? v v^)))))</span>
 
<span class='i'>(define find-dup
  (lambda (f H)
    (lambda (set)
      (let loop ((set set))
        (cond
          ((null? set) #f)
          (else
           (let ((e (car set)))
             (let ((e0 (walk e H)))
               (cond
                 ((find (lambda (e1)
                          ((f e0) (walk e1 H)))
                    (cdr set))
                  e)
                 (else
                  (loop (cdr set))))))))))))</span>

<span class='i'>(define drop-from-N-b/c-dup-var
  (lambdag@ (c : H D Y N A T)
    (cond
      (((find-dup same-var? H) N) =&gt;
       (lambda (n)
         (State H D Y (remq1 n N) A T)))
      (else c))))</span>
 
<span class='i'>(define drop-from-Y-b/c-dup-var
  (lambdag@ (c : H D Y N A T)
    (cond
      (((find-dup same-var? H) Y) =&gt;
       (lambda (y)
         (State H D (remq1 y Y) N A T)))
      (else c))))</span>

<span class='i'>(define drop-from-A-b/c-dup-var
  (lambdag@ (c : H D Y N A T)
    (cond
      (((find-dup same-var? H) A) =&gt;
       (lambda (a)
         (State H D Y N (remq1 a A) T)))
      (else c))))</span>

<span class='i'>(define drop-var-from-A-b/c-Y
  (lambdag@ (c : H D Y N A T)
    (let ((Y (map (lambda (y) (walk y H)) Y)))
      (cond
        ((find (lambda (a)
                 (exists (same-var? (walk a H)) Y))
               A) =&gt;
               (lambda (a)
                 (State H D Y N (remq1 a A) T)))
        (else c)))))</span>

<span class='i'>(define drop-var-from-A-b/c-N
  (lambdag@ (c : H D Y N A T)
    (let ((N (map (lambda (n) (walk n H)) N)))
      (cond
        ((find (lambda (a)
                 (exists (same-var? (walk a H)) N))
               A) =&gt;
               (lambda (a)
                 (State H D Y N (remq1 a A) T)))
        (else c)))))</span>

<span class='i'>(define var-type-mismatch?
  (lambda (H Y N A t1 t2)
    (cond
      ((num? H N t1)
       (not (num? H N t2)))
      ((sym? H Y t1)
       (not (sym? H Y t2)))
      ((not-pr? H A t1)
       (not (not (pair? t2))))
      (else #f))))</span>
 
<span class='i'>(define term-ununifiable?
  (lambda (H Y N A t1 t2)
    (let ((t1 (walk t1 H))
          (t2 (walk t2 H)))
      (cond
        ((or (untyped-var? H Y N A t1)
             (untyped-var? H Y N A t2)) #f)
        ((var? t1)
         (var-type-mismatch? H Y N A t1 t2))
        ((var? t2)
         (var-type-mismatch? H Y N A t2 t1))
        ((and (pair? t1) (pair? t2))
         (or (term-ununifiable? H Y N A
               (car t1) (car t2))
             (term-ununifiable? H Y N A
               (cdr t1) (cdr t2))))
        (else (not (eqv? t1 t2)))))))</span>  
    
<span class='i'>(define num?
  (lambda (H N n)
    (let ((n (walk n H)))
      (cond
        ((var? n) (tagged? H N n))
        (else (number? n))))))</span>
     
<span class='i'>(define sym?
  (lambda (H Y y)
    (let ((y (walk y H)))          
      (cond
        ((var? y) (tagged? H Y y))
        (else (symbol? y))))))</span>

<span class='i'>(define not-pr?
  (lambda (H A a)
    (let ((a (walk a H)))          
      (cond
        ((var? a) (tagged? H A a))
        (else (not-pair? a))))))</span>
          
<span class='i'>(define drop-from-D-b/c-d1-occurs-d2
  (lambdag@ (c : H D Y N A T)
    (cond
      ((find (lambda (d)
               (tree-occurs-check (lhs d) (rhs d) H))
         D) =&gt; (lambda (d)
                 (State H (remq1 d D) Y N A T)))
      (else c))))</span>          

<span class='i'>(define split-t-move-to-D-b/c-pair
  (lambdag@ (c : H D Y N A T)
    (cond
      ((exists
         (lambda (t)
           (let ((tr (walk (rhs t) H)))
             (cond
               ((pair? tr)
                ((split-t-move-to-D tr t) c))
               (else #f))))
         T))
      (else c))))</span>
 
<span class='i'>(define split-t-move-to-D
  (lambda (tr t)
    (lambdag@ (c : H D Y N A T)
      (let ((tl (lhs t))
            (tr-a (car tr))
            (tr-d (cdr tr)))
        (let ((t1 `(,tl . ,tr-a))
              (t2 `(,tl . ,tr-d))
              (T (remq1 t T)))
          (let ((T `(,t1 . (,t2 . ,T))))
            (cond
              ((unify tl tr H) =&gt;
               (lambda (H0)
                 (cond
                   ((eq? H0 H)
                    (State H D Y N A T))
                   (else
                     (let ((D `(,t . ,D)))
                       (State H D Y N A T))))))
              (else (State H D Y N A T)))))))))</span> 
 
<span class='i'>(define tree-occurs-check
  (lambda (d-a d-b H)
    (let ((d-a (walk d-a H))
          (d-b (walk d-b H)))
      (cond
        ((var? d-a)
         (occurs-check d-a d-b H))
        ((var? d-b)
         (occurs-check d-b d-a H))
        ((and (pair? d-a) (pair? d-b))
         (or
           (tree-occurs-check (car d-a) (car d-b) H)
           (tree-occurs-check (cdr d-a) (cdr d-b) H)))
        (else #f)))))</span>

<span class='i'>(define move-from-T-to-D-b/c-t2-A
  (lambdag@ (c : H D Y N A T)
    (cond
      ((exists
         (lambda (t)
           (let ((t2 (rhs t)))
             ((movable-t? (walk t2 H) t2 t) c)))
         T))
      (else c))))</span>
 
<span class='i'>(define movable-t?
  (lambda (t2^ t2 t)
    (lambdag@ (c : H D Y N A T)
      (cond
        ((and
           (not (untyped-var? H Y N A t2^))
           (not (pair? t2^)))
           (let ((T (remq1 t T)))
             (cond
               ((unify (lhs t) t2 H) =&gt;
                (lambda (H0)
                  (cond
                    ((eq? H0 H)
                     (State H D Y N A T))
                    (else
                     (let ((D `(,t . ,D)))
                       (State H D Y N A T))))))
               (else (State H D Y N A T)))))
        (else #f)))))</span>
 
<span class='i'>(define drop-from-D-b/c-Y-or-N-or-A
  (lambdag@ (c : H D Y N A T)
    (cond
      ((find (lambda (d)
               (term-ununifiable? 
                 H Y N A (lhs d) (rhs d)))
        D) =&gt;
       (lambda (d)
         (State H (remq1 d D) Y N A T)))
      (else c))))</span>         
         
<span class='i'>(define drop-from-T-b/c-t2-occurs-t1
  (lambdag@ (c : H D Y N A T)
    (cond
      ((find (lambda (t)
               (let ((t-a (walk (lhs t) H))
                     (t-d (walk (rhs t) H)))
                 (mem-check t-d t-a H)))
         T)
       =&gt; (lambda (t)
            (State H D Y N A (remq1 t T))))
      (else c))))</span>         
 
<span class='i'>(define LOF
  (list drop-from-Y-b/c-const
        drop-from-N-b/c-const
        drop-from-A-b/c-const
        drop-var-from-A-b/c-Y
        drop-var-from-A-b/c-N
        drop-from-Y-b/c-dup-var
        drop-from-N-b/c-dup-var
        drop-from-A-b/c-dup-var
        drop-from-D-b/c-Y-or-N-or-A
        drop-from-T-b/c-t2-occurs-t1
        move-from-T-to-D-b/c-t2-A
        split-t-move-to-D-b/c-pair))</span>
 
<span class='i'>(define len-LOF (length LOF))</span>       
 
<span class='i'>(define cycler
  (lambda (c n fns)
    (cond
      ((zero? n) c)
      ((null? fns) (cycler c len-LOF LOF))
      (else
       (let ((c^ ((car fns) c)))
         (cond
           ((not (eq? c^ c))             
            (cycler c^ len-LOF (cdr fns)))
           (else
            (cycler c (sub1 n) (cdr fns)))))))))</span>
               
<span class='i'>(define cycle
  (lambdag@ (c)
    (cycler c len-LOF LOF)))</span>

(<a id='350' tid='349' class='m'>define-syntax</a> <a id='352' tid='351' class='m'>conda</a>
  (<a id='206' tid='205' class='m'>syntax-rules</a> ()
    ((<a id='208' tid='207' class='m'>_</a> (<a id='210' tid='209' class='m'>g0</a> <a id='212' tid='211' class='m'>g</a> <a id='214' tid='213' class='m'>...</a>) (<a id='216' tid='215' class='m'>g1</a> <a id='218' tid='217' class='m'>g^</a> <a id='220' tid='219' class='m'>...</a>) <a id='222' tid='221' class='m'>...</a>)
     <span class='i'>(lambdag@ (c)
       (inc
         (ifa ((g0 c) g ...)
              ((g1 c) g^ ...) ...)))</span>)))
 
(<a id='372' tid='371' class='m'>define-syntax</a> <a id='374' tid='373' class='m'>ifa</a>
  (<a id='224' tid='223' class='m'>syntax-rules</a> ()
    ((<a id='226' tid='225' class='m'>_</a>) (<a id='228' tid='227' class='m'>mzero</a>))
    ((<a id='230' tid='229' class='m'>_</a> (<a id='232' tid='231' class='m'>e</a> <a id='234' tid='233' class='m'>g</a> <a id='236' tid='235' class='m'>...</a>) <a id='238' tid='237' class='m'>b</a> <a id='240' tid='239' class='m'>...</a>)
     (<span class='i'>let</span> <span class='i'>loop</span> <span class='i'>((c-inf e))</span>
       (<span class='i'>case-inf</span> <span class='i'>c-inf</span>
         (() (<a id='242' tid='241' class='m'>ifa</a> <a id='244' tid='243' class='m'>b</a> <a id='246' tid='245' class='m'>...</a>))
         ((<a id='68' tid='67' class='m'>f</a>) (<a id='70' tid='69' class='m'>inc</a> (<a id='72' tid='71' class='m'>loop</a> (<a id='74' tid='73' class='m'>f</a>))))
         <span class='i'>((a) (bind* c-inf g ...))</span>
         ((<a id='38' tid='37' class='m'>a</a> <a id='40' tid='39' class='m'>f</a>) <span class='i'>(bind* c-inf g ...)</span>))))))

(<a id='358' tid='357' class='m'>define-syntax</a> <a id='360' tid='359' class='m'>condu</a>
  (<a id='248' tid='247' class='m'>syntax-rules</a> ()
    ((<a id='250' tid='249' class='m'>_</a> (<a id='252' tid='251' class='m'>g0</a> <a id='254' tid='253' class='m'>g</a> <a id='256' tid='255' class='m'>...</a>) (<a id='258' tid='257' class='m'>g1</a> <a id='260' tid='259' class='m'>g^</a> <a id='262' tid='261' class='m'>...</a>) <a id='264' tid='263' class='m'>...</a>)
     <span class='i'>(lambdag@ (c)
       (inc
         (ifu ((g0 c) g ...)
              ((g1 c) g^ ...) ...)))</span>)))
 
(<a id='376' tid='375' class='m'>define-syntax</a> <a id='378' tid='377' class='m'>ifu</a>
  (<a id='266' tid='265' class='m'>syntax-rules</a> ()
    ((<a id='268' tid='267' class='m'>_</a>) (<a id='270' tid='269' class='m'>mzero</a>))
    ((<a id='272' tid='271' class='m'>_</a> (<a id='274' tid='273' class='m'>e</a> <a id='276' tid='275' class='m'>g</a> <a id='278' tid='277' class='m'>...</a>) <a id='280' tid='279' class='m'>b</a> <a id='282' tid='281' class='m'>...</a>)
     (<span class='i'>let</span> <span class='i'>loop</span> <span class='i'>((c-inf e))</span>
       (<span class='i'>case-inf</span> <span class='i'>c-inf</span>
         (() (<a id='284' tid='283' class='m'>ifu</a> <a id='286' tid='285' class='m'>b</a> <a id='288' tid='287' class='m'>...</a>))
         ((<a id='76' tid='75' class='m'>f</a>) (<a id='78' tid='77' class='m'>inc</a> (<a id='80' tid='79' class='m'>loop</a> (<a id='82' tid='81' class='m'>f</a>))))
         <span class='i'>((c) (bind* c-inf g ...))</span>
         <span class='i'>((c f) (bind* (unit c) g ...))</span>)))))

(<a id='512' tid='511' class='m'>define</a> <a id='514' tid='513' class='m'>succeed</a> (<a id='516' tid='515' class='m'>==</a> <a id='518' tid='517' class='m'>#f</a> <a id='520' tid='519' class='m'>#f</a>))

(<a id='362' tid='361' class='m'>define</a> <a id='364' tid='363' class='m'>fail</a> (<a id='366' tid='365' class='m'>==</a> <a id='368' tid='367' class='m'>#f</a> <a id='370' tid='369' class='m'>#t</a>))

(<a id='456' tid='455' class='m'>define-syntax</a> <a id='458' tid='457' class='m'>project</a>
  (<a id='290' tid='289' class='m'>syntax-rules</a> ()
    ((<a id='292' tid='291' class='m'>_</a> (<a id='294' tid='293' class='m'>x</a> <a id='296' tid='295' class='m'>...</a>) <a id='298' tid='297' class='m'>g</a> <a id='300' tid='299' class='m'>g*</a> <a id='302' tid='301' class='m'>...</a>)
     <span class='i'>(lambdag@ (c : H D Y N A T)
       (let ((x (walk* x H)) ...)
         ((fresh () g g* ...) c)))</span>)))

<span class='i'>(define booleano
  (lambda (x)
    (conde
      ((== #f x) succeed)
      ((== #t x) succeed))))</span>
         
(<a id='452' tid='451' class='m'>define</a> <a id='454' tid='453' class='m'>onceo</a>
  <span class='i'>(lambda (g)
    (condu
      (g)))</span>)

<span class='i'>(define prt
  (lambda args
    (lambdag@ (c)
      (begin           
        (for-each
          (lambda (msg)
            (printf &quot;~s~n&quot; msg))
          args)
        (pretty-print c)
        c))))</span>

</pre>
</div>
</body>
</html>
